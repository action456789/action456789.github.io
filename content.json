{"meta":{"title":"superkk","subtitle":"action456789","description":null,"author":"superkk","url":"http://liumengxia.shop"},"pages":[{"title":"C/C++","date":"2018-05-09T08:06:37.000Z","updated":"2018-05-09T08:06:37.128Z","comments":true,"path":"C-C/index.html","permalink":"http://liumengxia.shop/C-C/index.html","excerpt":"","text":""},{"title":"iOS","date":"2018-05-09T08:06:24.000Z","updated":"2018-05-09T08:06:24.144Z","comments":true,"path":"iOS/index.html","permalink":"http://liumengxia.shop/iOS/index.html","excerpt":"","text":""},{"title":"生活","date":"2018-05-09T08:06:54.000Z","updated":"2018-05-09T08:06:54.923Z","comments":true,"path":"生活/index.html","permalink":"http://liumengxia.shop/生活/index.html","excerpt":"","text":""},{"title":"随笔","date":"2018-05-09T08:07:12.000Z","updated":"2018-05-09T08:07:12.750Z","comments":true,"path":"随笔/index.html","permalink":"http://liumengxia.shop/随笔/index.html","excerpt":"","text":""}],"posts":[{"title":"RxSwift入门一","slug":"RxSwift入门一","date":"2018-05-09T10:01:12.000Z","updated":"2018-05-09T10:01:32.596Z","comments":true,"path":"2018/05/09/RxSwift入门一/","link":"","permalink":"http://liumengxia.shop/2018/05/09/RxSwift入门一/","excerpt":"","text":"[TOC] ObservableObservables是一个事件流的对象 empty通过empty函数，可以生成一个空的流，在这个流中只会产生一个Completed信息。1234let emptyStream: Observable&lt;Int&gt; = Observable.empty()_ = emptyStream.subscribe &#123; event inprint(event) completed&#125; never通过never函数产生的流对象，将不会有任何的事件发生。1234let neverStream: Observable&lt;Int&gt; = Observable.never()_ = neverStream.subscribe(&#123; _ inprint(\"这个方法永远都不会被执行\")&#125;) justjust函数调用之后将会产生一个next事件以及一个Completed事件，其中next可以用来传递数据，最后的Completed事件发送之后将不会再有事件了。简单的说：just函数可以发送一个数据。12345678let justStream = Observable.just(32)_ = justStream.subscribe(&#123; event inprint(event)/*next(32)completed*/&#125;) of将一个集合内的数据所有数据顺序的发送出去。 12345678910let ofStream = Observable.of(0, 1, 2)_ = ofStream.subscribe(&#123; event inprint(event)/*next(0)next(1)next(2)completed*/&#125;) from将一个集合对象（比如数组、Range等）转换成流对象，通过订阅可以获得这个集合对象的所有内容。 12345678910let streamFromArray = Observable.from([0, 1, 2])_ = streamFromArray.subscribe(&#123; (event) inprint(event)/*next(0)next(1)next(2)completed*/&#125;) createcreate 函数是通过利用闭包来生成流对象的函数 12345678910111213141516let myJust = &#123; (singleElement: Int) -&gt; Observable &lt;Int&gt; inreturn Observable.create(&#123; (observer) -&gt; Disposable inobserver.onNext(singleElement)observer.onCompleted()return Disposables.create()&#125;)&#125;let singleElementStream = myJust(32)_ = singleElementStream.subscribe &#123; (event) inprint(event)/*next(32)completed*/&#125; error通过error函数将会生成一个终止的流，这个流中只会产生一次error事件并结束掉。 123456let error = NSError(domain: \"com.RxSwiftDemo.kesen\", code: -1, userInfo: nil)let errorStream: Observable&lt;Int&gt; = Observable.error(error)_ = errorStream.subscribe &#123; (event) inprint(event)error(Error Domain=com.RxSwiftDemo.kesen Code=-1 \"(null)\")&#125; deffereddeffered函数生成的流对象，只有在添加了订阅者才会被创建。 1234567891011121314151617let defferedStream = Observable.deferred &#123; () -&gt; Observable&lt;Int&gt; inreturn Observable.create(&#123; (observer) -&gt; Disposable inobserver.onNext(0)observer.onNext(1)observer.onCompleted()return Disposables.create()&#125;)&#125;_ = defferedStream.subscribe(&#123; (event) inprint(event)/*next(0)next(1)completed*/&#125;) SubjectSubject其实就是Observer，拥有Observer的所有功能，也可以认为是热的Observer。 PublishSubject它仅仅会发送observer订阅之后的事件，也就是说如果sequence上有.Next 的到来，但是这个时候某个observer还没有subscribe它，这个observer就收不到这条信息，它只会收到它订阅之后发生的事件。 ReplaySubject它和PublishSubject不同之处在于它不会漏消息。即使observer在subscribe的时候已经有事件发生过了，它也会收到之前的事件序列。 BehaviorSubject当有observer在订阅一个BehaviorSubject的时候，它首先将会收到Observable上最近发送一个信号（或者是默认值），接着才会收到Observable上会发送的序列。 VariableVariable是BehaviorSubject的封装，它和BehaviorSubject不同之处在于，不能向Variable发送.Complete和.Error，它会在生命周期结束被释放的时候自动发送.Complete。","categories":[],"tags":[]},{"title":"KVO深入解析","slug":"KVO深入解析","date":"2018-05-09T09:18:51.222Z","updated":"2018-05-09T10:25:59.958Z","comments":true,"path":"2018/05/09/KVO深入解析/","link":"","permalink":"http://liumengxia.shop/2018/05/09/KVO深入解析/","excerpt":"","text":"[TOC] iOS 中监听某个值的改变有哪些方法？在一个复杂的，有状态的系统中，当一个对象的状态发生改变，如何通知系统，并对状态改变做出相应的行为是必需考虑的一个问题，在iOS中为这类问题提供了4种解决方法： NSNotifiactaion 和 NSNotificationCenter：通知中心 Delegates：代理， Callback：回调， KVO（Key-Value Observing）：键值观察 Key-Value Observing (简写为KVO)：当指定的对象的属性被修改了，允许对象接受到通知的机制。每次指定的被观察对象的属性被修改的时候，KVO都会自动的去通知相应的观察者。 KVO 是什么？ Objective-C 中的键(key)-值(value)观察(KVO)并不是什么新鲜事物，它来源于设计模式中的观察者模式，其基本思想就是：一个目标对象管理所有依赖于它的观察者对象，并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。 KVO 的用法 如果要监听“对象A”属性值的改变，先要为＂对象A＂的属性注册观察者（假设观察者为“对象B”）。12345- (void)addObserver:(NSObject * _Nonnull)anObserverforKeyPath:(NSString * _Nonnull)keyPathoptions:(NSKeyValueObservingOptions)optionscontext:(void * _Nullable)context anObserver : 观察者，注册 KVO 通知的对象. 其必须实现方法 observeValueForKeyPath:ofObject:change:context:.keyPath : 被观察的属性，其不能为nil.options : 表示要监听那些通知，一般为写 0context : 一些其他的需要传递给观察者的上下文信息，通常设置为 nil options 解释如下：NSKeyValueObservingOptionNew : change 字典中包含 key 改变后的新值NSKeyValueObservingOptionOld : change 字典中包含 key 改变前的旧值NSKeyValueObservingOptionInitial : 在添加观察者的时候立即发送一个通知给观察者,并且是在注册观察者方法返回之前NSKeyValueObservingOptionPrior : 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，这与-willChangeValueForKey:被触发的时间是相对应的。这样，在每次修改属性时，实际上是会发送两条通知。２. 观察者“对象B”实现 observeValueForKeyPath:ofObject:change:context:. 方法３. “对象A”移除监听者 - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;另外注意：keyPath 即被观察的属性只能是 NSString 类型 注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行 KVO 的实现原理键值编码和键值观察是根据 isa-swizzling 技术来实现的，主要依据runtime的强大动态能力。当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法实现真正的通知机制。同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。 重写新类的 class 方法重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。 123456789101112//打印如下内容：NSLog(@&quot;self-&gt;isa:%@&quot;,self-&gt;isa);NSLog(@&quot;self class:%@&quot;,[self class]);//在建立KVO监听前，打印结果为：self-&gt;isa:Personself class:Person//在建立KVO监听之后，打印结果为：self-&gt;isa:NSKVONotifying_Personself class:Person 重写新类的 set 方法新类会重写对应的set方法，是为了在set方法中增加另外两个方法的调用： 1- (void)willChangeValueForKey:(NSString *)key 1- (void)didChangeValueForKey:(NSString *)key 其中，didChangeValueForKey:方法负责调用：1234- (void)observeValueForKeyPath:(NSString *)keyPathofObject:(id)objectchange:(NSDictionary *)changecontext:(void *)context 如果没有 setter 方法，那么 -setValue:forKey 方法会直接调用：1- (void)willChangeValueForKey:(NSString *)key 1- (void)didChangeValueForKey:(NSString *)key 如果在没有使用键值编码且没有使用适当命名的访问起方法的时候，我们只需要显示调用上述两个方法，同样可以使用KVO！ 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344//// ViewController.m// KVO test//// Created by KeSen on 15/9/1.// Copyright (c) 2015年 KeSen. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;KSBaby.h&quot;@interface ViewController ()&#123;KSBaby *_baby;&#125;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO];_baby = baby;// 一般如下使用// [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil];// 在 self 中监听 _baby 的 cry 属性变化[_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld| NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionPrior context:@&quot;ssss&quot;];&#125;- (void)dealloc &#123;[_baby removeObserver:self forKeyPath:@&quot;cry&quot;];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;NSLog(@&quot;keyPath: %@\\n change: %@\\n context: %@\\n&quot;, keyPath, change, context);&#125;- (IBAction)click:(UIButton *)sender &#123;_baby.cry = @&quot;crying&quot;;&#125;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344//// ViewController.m// KVO test//// Created by KeSen on 15/9/1.// Copyright (c) 2015年 KeSen. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;KSBaby.h&quot;@interface ViewController ()&#123;KSBaby *_baby;&#125;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO];_baby = baby;// 一般如下使用// [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil];// 在 self 中监听 _baby 的 cry 属性变化[_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld| NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionPrior context:@&quot;ssss&quot;];&#125;- (void)dealloc &#123;[_baby removeObserver:self forKeyPath:@&quot;cry&quot;];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;NSLog(@&quot;keyPath: %@\\n change: %@\\n context: %@\\n&quot;, keyPath, change, context);&#125;- (IBAction)click:(UIButton *)sender &#123;_baby.cry = @&quot;crying&quot;;&#125;@end 那么：程序启动时输出： 点击按钮后输出： KVO与多线程注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// ViewController.m// KVO test//// Created by KeSen on 15/9/1.// Copyright (c) 2015年 KeSen. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;KSBaby.h&quot;#import &quot;FBKVOController.h&quot;@interface ViewController ()&#123;KSBaby *_baby;FBKVOController *_observer;&#125;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO];_baby = baby;// NSKeyValueObservingOptionNew : change 字典中包含 key 改变后的新值// NSKeyValueObservingOptionOld : change 字典中包含 key 改变前的旧值// NSKeyValueObservingOptionInitial : 在添加观察者的时候立即发送一个通知给观察者,并且是在注册观察者方法返回之前// NSKeyValueObservingOptionPrior : 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，这与-willChangeValueForKey:被触发的时间是相对应的。这样，在每次修改属性时，实际上是会发送两条通知。// 1. 一般用法如下[_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil];// dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew context:@&quot;ssss&quot;];//// &#125;);// 2. 第三方库 FBKVOController 的用法_observer = [[FBKVOController alloc] initWithObserver:self];[_observer observe:_baby keyPath:@&quot;cry&quot; options:NSKeyValueObservingOptionNew block:^(id observer, id object, NSDictionary *change) &#123;NSLog(@&quot;%@, %@&quot;, @&quot;FBKVOController&quot;, change[NSKeyValueChangeNewKey]);&#125;];&#125;- (void)dealloc &#123;[_baby removeObserver:self forKeyPath:@&quot;cry&quot;];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;NSLog(@&quot;%@&quot;, [NSThread currentThread]);NSLog(@&quot;keyPath: %@\\n change: %@\\n context: %@\\n&quot;, keyPath, change, context);&#125;- (IBAction)click:(UIButton *)sender &#123;// _baby.cry = @&quot;crying&quot;;// 1. 注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;_baby.cry = @&quot;cry again&quot;;&#125;);&#125;@end KVO 监听 NSMutableArray 的内容变化 将数组封装到一个对象中 给这个对象添加 KVO 监听 使用 [self.arrayObject mutableArrayValueForKey:@”array”] 获取数组对象，对数组对象今天添加删除操作，只有这样触发的数组才会触发 kvo 参考：http://www.cppblog.com/kesalin/archive/2012/11/17/kvo.htmlhttp://ningandjiao.iteye.com/blog/2009729http://www.bkjia.com/IOSjc/993206.htmlhttp://blog.csdn.net/wzzvictory/article/details/9674431","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"iOS SDK 开发","slug":"iOS-SDK-开发","date":"2018-05-09T07:07:25.000Z","updated":"2018-05-09T08:12:01.033Z","comments":true,"path":"2018/05/09/iOS-SDK-开发/","link":"","permalink":"http://liumengxia.shop/2018/05/09/iOS-SDK-开发/","excerpt":"","text":"一、Framework与.a基础此处等下一期 二、工程嵌套联调静态库1、新建一个主工程 2、新建一个Library工程 3、将静态库工程拖到主工程文件夹下 如果你要拖到其他目录，就要改Library Search Paths 4、将Library工程下.a文件拖入主工程的Link Binary With Libraries如果有必要（运行时崩溃），将静态库需要加入 Embedded Binaries 中 5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程如下图给主工程添加对子工程的依赖，这样每次编译主工程的时候也会编译子工程。 三、在静态库中使用图片以及 xib 等资源文件1、添加 Bundle Target 因为iOS框架中没有bundle，要选中OS X框架找到bundle，如下图 2、将资源文件加入 bundle 中将工程中的资源文件都加入到刚刚建的bundle中，如xib、图片。点+号或直接拖都行。 3、iOS Deployment Target改为你支持的最低版本 4、设置base SDK 为latest iOS 5、编译 Bundle 6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程 7、加载 Bundle 里的资源文件7.1、加载图片使用运行时替换 [UIImage imageNamed:]方法，减少修改代码的工作量。相关代码在以下几个类中12345678// 在AppDelegate中执行以下代码即可swizzle 所有 [UIImage imageNamed:]#import &quot;UIImage+Swizzle.h&quot;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [UIImage kk_autoLoadImageInBundle]; return YES;&#125; UIImage+Swizzle.m 123456789101112131415161718// // 修改所有的 [UIImage imageNamed:]的实现，改为先从同一项目中的 .bundle 文件中加载，没有再使用系统默认实现加载+ (void)kk_autoLoadImageInBundle &#123; SEL original = @selector(imageNamed:); SEL new = @selector(hook_kk_imageWithName:); [self kk_swizzleClassMethod:original with:new];&#125;// 1. 从 .bundle 中加载图片// 2. 按照默认的方法加载图片+ (instancetype)hook_kk_imageWithName:(NSString *)imageName &#123; UIImage *image = [NSBundle kk_imageInBundle:kk_BundleName imageName:imageName]; if (!image) &#123; image = [self hook_kk_imageWithName:imageName]; &#125; return image;&#125; NSObject+Swizzle.m 1234567891011121314151617181920212223242526272829#import &quot;NSObject+Swizzle.h&quot;#import &lt;objc/objc.h&gt;#import &lt;objc/runtime.h&gt;@implementation NSObject (Swizzle)+ (BOOL)kk_swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel &#123; Class class = object_getClass(self); Method originalMethod = class_getInstanceMethod(class, originalSel); Method newMethod = class_getInstanceMethod(class, newSel); if (!originalMethod || !newMethod) return NO; method_exchangeImplementations(originalMethod, newMethod); return YES;&#125;+ (BOOL)kk_swizzleClassMethod:(SEL)originalSel with:(SEL)newSel &#123; Class class = object_getClass(self); Method originalMethod = class_getClassMethod(class, originalSel); Method newMethod = class_getClassMethod(class, newSel); if (!originalMethod || !newMethod) return NO; method_exchangeImplementations(originalMethod, newMethod); return YES;&#125;@end 7.2、加载 xib7.2.1 加载xib对应的UIViewController需要重写xib对应控制器的 init 方法，否则可能出现找不到xib文件导致crash参考bundle打包xib文件 12345678910- (instancetype)init &#123; NSBundle *bundle = [NSBundle kk_bundleWithName:kBundleTargetName]; self = [super initWithNibName:@&quot;CalculatePriceViewController&quot; bundle:bundle]; return self;&#125; 代码参见：github](https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)) 7.2.1 加载xib对应的UIVIew需要重写xib对应View的 init 方法，，否则可能出现找不到xib文件导致crash123456789101112@implementation OfflineView//重写要加载的view的init方法- (instancetype)init &#123; if (self = [super init]) &#123; NSBundle *bundle = [NSBundle kk_bundleWithName:kk_BundleName]; self = [[bundle loadNibNamed:@&quot;OfflineView&quot; owner:self options:nil] lastObject]; &#125; return self;&#125;@end 7.3、加载 Localizable.strings第一步：在Bundle中新建国际化文件 第二步：添加语言，并将之前的国际化文件中的代码复制过来 第三步：使用 NSBundle+Resource 如下方法12+ (NSString *)mj_localizedStringForKey:(NSString *)key;+ (NSString *)mj_localizedStringForKey:(NSString *)key value:(NSString *)value; 然后使用如下宏定义1234// 加载 Bundle 中的国际化语句#undef NSLocalizedString#define NSLocalizedString(key, comment) \\[NSBundle mj_localizedStringForKey:(key)] 然后就可以自动的加载Bundle中的字符串了 四、将整个App打包为Framework需要注意的地方 整个项目都要解除 AppDelegate 的依赖，AppDelegate不能打入Framework中 图片和xib文件需要按照 三 中的处理 可以使用 runtime 动态加载图片和xib文件，减少工作量 注意点：bundle中的国际化文件需要重新新建，添加语言，然后将之前App中的内容复制过来，直接拖进去是无效的 实际操作中存在的问题 图片同时存在@2x和@3x后缀导致加载的图片为nil的问题解决办法为只要@2x的图片 五、使用 appledoc 生成文档官网 安装brew install appledoc 查看版本appledoc --version 查看帮助appledoc --help 生成文档1appledoc --output ./doc --project-name &quot;D103Framework&quot; --project-company &quot;RICISUNG&quot; --company-id &quot;RICISUNG&quot; . ”.“ 和前面的符号一定要加 空格 否则就会报错。 参考iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调](http://www.cnblogs.com/zhanglinfeng/p/5494762.html))iOS framework静态库中使用xib和图片资源详解","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"iOS11新特性","slug":"iOS11新特性","date":"2017-12-22T15:02:12.000Z","updated":"2018-05-09T08:12:06.230Z","comments":true,"path":"2017/12/22/iOS11新特性/","link":"","permalink":"http://liumengxia.shop/2017/12/22/iOS11新特性/","excerpt":"","text":"[TOC] iOS11 大标题12345// 导航控制器的`prefersLargeTitles`为大标题的总开关navigationController?.navigationBar.prefersLargeTitles = true// 各个控制器可以自己通过 largeTitleDisplayMode，如果导航控制器的 `prefersLargeTitles` 为 NO，largeTitleDisplayMode 将没有效果navigationItem.largeTitleDisplayMode = .never iOS11 导航栏搜索框1234567891011121314151617let searchResultsVC = SearchResultTabelViewVC(nibName: nil, bundle: nil)lazy var searchController: UISearchController = &#123;let vc = UISearchController(searchResultsController: searchResultsVC)vc.searchResultsUpdater = self.searchResultsVCvc.hidesNavigationBarDuringPresentation = truevc.dimsBackgroundDuringPresentation = truevc.searchBar.placeholder = &quot;搜索设备&quot;vc.searchBar.enablesReturnKeyAutomatically = falsevc.searchBar.sizeToFit()return vc&#125;()navigationItem.searchController = searchControllernavigationItem.hidesSearchBarWhenScrolling = false iOS11 Safe Area Insets1additionalSafeAreaInsets = UIEdgeInsets(top: 100, left: 0, bottom: 100, right: 100) UITableView separatorInsetReference123456tableView.estimatedRowHeight = 0tableView.estimatedSectionHeaderHeight = 0tableView.estimatedSectionFooterHeight = 0tableView.separatorInsetReference = .fromAutomaticInsetstableView.separatorInset.left = 60 UITableViewCell 左划、右划123456789101112131415161718192021222324252627// iOS11 UITableViewCell 左划override func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? &#123;let action = UIContextualAction(style: .normal, title: &quot;收藏&quot;) &#123; (action, view, completionHandler) in// 执行收藏操作// ...completionHandler(true)&#125;action.image = imageLiteral(resourceName: &quot;favorite&quot;)action.backgroundColor = UIColor.redlet configuration = UISwipeActionsConfiguration(actions: [action])return configuration&#125;// iOS11 UITableViewCell 右划override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? &#123;let action = UIContextualAction(style: .destructive, title: &quot;删除&quot;) &#123; (action, view, completionHandler) in// remove item// ...completionHandler(true)&#125;let configuration = UISwipeActionsConfiguration(actions: [action])return configuration&#125; 代码见https://github.com/action456789/iOS11Demo","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"git命令大全","slug":"git命令大全","date":"2017-09-09T13:09:46.000Z","updated":"2018-05-09T10:10:22.280Z","comments":true,"path":"2017/09/09/git命令大全/","link":"","permalink":"http://liumengxia.shop/2017/09/09/git命令大全/","excerpt":"","text":"[TOC] #基本概念 master指针：指向最新的提交 资料http://sfault-image.b0.upaiyun.com/37/92/37923f2478edc5709b36562b26c9e008 #全局配置$ git config --global user.name &quot;kk&quot;$ git config --global user.email &quot;superkesen@gmail.com&quot; 编辑模式查看全局设置：git config --global -e 列表形式查看全局设置：git config --global -l 使用GitHub时，在本地创建SSH Keyssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果一切顺利的话，可以在用户主目录里（~/.ssh）找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 远程仓库 克隆远程仓库到本地git clone git@github.com:michaelliao/gitskills.git 克隆远程仓库某个分支到本地git clone -b &lt;branch&gt; &lt;remote_repo&gt;例如： git clone -b 指定的分支名字 给本地仓库指定远程仓库 关联GitHub仓库：git remote add origin git@github.com:michaelliao/learngit.git 显示远程仓库：git remote show origin第一次推送使用：git push -u origin 分支名称之后推送使用：git push origin maste 查看远程仓库地址git remote -v 取消关联远程仓库git remote rm origin 初始化git仓库git initgit add .git commit -m “xxxx&quot; 文件操作删除所有文件git rm * -r删除文件夹git rm filename -r忽略无需版本控制的文档echo “*.txt” &gt; .gitignore 日志查看commit日志git reflog或git log 分支管理 查看当前所在分支git branch -a 切换到某个分支git checkout 分支名字 创建本地分支并切换到创建的分支：git checkout -b your_branch 提交该分支到远程仓库git push origin dev 追踪远程分支git branch --track release_2.3.0 origin/HEAD:refs/for/release_2.3.0 将本地分支push到远程分支，（远程会自动创建your_branch分支），并关联本地分支与远程分支git push -u origin your_branch 删除远程分支git push origin --delete &lt;branchName&gt; 删除本地分支git branch -d your_branch 本地提交回滚 先重置本地在上次提交之后的修改（如果需要的话）git checkout *.m 重置为远程仓库的最新版本soft表示本地的修改还在本地文件中，不加的话那么本地的修改也没了git reset HEAD^ --soft 拉取远程代码时冲突 保存本地修改到暂存区git stash 拉取远程代码git pull 将暂存区内容恢复到本地，有冲突时先解决冲突git stash pop git stash 的使用 列出所有暂时保存的工作git stash list 恢复某个暂时保存的工作 git stash apply stash@{1} 保存stash时设置stash名称git stash save &quot;my_stash&quot; 丢弃最近一次stash的文件git stash drop 合并某次提交 merge a specific commit in Gitgit cherry-pick d42c389f git merge 后 push 到 Gerrit 失败，提示 no new changes 在 git merge 的时候，加上 --no-ff 参数，是为了让它生成一个新的 commit，这样就可以提交了~（不过生成的 gerrit change 是看不到改动信息的） tag 操作 查看taggit tag 创建 本地 taggit tag 1.0.0或者git tag -m &quot;first release&quot; 0.1.0 推送 本地 tag 到远程服务器git push origin 1.0.0 或者推送所有tags到远程服务器git push --tags 删除本地 taggit tag -d 1.0.0 删除远程 tag 先删除本地 taggit tag -d 1.0.0 然后pushgit push origin --delete tag 1.0.0fatal: remote origin already exists.错误解决 先删除远程 Git 仓库 git remote rm origin2 再添加远程 Git 仓库 git remote add origin git@github.com:FBing/Java-code-generator git ignore 创建.gitignore文件touch .gitignore忽略规则示例123456# 这是注释行，将被忽略*.a # 忽略所有以.a为扩展名的文件 !lib.a # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略/TODO # 只忽略此目录下的TODO文件，子目录中的TODO文件不忽略build/ # 忽略所有build目录下的文件，但如果是名为build的文件则不忽略doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略 例如忽略下图的GPUImage.framework框架1SystemVedio/GPUImage/GPUImage.framework 只追踪某几个文件1234567#忽略所有文件，注意放在开头/*#除src文件夹外!/src#除bin文件夹外!/bin #总的效果就是git只跟踪src和bin两个文件夹 merge 与 rebase 的区别 作者：王靖轩链接：https://www.zhihu.com/question/36509119/answer/131513261来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 搞清楚这个问题首先要搞清楚merge和rebase背后的含义。 merge：会产生一次合并提交先看merge，官方文档给的说明是：git-merge - Join two or more development histories together 顾名思义，当你想要两个分支交汇的时候应该使用merge。根据官方文档给的例子，是master merge topic，如图：A—B—C topic/ \\D—E—F—G—H master然而在实践中，在H这个commit上的merge经常会出现merge conflict。为了避免解决冲突的时候引入一些不必要的问题，工程中一般都会规定no conflict merge。比如你在github上发pull request，如果有conflict就会禁止merge。 所以才会有题主问的问题：在当前的topic分支，想要引入master分支的F、G commit上的内容以避免merge conflict，方便最终合并到master。 这种情况下用merge当然是一个选项。用merge代表了topic分支与master分支交汇，并解决了所有合并冲突。然而merge的缺点是引入了一次不必要的history join。如图：A–B–C-X topic/ / \\D—E—F—G—H master其实仔细想一下就会发现，在引入master分支的F、G commit这个问题上，我们并没有要求两个分支必须进行交汇(join)，我们只是想避免最终的merge conflict而已。 rebase：将其他分支的内容整合到当前分支，改变当前分支branch out的位置rebase是另一个选项。rebase的含义是改变当前分支branch out的位置。这个时候进行rebase其实意味着，将topic分支branch out的位置从E改为G，如图：A—B—C topic/D—E—F—G master在这个过程中会解决引入F、G导致的冲突，同时没有多余的history join。但是rebase的缺点是，改变了当前分支branch out的节点。如果这个信息对你很重要的话，那么rebase应该不是你想要的。rebase过程中也会有多次解决同一个地方的冲突的问题，不过可以用squash之类的选项解决。个人并不认为这个是rebase的主要问题。 综上，其实选用merge还是rebase取决于你到底是以什么意图来避免merge conflict。实践上个人还是偏爱rebase。一个是因为branch out节点不能改变的情况实在太少。另外就是频繁从master merge导致的冗余的history join会提高所有人的认知成本。","categories":[],"tags":[]},{"title":"Mac安装MQTT服务器","slug":"Mac安装MQTT服务器","date":"2017-03-09T07:08:59.000Z","updated":"2018-05-09T08:12:21.661Z","comments":true,"path":"2017/03/09/Mac安装MQTT服务器/","link":"","permalink":"http://liumengxia.shop/2017/03/09/Mac安装MQTT服务器/","excerpt":"emqttd windows版安装具体以官方文档为主 下载http://emqtt.io/docs/v2/install.html#installing-on-windows 进入下载后的bin目录下cd C:\\Users\\kk\\Desktop\\emqttd\\bin\\然后执行emqttd console 进入Web管理控制台(Dashboard)控制台地址: http://127.0.0.1:18083默认用户: admin，密码：public","text":"emqttd windows版安装具体以官方文档为主 下载http://emqtt.io/docs/v2/install.html#installing-on-windows 进入下载后的bin目录下cd C:\\Users\\kk\\Desktop\\emqttd\\bin\\然后执行emqttd console 进入Web管理控制台(Dashboard)控制台地址: http://127.0.0.1:18083默认用户: admin，密码：public 或者使用 mosquitto 安装brew install mosquitto 配置服务器进入目录/usr/local/Cellar/mosquitto 进入响应版本下目录，我这里是1.4.11_2找到/etc/mosquitto/mosquitto.conf文件，修改mosquitto.conf可以对服务器进行配置 启动服务器进入sbin目录：/usr/local/Cellar/mosquitto/1.4.11_2/sbin然后执行：./mosquitto -c /usr/local/Cellar/mosquitto/1.4.11_2/etc/mosquitto/mosquitto.conf -d 参考：http://blog.csdn.net/pz0605/article/details/51970568","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"Autolayout高级","slug":"Autolayout高级","date":"2016-11-09T12:23:21.000Z","updated":"2018-05-09T08:11:51.374Z","comments":true,"path":"2016/11/09/Autolayout高级/","link":"","permalink":"http://liumengxia.shop/2016/11/09/Autolayout高级/","excerpt":"","text":"[TOC] intrinsicContentSizeIntrinsic Content Size：固有大小。意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。 比如：大家都知道在使用 AutoLayout 的时候，UILabel 就不用指定尺寸大小，只需指定位置即可，就是因为，只要确定了文字内容，字体等信息，它自己就能计算出大小来。 UILabel，UIImageView，UIButton 等组件及某些包含它们的系统组件都有 Intrinsic Content Size 属性。 Content Hugging 约束（不想变大约束）如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要拉伸的时候拉伸。 Content Compression Resistance 约束（不想变小约束）如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要压缩的时候压缩。 例如： Top Layout GuidetopLayoutGuide属性表示不希望被透明的状态栏或导航栏遮挡的内容范围的最高位置。这个属性的值是它的length属性的值（topLayoutGuide.length） 这个值可能由当前的ViewController或这个ViewController所属的NavigationController或TabBarController决定，有如下情况： 一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。 包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义： 如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。 如果状态栏可见，topLayoutGuide表示状态栏的底部。 如果都不可见，表示ViewController的上边缘。 总之是屏幕上方任何遮挡内容的栏的最底部。 Safe Area*作用：取代topLayoutGuide和bottomLayoutGuide** safeArea是描述你的视图部分不被任何内容遮挡的方法。 改变布局的方法一、 setNeedsLayout与layoutIfNeeded更新Autolayout后，如何要立即刷新布局，还要依次调用以下两个方法 123456// 立即刷新布局（自己和subview的）self.view.setNeedsLayout()self.view.layoutIfNeeded() setNeedsLayout给当前 UIView 立一个 flag，以表示后续应该调用 layoutSubviews方法，以调整当前视图及其子视图的布局。 layoutIfNeeded如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews） 二、 layoutSubviews触发时机——Frame改变就会触发，具体如下 初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发 addSubview会触发layoutSubviews 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化 滚动一个UIScrollView会触发layoutSubviews 旋转Screen会触发父UIView上的layoutSubviews事件 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 何时重写 layoutSubviews 方法1当我们在某个类的内部调整子视图位置时，需要调用；如果你想要在外部设置subviews的位置，就不要重写。 三、sizeToFit调用sizeToFit的时候，系统会根据内容的帮我布局一个它认为最合适的大小。 我们一般在不方便手动布局的时候才调用sizeToFit方法。比如 navigationBar中对navigationItem的设置，（添加两个视图以上的控件到Item） toolBar中的对UIBarButtonItem的设置（一般我们还要添加弹簧控件） 上述两种场合就可以用sizeToFit这个方法，来让系统给我们做自动布局。（注意：如果就添加一个控件的话，我们直接设置fram也是可以的） 在tabBar中我们不能手动的添加的子控件，因为tabBar是根据控制器系统默认自动添加的tabBarItem。（猜想系统可能也会自动调用了这个方法） UILabel中添加文字，然后让调整label的大小来适应文字，我们也调用sizeToFit的方法。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"iOS调试内存泄露","slug":"iOS调试内存泄露","date":"2016-10-09T15:11:07.000Z","updated":"2018-05-09T08:12:11.566Z","comments":true,"path":"2016/10/09/iOS调试内存泄露/","link":"","permalink":"http://liumengxia.shop/2016/10/09/iOS调试内存泄露/","excerpt":"","text":"[TOC] Xcode8使用Memory Graph 第一步：真机下运行APP后，点击 第二步：查看issue面板，注意选择右边Runtime 第三步：查看可能出现的内存泄露比如上图的 1 instance of __NSMallocBlock_leaked，点击后出现下图原因在于如下代码 12345678910group.didSelectedRowBlock = &#123; [unowned self, group] row inguard let indexPaths = group.selectedIndexPaths else &#123;return&#125;if indexPaths.count &gt; 0 &#123;self.shouldAdd = truelet row = (indexPaths.firstObject as! IndexPath).rowself.deviceAttri?.attrValue = String(row)&#125; else &#123;self.shouldAdd = false&#125;&#125; group的block中又使用了group，导致了循环引用，虽然使用了[unowned group]，事实证明并没有效果最后的解决办法是修改didSelectedRowBlock的接口，直接将selectedIndexPaths参数传入block参数中:123456789group.didSelectedRowBlock = &#123; [unowned self] indexPaths inguard let indexPaths = indexPaths else &#123;return&#125;if indexPaths.count &gt; 0 &#123;self.shouldAdd = trueself.deviceAttri?.attrValue = String(indexPaths.first!.row)&#125; else &#123;self.shouldAdd = false&#125;&#125; 第四步：在 debug 页面查看内存泄露情况有叹号说明需要注意可能存在内存泄露，可以看到 CoreFoundation中也可能存在内存泄露情况 使用Instruments的Leaks工具Time Profiler 查看多个线程里那些方法费时过多的方法 Call Tree上会默认按照费时的线程进行排序，单个线程中会也会按照对应的费时方法排序 Allocations 可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置 具体操作 在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation， 切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation， 这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。 Leak可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics&gt;Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。 其他调试方法勾选Address Sanitizer可以在运行时看到坏内存访问情况","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"使用WireShark 调试真机网络","slug":"使用WireShark-调试真机网络","date":"2016-10-09T07:09:37.000Z","updated":"2018-05-09T08:11:44.561Z","comments":true,"path":"2016/10/09/使用WireShark-调试真机网络/","link":"","permalink":"http://liumengxia.shop/2016/10/09/使用WireShark-调试真机网络/","excerpt":"","text":"使用WireShark 调试真机网络需求：调试UIWebView加载缓慢问题 获取iPhone的UDID 2：根据获取的 UDID 创建一个虚拟的网卡rvictl -s &lt;UDID&gt; 通过 ifconfig 可以看到多了一个 rvi0接口通过 rvictl -l 命令可以列出所有挂接的虚拟接口 3: 在 Wireshark 首页选择 rvi0，使用默认的 Capture Options 即可开始对 iPhone 进行抓包。 其中 iPhone 手机连接 WiFi 动态获取的 IP 地址为 192.168.100.1。 黑色的内容表示遇到错误，需要重点关注关闭wifi，可以抓取移动网络数据包 -4 ： 使用rvictl -x命令删除虚拟接口, 使用 iPhone 的 UDID 作为参数。 WireShark 抓包技巧 第一步：找到请求网址的 IP 地址方法一：用ping命令得到对应的IP地址（可能不对，此时要用方法二） 方法二：使用DNS包来确定IP地址 注意手机上 DNS 解析的结果并不总是和电脑上的解析结果一致。这种情况下我们可以通过查看 DNS 数据包来确定DNS 是基于 UDP 的协议，不会有 TCP 重传 第二步：过滤 IP 地址 第三步：确定端口号 注意红框中的 SourcePort，这是客户端端口。我们知道 HTTP 支持并发请求，不同的并发请求肯定是占用不同的端口。所以在图中看到的上下两个数据包，并非一定是请求与响应的关系，他们可能属于两个不同的端口，彼此之间毫无关系，只是恰好在时间上最接近而已。 如果只想显示某个端口的数据，可以使用: ip.addr == 220.194.203.68 and tcp.dstport == 52914 如果只想看 HTTP 协议的 GET 请求与响应，可以使用 ip.addr == 220.194.203.68 and (http.request.method == “GET” || http.response.code == 200)来过滤。 如果想看丢包方面的数据，可以用 ip.addr == 220.194.203.68 and (tcp.analysis.fast_retransmission || tcp.analysis.retransmission) # 参考 http://ios.jobbole.com/93159/ http://blog.csdn.net/phunxm/article/details/38590561","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"《Effective Objective-C 2.0》读书笔记","slug":"《Effective-Objective-C-2-0》读书笔记","date":"2016-08-12T15:05:51.000Z","updated":"2018-05-09T10:06:26.916Z","comments":true,"path":"2016/08/12/《Effective-Objective-C-2-0》读书笔记/","link":"","permalink":"http://liumengxia.shop/2016/08/12/《Effective-Objective-C-2-0》读书笔记/","excerpt":"","text":"[TOC] 多用类型常量，少用 #define 对于局部常量(.m文件中)， 使用 static 声明表明变量只在本文件中可见，所以无需前缀 同时使用 static const 关键字与#define 效果相同，好处在于带有类型信息。1static const CGFloat kTopViewHeight = 40; 对于全局常量 由于全局使用，使用类名做前缀 在 .h 文件中使用 extern 声明 1extern NSString * const KKSlideTabBarBgColor; 在 .m 文件中定义 1NSString * const KKSlideTabBarBgColor = @&quot;name&quot;; NS_ENUM 与 NS_OPTIONS 使用 NS_ENUM 和 NS_OPTIONS 可以指定底层数据类型，而且可以保证系统兼容 当多种状态可以互相组合时，使用 NS_OPTIONS，否则使用 NS_ENUM 命名规则：前缀+状态 1234567891011121314151617typedef NS_ENUM(NSUInteger, GDFConnectionState) &#123;GDFConnectionStateDisconnected,GDFConnectionStateConnecting,GDFConnectionStateConnected,&#125;;GDFConnectionStateDisconnected,GDFConnectionStateConnecting,GDFConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, GDFDirection) &#123;GDFDirectionUp = 1 &lt;&lt; 0,GDFDirectionDown = 1 &lt;&lt; 1,GDFDirectionLeft = 1 &lt;&lt; 2,GDFDirectionRight = 1 &lt;&lt; 3,&#125;; 消息转发 message forwarding 动态方法解析 resolve method 动态方法解析是消息转发的第一步，在这里处理，效率最高@dynamic 属性 使编译器不自动生成实例变量及存储方法调用的方法：1+ (BOOL)resolveInstanceMethod:(SEL)selector 代码参见：Runtime.md 动态方法解析 resolve method 方法调配 method swizzling 作用1：在运行死交换两个方法的实现 1234// 根据方法名找到方法的实现class_getInstanceMethod(__unsafe_unretained Class cls, SEL name)// 交换两个方法的实现method_exchangeImplementations(Method m1, Method m2) 作用2：为既有的方法实现添加新功能——调试黑盒方法，为完全不知道具体实现的方法添加日志功能 123456789101112131415@implementation NSString (EOC)+ (void)load &#123;Method originalMethod = class_getInstanceMethod([NSString class],@selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class],@selector(eoc_myLowercaseString));method_exchangeImplementations(originalMethod, swappedMethod);&#125;- (NSString *)eoc_myLowercaseString &#123;NSString *lowercase = [self eoc_myLowercaseString];NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);return lowercase;&#125; 类对象1234567891011121314151617181920212223// 对象结构体// isa 指针指向类对象struct objc_object &#123;Class isa;&#125;;// 类结构体// 1. 这个结构存放类的元数据，实例中的方法，变量等信息就存储在类对象中// 2. isa 指针指向元类(metaclass)，元类描述类对象本身所具有的元数据，类方法就存储在元类中// 3. 每个类只有一个类对象，每个类对象只有一个元类typedef struct objc_class *Class;struct objc_class &#123;Class isa;Class super_class;const char *name;long version;long info;long instance_size;struct objc_ivar_list *ivars;struct objc_method_list **methodLists;struct objc_cache *cache;struct objc_protocol_list *protocols;&#125;; 前缀 苹果保留了两字符前缀，我们应该使用三字符前缀 C函数名应该加上前缀 头文件中的全局变量需要加上前缀 为私有方法名添加前缀（例如p_），用于区分哪些方法是私有的，哪些是公有的，私有方法可以随意改动，公有方法则要三思而后行。 为第三方类添加分类时，分类中的方法要增加前缀，可以避免覆盖原有方法。 使用段位缓存代理能否响应某个方法 段位：结构体可以设置其成员所占的二进制位数 12345struct &#123;unsigned int fieldA : 8; // fieldA 占 8 个二进制位，即 0 ~ 255unsigned int fieldB : 4;unsigned int fieldC : 2;unsigned int fieldD : 1;&#125;_delegateFlag; 实例： 12345678@protocol KKSlideTabBarViewDelegate &lt;NSObject&gt;@optional;- (void)slideTabBarView:(KKSlideTabBarView *)tabBar pageChangedFromIndex:(NSUInteger)from toIndex:(NSUInteger)to;- (void)slideTabBarView:(KKSlideTabBarView *)tabBar itemMoreClicked:(UIButton *)itemMore;@end@interface KKSlideTabBarView : UIView@property (nonatomic,weak) id &lt;KKSlideTabBarViewDelegate&gt; delegate;@end 123456789101112@implementation KKSlideTabBarView &#123; struct &#123;unsigned int didPageChangedHandle : 1;unsigned int didItemMoreClickdHandle : 1;&#125;_delegateFlags;&#125;- (void)setDelegate:(id&lt;KKSlideTabBarViewDelegate&gt;)delegate &#123;_delegate = delegate;_delegateFlags.didPageChangedHandle = [self.delegate respondsToSelector:@selector(slideTabBarView:pageChangedFromIndex:toIndex:)];_delegateFlags.didItemMoreClickdHandle = [self.delegate respondsToSelector:@selector(itemMoreClicked:)];&#125; 123456- (void)itemMoreClicked:(UIButton *)sender&#123;if (_delegateFlags.didItemMoreClickdHandle) &#123;[self.delegate slideTabBarView:self itemMoreClicked:sender];&#125;&#125;&#125; NSOperation 与 GCD 优缺点 GCD 优点：纯 C api，更加轻量级。而operation 是对象，更加重量级 NSOperation 优点： 操作加入队列后可以取消（已经启动的任务无法取消） 可以自动操作之间的依赖关系 可以使用 KVO 监控 NSOperation 对象的属性，比如通过 isCancelled 判断任务是否取消， isFinished 属性判断任务是否完成 可以指定每个操作的优先级，而 GCD 只能指定队列的优先级 可以自定义 operation 对象 使用 NSCache 和 NSPurgeableData 缓存数据 只有费时操作才值得放入缓存，比如需要从网络获取的数据、从磁盘读取的数据1234567891011121314151617181920212223242526272829303132333435@interface KKSlideTabBarViewController ()&#123;NSCache *_cache;&#125;@end_cache = [NSCache new];_cache.countLimit = 100;_cache.totalCostLimit = 5 * 1024 * 1024;NSPurgeableData *cacheData = [_cacheobjectForKey:@&quot;url...&quot;];if (cacheData) &#123;// stop the data being purged[cacheData beginContentAccess];// 使用数据// ......// Mark that the data may be purged again[cacheData endContentAccess];&#125; else &#123;NSData *data = [NSData dataWithContentsOfURL:@&quot;xxx&quot;];NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];[_cache setObject:purgeableDataforKey:@&quot;url...&quot;cost:data.length];// With access already maked// user data// .....// Mark that the data may be purged now[purgeableData endContentAccess];&#125; 精简 + load 与 + initialize 方法它们都是在类载入系统时由运行时系统调用，不能手动调用。 + load 方法:在类加载时调用。系统会先调用父类的 load 再调用子类的 load，先调用类本身 load，再调用 categery load。在 load 方法中，运行时系统处于脆弱状态，不能确定其他类是否加载完毕。不能在 load 方法中使用其他类对象，因为无法知道这个类是否加载了。+ initialize 方法+ initialize 方法是惰性加载，使用到类时才会调用。+ initialize 方法调用时，系统处于正常状态，可以在 + initialize 方法中使用其他类对象。+ initialize 方法一定会在线程安全的环境中执行，那么执行 + initialize 方法时会阻塞其他线程如果子类没有实现 + initialize 方法，而父类实现了，那么会调用夫类的。所以应该这么实现：1234567+ (void)initialize&#123;if (self == [KKSlideTabBarView class]) &#123;// 只有当 KKSlideTabBarView 类载入系统时才执行这里的代码// 不然的话 KKSlideTabBarView 的父类载入系统也会调用 initialize&#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"GCD用法全解","slug":"GCD用法全解","date":"2016-08-02T09:16:17.000Z","updated":"2018-05-09T09:45:41.512Z","comments":true,"path":"2016/08/02/GCD用法全解/","link":"","permalink":"http://liumengxia.shop/2016/08/02/GCD用法全解/","excerpt":"","text":"[TOC] dispatch_time与dispatch_walltime的区别所有定时器dispatch source都是间隔定时器，一旦创建，会按你指定的间隔定期递送事件。当计算机睡眠时，定时器dispatch source会被挂起，稍后系统唤醒时，定时器dispatch source也会自动唤醒。定时器dispatch source会使用系统默认时钟来确定何时触发，但是默认时钟在计算机睡眠时不会继续。 如果你使用 dispatch_walltime 函数来设置定时器dispatch source，则定时器会根据挂钟时间来跟踪，这种定时器比较适合触发间隔相对比较大的场合，可以防止定时器触发间隔出现太大的误差。 区别： dispatch_time_t类型的时间我们可以通过dispatch_time来创建，也可以通过dispatch_walltime来创建。dispatch_time创建的时间多以第一个参数为参照物，之后过多久执行任务。dispatch_walltime多用于创建绝对时间，如某年某月某日某时某分执行某任务，比如闹钟的设置。 dispatch_time在计算机睡眠时会停止dispatch_walltime不会 例如以下情景 情景：希望一小时后执行任务，5分钟后计算机进入睡眠操作：50分钟后唤醒计算机实际：使用dispatch_walltime时: 5分钟后开始执行使用dispatch_time: 55分钟后开始执行 GCD 定时器的使用dispatch_source_set_timer 最后一个参数 leeway 详解 leeway 这个参数告诉系统我们需要计时器触发的精准程度。所有的计时器都不会保证100%精准，这个参数用来告诉系统你希望系统保证精准的努力程度。如果你希望一个计时器没五秒触发一次，并且越准越好，那么你传递0为参数。 如果是一个周期性任务，比如检查email，那么你会希望每十分钟检查一次，但是不用那么精准。所以你可以传入60，告诉系统60秒的误差是可接受的。 这样有什么意义呢？——降低资源消耗。如果系统可以让cpu休息足够长的时间，并在每次醒来的时候执行一个任务集合，而不是不断的醒来睡去以执行任务，那么系统会更高效。如果传入一个比较大的leeway给你的计时器，意味着你允许系统拖延你的计时器来将计时器任务与其他任务联合起来一起执行。 123456789101112 dispatch_queue_t mainQueue = dispatch_get_main_queue(); NSTimeInterval interval = 1.0f; NSTimeInterval delay = 1.0f; dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, mainQueue); dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, delay), interval * NSEC_PER_SEC, 1.0 * NSEC_PER_SEC); dispatch_source_set_event_handler(timer, ^&#123; NSLog(@&quot;%s&quot;, __func__); &#125;); dispatch_resume(timer); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; dispatch_source_cancel(timer);&#125;); 测试代码执行效率12345678910111213func testPerformance(closure: ()-&gt;()) &#123; let startTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) closure() let endTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) print(endTime - startTime)&#125; func testFunctionPerformance(selector: Selector) &#123; let startTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) self.performSelector(selector) let endTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) print(endTime - startTime)&#125; GCD 加锁GCD 信号量的使用 设置信号量的个数为1时，可以当锁来使用 设置信号量的个数与CPU个数相近时（比如CPU个数 * 2），可以用来限制线程个数。 123456789101112131415161718192021222324252627282930313233343536373839var semaphore: dispatch_semaphore_t = dispatch_semaphore_create(1)//MARK: ------------------- 使用信号量进行加锁操作 --------------------func test_semaphore() &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) &#123; () -&gt; Void in self.tast_first() &#125; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) &#123; () -&gt; Void in self.tast_second() &#125; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) &#123; () -&gt; Void in self.tast_third() &#125;&#125; func tast_first() &#123; // p操作，进入临界区 dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) print(&quot;First tast starting&quot;) sleep(1) NSLog(&quot;%@&quot;, &quot;First task is done&quot;) // v操作，离开临界区 dispatch_semaphore_signal(self.semaphore)&#125; func tast_second() &#123; dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) print(&quot;Second tast starting&quot;) sleep(1) NSLog(&quot;%@&quot;, &quot;Second task is done&quot;) dispatch_semaphore_signal(self.semaphore)&#125; func tast_third() &#123; dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) print(&quot;Third tast starting&quot;) sleep(1) NSLog(&quot;%@&quot;, &quot;Thrid task is done&quot;) dispatch_semaphore_signal(self.semaphore)&#125; 使用信号量控制多线程中代码执行顺序12345678910- (void)test_dispatch_semaphore_t_0 &#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [self method1]; sleep(10); dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self method2];&#125; 延时执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//MARK: ------------------- dispatch_after 的使用-------------------- func dispatchAfter() &#123; let delay: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, Int64(5 * Double(NSEC_PER_SEC))) dispatch_after(delay, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) &#123; () -&gt; Void in print(&quot;viewDidLoad()&quot;) &#125;&#125;# GCD 多任务异步执行与 `dispatch_notify` 的使用```Objective-C//MARK: ------------------- 多任务异步执行 与 dispatch_group_notify 的使用 -------------------- func dispatchGroup() &#123; let group: dispatch_group_t = dispatch_group_create() let globalQueueDefault: dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) // 串行队列按照先进先出的顺序执行（FIFO） let userQueueSerie: dispatch_queue_t = dispatch_queue_create(&quot;com.dispatchGroup.demo&quot;, DISPATCH_QUEUE_SERIAL) // 下载任务1 dispatch_group_async(group, userQueueSerie)&#123; sleep(3) NSLog(&quot;Task1 is done&quot;) &#125; // 下载任务2 dispatch_group_async(group, userQueueSerie)&#123; sleep(3) NSLog(&quot;Task2 is done&quot;) &#125; // 下载任务3 dispatch_group_async(group, globalQueueDefault)&#123; sleep(3) NSLog(&quot;Task3 is done&quot;) &#125; // 监听任务组事件的执行完毕 dispatch_group_notify(group, dispatch_get_main_queue())&#123; NSLog(&quot;Group tasks are done&quot;) &#125; // 设置等待时间(即设置超时)，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败 // 等待直到完成 let result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER) if (result != 0) &#123; print(&quot;Now viewDidLoad is done&quot;) &#125;&#125;# dispatch_group_apply```Objective-C//MARK: ------------------- 多任务异步执行/同步执行 与 dispatch_apply 的使用 -------------------- func dispatchApply() &#123; let iterations: Int = 20 // 迭代次数 let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) // 同步执行 self.testPerformance &#123; () -&gt; () in dispatch_apply(iterations, globalQueue) &#123; (index: Int) -&gt; Void in print(index, NSThread.currentThread()) &#125; NSLog(&quot;iterations is over&quot;) &#125; print(&quot;------------------------------------&quot;) // 异步执行 self.testPerformance &#123; () -&gt; () in dispatch_apply(iterations, globalQueue, &#123; (index: Int) -&gt; Void in dispatch_async(globalQueue, &#123; () -&gt; Void in print(index, NSThread.currentThread()) &#125;) &#125;) NSLog(&quot;iterations is over&quot;) &#125; print(&quot;------------------------------------&quot;) self.testPerformance &#123; () -&gt; () in for i:Int in 1...iterations &#123; print(i, NSThread.currentThread()) &#125; &#125;&#125; dispatch_group_enter / dispatch_group_leave1234567891011121314151617181920212223242526272829303132333435363738394041424344//MARK: ------------------- dispatch_group_enter / dispatch_group_leave -------------------// 将任务组中的任务未执行完毕的任务数目加减1，这种方式不使用 dispatch_group_async 来提交任务， // 注意：这两个函数要配合使用，有enter要有leave，这样才能保证功能完整实现。 // 串行执行三个任务 func dispatchGroup_EnterAndLeave_Seriel() &#123; let group = dispatch_group_create() for index:UInt32 in 1...3&#123; dispatch_group_enter(group)//提交了一个任务，任务数目加1 manualDownLoad(index)&#123; print(&quot;Task \\(index) is done&quot;) dispatch_group_leave(group)//完成一个任务，任务数目减1 &#125; &#125; &#125; func manualDownLoad(num: UInt32, block:()-&gt;())&#123; print(&quot;Downloading task &quot;, num) sleep(num) block() &#125; // 并行执行三个任务 func dispatchGroup_EnterAndLeave_Concurrent() &#123; let group = dispatch_group_create()//创建group let globalQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0) for index:UInt32 in 1...3 &#123; dispatch_group_enter(group)//提交了一个任务，任务数目加1 manualDownLoad(index, queue: globalQueueDefault)&#123; NSLog(&quot;Task\\(index) is done&quot;) dispatch_group_leave(group)//完成一个任务，任务数目减1 &#125; &#125; &#125; func manualDownLoad(num: UInt32, queue:dispatch_queue_t, block:()-&gt;())&#123; dispatch_async(queue)&#123; NSLog(&quot;Downloading task\\(num)&quot;) sleep(num) block() &#125; &#125; GCD 实战：资源竞争12345678910111213141516171819202122232425262728//MARK: ------------------- 多线程测试：资源竞争 -------------------- func test_mutiThread() &#123; let userSerialQueue = dispatch_queue_create(&quot;com.test.mutiThread.userSerialQueue&quot;, DISPATCH_QUEUE_SERIAL) let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) let group = dispatch_group_create() // 当 &quot;Processing data&quot;（CUP处理速度） 速度远小于 &quot;Reading file&quot;（磁盘处理速度） 速度时，线程数占用过多 // 使用信号量来限制同时执行的任务的数量 let cupCount = NSProcessInfo.processInfo().processorCount // CPU 数量 let jobSemaphore = dispatch_semaphore_create(cupCount * 2) // 限制线程个数 for i:Int in 1...50 &#123; dispatch_semaphore_wait(jobSemaphore, DISPATCH_TIME_FOREVER); dispatch_group_async(group, userSerialQueue, &#123; () -&gt; Void in print(&quot;Reading file&quot;, i, NSThread.currentThread()) // sleep(2) dispatch_group_async(group, globalQueue, &#123; () -&gt; Void in print(&quot; Processing data&quot;, i, NSThread.currentThread()) sleep(1) dispatch_group_async(group, userSerialQueue, &#123; () -&gt; Void in print(&quot; writing file&quot;, i, NSThread.currentThread()) // sleep(2) dispatch_semaphore_signal(jobSemaphore); &#125;) &#125;) &#125;) &#125; dispatch_group_wait(group, DISPATCH_TIME_FOREVER) &#125; 参考http://www.jianshu.com/p/6670cdbb1ebbhttp://www.dreamingwish.com/article/gcd-practice-io-race.html","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"CocoaPods 管理私有库","slug":"CocoaPods-管理私有库","date":"2016-06-09T10:02:18.000Z","updated":"2018-05-09T10:02:51.884Z","comments":true,"path":"2016/06/09/CocoaPods-管理私有库/","link":"","permalink":"http://liumengxia.shop/2016/06/09/CocoaPods-管理私有库/","excerpt":"","text":"[toc] 一、创建私有 Cocoapod Spec Repo 仓库Spec Repo 是所有 pod 的索引，自己创建的私有 pod 库都将放在这里 创建一个空的私有 Cocoapod Spec Repo 的远程 git 仓库 执行命令pod repo add KSSpecPods https://coding.net/u/action456789/p/KSSpecPods.git 查看是否创建成功进入到~/.cocoapods/repos目录下，如果看到 KSSpecPods ，说明创建成功 二、创建需要放入 Cocoapod Spec Repo 仓库进行管理的私有库创建全新的私有库时 创建私有库的远程 git 仓库 创建本地私有库pod lib create podTestLibrary 关联本地私有库与远程仓库，并打上版本号，然后推送到远程 git 仓库git tag -m &quot;first release&quot; 0.1.0git push --tags #推送tag到远端仓库 编辑podspec文件例如： 1234567891011121314151617181920212223242526272829303132333435363738Pod::Spec.new do |s|s.name = &apos;TAFNetwork&apos;s.version = &apos;0.1.0&apos;s.summary = &apos;Just Testing.&apos;s.description = &lt;&lt;-DESCTesting Private Podspec.* Markdown format.* Don&apos;t worry about the indent, we strip it!DESCs.homepage = &apos;https://github.com/action456789/CocoapodsPrivateLibTest&apos; #主页,这里要填写可以访问到的地址，不然验证不通过# s.screenshots = &apos;www.example.com/screenshots_1&apos;, &apos;www.example.com/screenshots_2&apos; #截图s.license = &apos;MIT&apos; #开源协议s.author = &#123; &apos;kesen&apos; =&gt; &apos;317331820@qq.com&apos; &#125;s.source = &#123; :git =&gt; &apos;https://github.com/action456789/CocoapodsPrivateLibTest.git&apos;, :tag =&gt; s.version&#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS# s.social_media_url = &apos;https://twitter.com/&lt;TWITTER_USERNAME&gt;&apos; #多媒体介绍地址s.platform = :ios, &apos;7.0&apos; #支持的平台及版本s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARCs.source_files = &apos;TAFNetwork/Classes/**/*&apos; #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，# s.resource_bundles = &#123; #资源文件地址# &apos;TAFNetwork&apos; =&gt; [&apos;TAFNetwork/Assets/*.png&apos;]# &#125;s.public_header_files = &apos;TAFNetwork/Classes/**/*.h&apos; #NAME_OF_POD/Classes/**/*&apos;，公开头文件地址s.frameworks = &apos;UIKit&apos; #所需的framework，多个用逗号隔开# s.dependency &apos;CocoaAsyncSocket&apos;, &apos;~&gt; 7.5.0&apos;# s.dependency &apos;FMDB&apos;, &apos;~&gt; 2.5&apos;# s.dependency &apos;Reachability&apos;, &apos;~&gt; 3.2&apos;# s.dependency &apos;SAMKeychain&apos;, &apos;~&gt; 1.5.2&apos;end 验证podspec执行pod lib lint 私有库项目已经存在时 创建 podspec 文件pod spec create PodTestLibrary git@coding.net:wtlucky/podTestLibrary.git 验证podspec执行pod lib lint 三、本地测试podspec文件1）新建一个项目，在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。 在Podfile中我们可以这样编辑，有两种方式12pod &apos;podTestLibrary&apos;, :podspec =&gt; &apos;/Users/kesen/Desktop/Repository/KSSpecPods/podTestLibrary/podTestLibrary.podspec&apos; # 指定podspec文件# pod &apos;podTestLibrary&apos;, :path =&gt; &apos;/Users/kesen/Desktop/Repository/KSSpecPods&apos; # 指定路径 2）安装依赖pod install 四、提交私有库到私有 Cocoapod Spec Repo 仓库 进入私有库目录，执行pod repo push KSSpecPods podTestLibrary.podspec 进入/Users/kesen/.cocoapods/KSSpecPods查看是否提交成功 五、私有制作好的私有库1）在 podfile 文件中加入代码1pod &apos;PodTestLibrary&apos;, &apos;~&gt; 0.1.0&apos; 2）执行 pod update然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了 六、更新私有库参考http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"如何更新React Native","slug":"如何更新React-Native","date":"2016-04-12T07:32:04.000Z","updated":"2018-05-09T08:11:38.978Z","comments":true,"path":"2016/04/12/如何更新React-Native/","link":"","permalink":"http://liumengxia.shop/2016/04/12/如何更新React-Native/","excerpt":"","text":"最新的React Native已经更新到了0.33.0，如何更新自己已经搭建好的React Native开发环境呢，我按照以下步骤完成了更新，现记录下来，供有需要的人参考。 1.查看 react native 的最新版本。进入项目根目录，命令行执行npm info react-native 查看当前版本react-native --version 2.在项目目录下修改package.json文件，将下列代码中的 react-native 改为最新版本1234 &quot;dependencies&quot;: &#123; &quot;react&quot;: &quot;^0.14.8&quot;, &quot;react-native&quot;: &quot;^0.33.0&quot; &#125; ## 3. 命令行执行 `npm install --save react-native@0.33.0` 如果升级后出现类似于 `react-native@0.33.0 requires a peer of react@~15.3.1 but none was installed.` 执行 `npm install --save react@~15.3.1` ## 4. 运行程序 如果更新后执行react-native run-android不能正确运行，而是出现类似： Could not find com.facebook.react:react-native:0.23.0. 错误，或者在Android Studio中直接运行app时报错： Android Studio failed to resolve com.facebook.react:react-native:0.23.0 那么可以按照下列命令修复，首先在命令行中执行： `npm i` 执行完毕且不报错后，执行下面的命令，**注意，在执行命令之后，某些文件可能会产生冲突，请确保你的本地文件记录可以恢复**（在Android Studio中可以查看历史记录来恢复文件） `react-native upgrade` 执行上面的命令可能会提示你是否覆盖文件。在解决冲突之后重新运行App即可。 ## 如果还有问题，可以更新一下npm和Node.js再试 - 如何更新npm `npm install -g npm` - 如何更新Node.js `npm update node.js`","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"消除编译器警告","slug":"消除编译器警告","date":"2016-01-09T09:54:41.000Z","updated":"2018-05-09T09:56:09.349Z","comments":true,"path":"2016/01/09/消除编译器警告/","link":"","permalink":"http://liumengxia.shop/2016/01/09/消除编译器警告/","excerpt":"","text":"[TOC] 关闭 deprecated-declarations 警告.基本流程: push 当前警告入栈 忽略我们要消除的警告 执行会产生警告的代码 pop 警告出栈——恢复之前的状态123456#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;/*要屏蔽掉deprecated警告的代码*/#pragma clang diagnostic pop 关闭 XCode8 Convenience initializer missing a self call to.... 警告123456#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-designated-initializers&quot;/*要屏蔽掉deprecated警告的代码*/#pragma clang diagnostic pop undeclared selector警告1234567#pragma clang diagnostic push#pragma clang diagnostic ignored&quot;-Wundeclared-selector&quot;//......#pragma clang diagnostic pop Category is implementing a method which will also be implemented by its primary class当category重写类已有的方法时会出现此警告。 12345678910#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-protocol-method-implementation”//.....#pragma clang diagnostic pop","categories":[],"tags":[]},{"title":"iOS编译ffmpeg","slug":"iOS编译ffmpeg","date":"2015-11-06T02:59:45.000Z","updated":"2018-05-09T10:00:27.621Z","comments":true,"path":"2015/11/06/iOS编译ffmpeg/","link":"","permalink":"http://liumengxia.shop/2015/11/06/iOS编译ffmpeg/","excerpt":"","text":"[TOC] iOS编译ffmpeg参考http://www.jianshu.com/p/08107176d5bb 1） 下载”一键编译”脚本https://github.com/kewlbear/FFmpeg-iOS-build-script 2）编译能在iOS下使用的FFMPEG library库进入脚本目录，执行./build-ffmpeg.sh 3）在xcode中引入FFMPEG library库新建工程，把上面编译好的FFmpeg-iOS拖到xcode工程中 编译后的文件夹中ffmpeg-2.5.3 是源码FFmpeg-iOS 是编译出来的库，里面有我们需要的.a静态库，一共有7个 执行lipo -info libavcodec.a，查看.a包支持的架构，这几个包都支持了armv7 armv7s i386 x86_64 arm64这几个架构，这个脚本果真是业界良心啊～～～ 4）加入依赖库libz.tbd libbz2.tbd libiconv.tbd等 5）为TARGETS 添加 search paths项目根目录用 $(SRCROOT) 表示 添加 Header Search Paths$(inherited)$(SRCROOT)/FfmpegDemo/FFmpeg-iOS/lib 添加 Library Search Paths （系统可能已经添加）$(inherited)`$(SRCROOT)/FfmpegDemo/FFmpeg-iOS/include 如果编译不过（如缺少文件）一般都是search paths路径没写对 5）修改某个.m文件为.mm注意，不能是引入FFmpeg库的文件，否则编译不过 6）引入头文件1#include &quot;avformat.h&quot; 如果编译成功，说明 search patchs 设置成功 7）添加代码123456#include &quot;avutil.h&quot;av_register_all();// 获取 ffmpeg 版本号const char *version = av_version_info();NSLog(@&quot;version: %s&quot;, version); 执行成功说明集成成功 各个CPU构架支持的设备","categories":[],"tags":[]},{"title":"Hexo GitHub博客搭建","slug":"Hexo-GitHub博客搭建","date":"2015-09-09T04:01:05.000Z","updated":"2018-05-09T08:36:18.168Z","comments":true,"path":"2015/09/09/Hexo-GitHub博客搭建/","link":"","permalink":"http://liumengxia.shop/2015/09/09/Hexo-GitHub博客搭建/","excerpt":"","text":"[TOC] 相关网站https://hexo.io/zh-cn/docs/ 准备工作 1、安装Node.jshttps://blog.csdn.net/u011619283/article/details/52368759 2、安装hexonpm install -g hexo-cli 本地站点搭建 1、初始化 Hexo进入自己创建的目录下 1hexo init 2、生成静态页面 1hexo generate 3、启动服务 1hexo server 4、查看效果打开浏览器，输入 http://localhost:4000/ 部署到github 1、创建仓库仓库名称固定格式如下：yourGitbubUsername.github.io注意yourGitbubUsername必须与你的github用户名相同，否则无法部署 2、安装github部署器 1npm install hexo-deployer-git –save 3、修改本地配置文件_config.yml 1234deploy:type: gitrepo: https://github.com/action456789/action456789.github.io.gitbranch: master 4、部署 12hexo generatehexo deploy 5、测试部署成功以后，在浏览器中输入 http://action456789.github.io 即可在线浏览自己的博客啦 绑定域名https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html（亲测可行） 修改主题 直接去查找最流行的主题，github上有安装说明，这个是最靠谱的安装方法。 安装完成之后：输入hexo s --debug进行测试 1234hexo clean hexo generate hexo server (若是想本地预览和执行该命令预览) hexo deploy NexT主题官方文档http://theme-next.iissnan.com/getting-started.html 添加tag1hexo new page &quot;tags&quot; 博客的创建、修改与删除 1、创建新博客 1hexo new &quot;test_blog&quot; 删除博客删除博客文件后重新发布更新即可可能需要等几分钟才有效果 2、发布更新 123hexo cleanhexo generatehexo deploy 3、一些快捷键 1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"iOS中的时间","slug":"iOS中的时间","date":"2015-08-12T14:10:18.000Z","updated":"2018-05-09T08:12:16.341Z","comments":true,"path":"2015/08/12/iOS中的时间/","link":"","permalink":"http://liumengxia.shop/2015/08/12/iOS中的时间/","excerpt":"","text":"[TOC] 设备开机后的时间 CACurrentMediaTime() 设备从开机时起到现在的时间，设备重启会重置，单位为秒 [[NSProcessInfo processInfo] systemUptime] 与CACurrentMediaTime()等价 相对某个参考系的时间 Date().timeIntervalSince1970 1970年1月1日凌晨为参考系，到现在的时间，一般用于表示时间戳 Date().timeIntervalSinceReferenceDate 世界时间（UTC）2001年1月1日凌晨到现在经过的时间，单位为秒 CFAbsoluteTimeGetCurrent() 与Date().timeIntervalSinceReferenceDate等价 当用户手动改变了设备上的系统时间后，基于系统时钟的上述方法返回的结果也会一同改变 12345678print(CACurrentMediaTime()) // 设备刚重启print(Date().timeIntervalSince1970)print(Date().timeIntervalSinceReferenceDate)print(CFAbsoluteTimeGetCurrent()) 必要时，从服务器上获取时间如果App本身对获取的时间精度要求很高，还是直接通过网络从服务器获取时间戳会比较保险。 当网络可用时，直接从服务器获取； 网络不可用时，且设备没有被重启过，可以根据上一次获取服务器时间戳的时刻到此时的时间差来推算出正确的时间","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"cocoapods 安装与使用","slug":"cocoapods-安装与使用","date":"2014-09-03T01:10:54.000Z","updated":"2018-05-09T10:26:28.513Z","comments":true,"path":"2014/09/03/cocoapods-安装与使用/","link":"","permalink":"http://liumengxia.shop/2014/09/03/cocoapods-安装与使用/","excerpt":"","text":"常见命令更新本地索引库需要经常手动进行更新，尤其在苹果有大的版本发布之后，各个第三方库会在随后更新pod repo update 更新cocoapod版本gem install cocoapods --pre 单独更新某个库pod update MJRefresh 安装 1.安装 rvm参考：http://ruby-china.org/wiki/rvm-guide，测试可行 2.安装ruby同样参考上面的网站 3.开始安装cocoapods升级ruby的gemsudo gem update --system安装cocoapodssudo gem install cocoapods还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。 请参见cocoapods官网 https://cocoapods.org 4.更新ruby的源 最新的国内安装源可以在这里看到 https://gems.ruby-china.org 123gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l 参考唐巧博客：http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/ 二、重装 更新了 Xcode 7 和 OSX 0.11.1 后，install pod 不好使了。试了下重新安装 cocoapods。遇到了一些问题 1. 执行 sudo gem install cocoapods 出现了如下错误： ERROR: Could not find a valid gem ‘cocospods’ (&gt;= 0), here is why:Unable to download data from http://ruby.taobao.org/ - bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz) 解决办法：将http 替换成 https，具体如下 gem sources –remove http://ruby.taobao.org/ gem sources -a https://ruby.taobao.org/ 查看源对不对gem sources -l 再安装就好了sudo gem install cocoapods 2. 然后可以执行 sudo gem install cocoapods 了。但是执行到一半又出现了如下错误 While executing gem … (Errno::EPERM)Operation not permitted - /usr/bin/xcodeproj 解决办法：自定义GEM_HOME命令行操作：12345678$ mkdir -p $HOME/Software/ruby$ export GEM_HOME=$HOME/Software/ruby$ gem install cocoapods [...] 1 gem installed $ export PATH=$PATH:$HOME/Sofware/ruby/bin $ pod --version 0.39.0 然后就顺利安装成功了 ## 三、使用 cocoapods 更换clone github镜像，加快 pod 代码下载速度~~~123456789 ``` $ cd ~/.cocoapods/repos $ pod repo remove master $ git clone https://git.coding.net/hging/Specs.git master ``` ~~~然后需要在 podfile文件中加入如下代码 12 // 如果不加这一句话，它默认还是从github镜像源地址去下载的 source &apos;https://git.coding.net/hging/Specs.git&apos; 目前没有发现比较好的镜像，上面的镜像pod里库的版本已经很低，不建议使用了，所以暂时无法解决慢的问题。 —- ### 常用命令 pod search pop pod init pod install pod install --verbose --no-repo-update pod update pod update --verbose --no-repo-update ### 注意点 * 如果 import 的时候没有提示 POP.h 的文件，可以在 target-Build Settings 下修改 User Header Search Paths 项，新增 ${SRCROOT} 并选择 rcursive，如下图。 ## 四、参考： 安装Cocoapods， 更新gem出现的问题 Mac OS X 跟新到10.11后cocoapods安装出现的问题（- bad response Not Found 404 (http://ruby.taobao.org/latest_spe 使用CocoaPods管理依赖库 解决CocoaPods慢的小技巧","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://liumengxia.shop/tags/iOS/"}]},{"title":"《C语言深度剖析》读书笔记","slug":"《C语言深度剖析》读书笔记","date":"2013-07-15T06:19:07.000Z","updated":"2018-05-09T10:20:02.782Z","comments":true,"path":"2013/07/15/《C语言深度剖析》读书笔记/","link":"","permalink":"http://liumengxia.shop/2013/07/15/《C语言深度剖析》读书笔记/","excerpt":"","text":"registerregister 变量必须是一个单个的值,并且其长度应小 于或等于整型的长度。 而且 register 变量可能不存放在内存中,所以不能用取址运算符“&amp;” 来获取 register 变量的地址。 float 变量与“零值”进行比较12//EPSINON 为定义好的 精度。if((fTestVal &gt;= -EPSINON) &amp;&amp; (fTestVal &lt;= EPSINON)); volatilevolatile 关键字告诉编译器 i 是随时可能发生变化的,每次使用它的时候必须从内存中取出 i 的值,因而编译器生成的汇编代码会重新从 i 的地址处读取数据放在 k 中。 这样看来,如果 i 是一个寄存器变量或者表示一个端口数据或者是多个线程的共享数 据,就容易出错,所以说 volatile 可以保证对特殊地址的稳定访问。 externextern 可以置于变量或者函数前,以 标示变量或者函数的定义在别的文件中,下面的代码用到的这些变量或函数是外来的,不 是本文件定义的,提示编译器遇到此变量和函数时在其他模块中寻找其定义 空结构体占用空间大小123struct student &#123;&#125;stu; sizeof(stu)的值是多少呢?Visual C++ 6.0上为 1编译器认为你构造一个结构体数据类型是用来打包一些数据成员的,而最小的数据成员需要 1 个 byte,编译器为每个结构体类型数据至少预留 1 个 byte 的空间。所以,空结构体的大小就定位 1 个 byte。 struct 与 class 的区别struct 的成 员默认情况下属性是 public 的,而 class 成员却是 private 的。 union 关键字union 维护足够的空间来置放多个数据成员中的“一种”,而不是为每一个数据成员配置 空间,在 union 中所有的数据成员共用一个空间,同一时间只能储存其中一个数据成员,所 有的数据成员具有相同的起始地址。123456union StateMachine &#123;char character;int number;char *str;double exp;&#125;; 一个 union 只配置一个足够大的空间以来容纳最大长度的数据成员,以上例而言,最大 长度是 double 型态,所以 StateMachine 的空间大小就是 double 数据类型的大小。另外，注意大小端模式对 union 类型数据存储的空间有影响 typedef 关键字123456789101112131415typedef struct student &#123;//code&#125;Stu_st,*Stu_pst;A),struct student stu1;和 Stu_st stu1;没有区别。B),struct student *stu2;和 Stu_pst stu2;和 Stu_st *stu2;没有区别。 这个地方很多初学者迷惑,B)的两个定义为什么相等呢?其实很好constconst int *p; //p指向的对象不可变（*p不可变）int const *p; //p指向的对象不可变（*p不可变）int *const p; //p不可变，p指向的对象可变const int *const p; //前一个 const 修饰*p,后一个 const 修饰 p,指针 p 和 p 指向的对象 都不可变void Fun(const int i); //不希望这个参数值被函数体内意外改变。const int Fun (void); //返回值不可被改变。 运算符1SQR(8) 输出的是:The square of 8 is 64. #预算符 ##运算符可以用于宏函数的替换部分。这个运算符把两个语言符号组 合成单个语言符号。1#define XNAME(n) x ## n 如果这样使用宏:1XNAME(8) 则会被展开成这样:x8 指针和数组A)1int* p1[10]; // 指针数组，数组的每个值都是指针 “[]”的优先级比“”要高。p1 先与“[]”结合,构成一个数组的定义,数组名为 p1,int 修饰的是数组的内容,即数组的每个元素。那现在我们清楚,这是一个数组,其包含 10 个 指向 int 类型数据的指针,即指针数组。B)1int (*p2)[10]; //数组指针，可以理解为 int (*)[10] p2，实际上就是二维数组p[][10]; “()”的优先级比 “[]”高,“*”号和 p2 构成一个指针的定义，指针变量名为 p2,int 修饰的是数组的内容, 即数组的每个元素。数组在这里并没有名字,是个匿名数组。那现在我们清楚 p2 是一个指 针,它指向一个包含 10 个 int 类型数据的数组,即数组指针。 函数指针A)1char * fun3(char * p1,char * p2); //fun3是函数名,p1,p2是参数,其类型为char*型,函数的返回值为char * 类型。 B)1char * *fun2(char * p1,char * p2); //与 C)表达式相比,唯一不同的就是函数的返回值类型为 char** C)1char * (*fun1)(char * p1,char * p2); //fun1 不是什么函数名,而是一个 指针变量,它指向一个函数。这个函数有两个指针类型的参数,函数的返回值也是一个指 针。我们把这个表达式改写一下:char * (*)(char * p1,char * p2) fun1; 这样子是不 是好看一些呢?只可惜编译器不这么想。 函数指针数组12char * (*pf)(char * p) //函数指针char * (*pf[3])(char * p); //这是定义一个函数指针数组。它是一个数组,数组名为 pf,数组内存储了 3 个指向函数的 指针。pf是数组名 函数指针数组的指针1char * (*(*pf)[3])(char * p); //pf是指针，这个指针指向一个包含了 3 个元素的数组;这个数字里 面存的是指向函数的指针;这些指针指向一些返回值类型为指向字符的指针、参数为一个 指向字符的指针的函数。 实战练习 参考答案：a) int a;b) int a;c) int **a;d) int a[10];e) int a[10];f) int (a)[10];g) int (func)(int a);h) int (*func[10])(int a);","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://liumengxia.shop/tags/C-C/"}]}]}
{"meta":{"title":"爱工作·爱生活","subtitle":"action456789","description":null,"author":"action456789","url":"http://superkk.top"},"pages":[{"title":"C/C++","date":"2018-05-09T08:06:37.000Z","updated":"2018-05-09T08:06:37.000Z","comments":true,"path":"C-C/index.html","permalink":"http://superkk.top/C-C/index.html","excerpt":"","text":""},{"title":"iOS","date":"2018-05-09T08:06:24.000Z","updated":"2018-05-09T08:06:24.000Z","comments":true,"path":"iOS/index.html","permalink":"http://superkk.top/iOS/index.html","excerpt":"","text":""},{"title":"生活","date":"2018-05-09T08:06:54.000Z","updated":"2018-05-09T08:06:54.000Z","comments":true,"path":"生活/index.html","permalink":"http://superkk.top/生活/index.html","excerpt":"","text":""},{"title":"随笔","date":"2018-05-09T08:07:12.000Z","updated":"2018-05-09T08:07:12.000Z","comments":true,"path":"随笔/index.html","permalink":"http://superkk.top/随笔/index.html","excerpt":"","text":""}],"posts":[{"title":"组件化模块间通信方案","slug":"组件化模块间通信方案","date":"2018-08-21T17:12:20.000Z","updated":"2019-08-29T09:07:04.749Z","comments":true,"path":"2018/08/22/组件化模块间通信方案/","link":"","permalink":"http://superkk.top/2018/08/22/组件化模块间通信方案/","excerpt":"","text":"组件化模块间通信方案1、公共模块下沉比如一些公共的基础UI组件应该互相独立，并且可以下沉为一个单独的层（比如通用业务层），供其他业务模块调用。 2、OpenURL统跳协议用一个url表示一个页面（Controller），或者UI控件，或者任意一个类的对象。 需要创建一个字典，key是url，value是相应的对象，这个字典由路由类去管理，典型的方案就是MGJRouter。 优点：能解决组件间的依赖，并且方案成熟，有很多知名公司都在用这种方案（蘑菇街）； 缺点：编译阶段无法发现潜在bug，并且需要去注册&amp;维护路由表。 // 注册路由 [[Router sharedInstance] registerURL:@&quot;myapp://good/detail&quot; with:^UIViewController *{ return [GoodDetailViewController new]; }]; // 通过url获取 UIViewController *vc = [[Router sharedInstance] openURL:@&quot;myapp://good/detail&quot;] 参考 3、Target-Action(反射)例如从A中push到BViewController，需要在AViewController类文件中import进BViewController，这样二者就会产生耦合现在利用Target-Action机制，我们不再直接import进BViewController，而是利用NSClassFromString(&lt;#NSString * _Nonnull aClassName#&gt;)这个api将BViewController这个字符串反射成BViewController这个类，这样我们就可以根据反射后的类进行实例化，再调用实例化对象的各种方法。 优点：相比于URL Router，Target-Action也不需要注册和内存占用。 缺点：编译阶段无法发现潜在的BUG，而且，开发者所创建的类和定义的方法必须要遵守Target-Action的命名规则，调用者可能会因为硬编码问题导致调用失败。 第三方框架有CTMediator和BeeHive在github 4、NSNotificationCenter 优点：简单直接。 缺点：遍地都是通知，如果同事间协调不好会使得代码很混乱。 5、依赖注入：推荐方法比如业务C将自己注入中间层，业务A去中间层去获取依赖的方法和变量。 实现方式：通过中间层协议实现业务B遵从这个协议，实现协议的代理方法，返回与中间层商量好的一个实际对象。业务A通过中间层的某个方法（与B商量），获取遵从了这个协议的实例B，将其当做一个遵从了这个协议的透明对象来使用。 编程实现：具体运用了java的面向接口编程`Protocol - Class，即iOS的面向协议编程` 优点：1、接口类似代码，可以非常灵活的定义函数和回调等。 缺点：1、接口定义文件需要放在一个模块以供依赖，但是这个模块不会贡献代码，所以还好。2、使用较为麻烦，每各调用都需要定义一个service，并实现, 对于一些具有普适性规律的场景不太合适，比如页面统一跳转 面向接口的调用会产生依赖`Objective-C// A 模块 (void)getSomeDataFromB { B.getSomeData();} // B 模块 (void)getSomeData { return self.data;}` 示例ServiceBProtocolprotocol ServiceBProtocol { func getSomeDataFromServiceB() -&gt; String; } MiddleLayer class MiddleLayer: NSObject { class func findServiceB() -&gt; ServiceBProtocol { return ServiceB() } } ServiceB // 模块B class ServiceB: NSObject { let serviceB_Data = &quot;ServiceB&quot; } extension ServiceB: ServiceBProtocol { func getSomeDataFromServiceB() -&gt; String { return self.serviceB_Data } } ServiceA // 模块A class ServiceA: NSObject { func getDataFromB() { print(MiddleLayer.findServiceB().getSomeDataFromServiceB()) } }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"高级","slug":"iOS/高级","permalink":"http://superkk.top/categories/iOS/高级/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"ReactiveCocoa冷热信号详解","slug":"ReactiveCocoa冷热信号详解","date":"2018-07-30T12:08:40.000Z","updated":"2019-08-29T09:07:04.741Z","comments":true,"path":"2018/07/30/ReactiveCocoa冷热信号详解/","link":"","permalink":"http://superkk.top/2018/07/30/ReactiveCocoa冷热信号详解/","excerpt":"","text":"[TOC] 简介函数响应式编程(Functional Reactive Programming:FRP)，ReactiveCocoa 版本 2.5 冷热信号 冷信号只有当你订阅的时候，它才会发布消息，一对一，当有不同的订阅者，消息是重新完整发送。 热信号尽管你并没有订阅事件，但是它会时刻推送，类似“直播”，错过了就不再处理。可以有多个订阅者，是一对多 RACSignal 与RACSubject 的区别 RACSignal是冷信号 RACSubject是热信号 如下图 signal subject replaySubject Subject可以附加行为，例如RACReplaySubject具备为未来订阅者缓冲事件的能力。（这一点与冷信号类似，即使是在数据发送之后才订阅的，依然会收到全部消息） 冷信号示例：延时订阅，依然能收到所有信号数据- (void)test1 { RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@1]; [subscriber sendNext:@2]; [subscriber sendNext:@3]; [subscriber sendCompleted]; return nil; }]; NSLog(@&quot;Signal was created.&quot;); [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{ [signal subscribeNext:^(id x) { NSLog(@&quot;Subscriber1 recveive: %@&quot;, x); }]; }]; [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [signal subscribeNext:^(id x) { NSLog(@&quot;Subscriber2 recveive: %@&quot;, x); }]; }]; } 热信号示例：错过了订阅时机，就收不到信号数据，类似于直播 冷信号会收到全部的数据，即使是在数据发送之后才订阅的 - (void)test2 { RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{ [subscriber sendNext:@1]; }]; [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{ [subscriber sendNext:@2]; }]; [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{ [subscriber sendNext:@3]; [subscriber sendCompleted]; }]; return nil; }] publish]; [connection connect]; NSLog(@&quot;Signal was created.&quot;); [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{ [connection.signal subscribeNext:^(id x) { NSLog(@&quot;Subscriber1 recveive: %@&quot;, x); }]; }]; [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{ [connection.signal subscribeNext:^(id x) { NSLog(@&quot;Subscriber2 recveive: %@&quot;, x); }]; }]; } SideEffect示例：多次订阅导致信号block多次执行- (void)test3 { // 多次订阅会多次执行 RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSLog(@&quot;开始请求网络数据&quot;); [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{ [subscriber sendNext:@&quot;1&quot;]; }]; return nil; }]; // 【请求数据次数 +1】 [requestSignal subscribeNext:^(id x) { NSLog(@&quot;订阅者1&quot;); }]; // 【请求数据次数 +1】 [requestSignal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者2&quot;); }]; // 将信号转换为内容为2的信号 RACSignal *signal1 = [requestSignal flattenMap:^RACStream *(id value) { return [RACSignal return:@&quot;2&quot;]; }]; // 将signal1信号所有错误信息转换为字符串@&quot;Error&quot; [signal1 catchTo:[RACSignal return:@&quot;Error&quot;]]; // 在没有获取值之前以字符串@&quot;Loading...&quot;占位 [signal1 startWith:@&quot;Loading...&quot;]; // 将信号进行绑定 // 【请求数据次数 +1】 RAC(self.acountField, text) = signal1; // 订阅多个信号的任何错误，并且弹出UIAlertView // 【请求数据次数 +2】 [[RACSignal merge:@[requestSignal, signal1]] subscribeError:^(NSError *error) { NSLog(@&quot;发生错误&quot;); }]; } 解决方式一：使用 RACMulticastConnection把冷信号转化为热信号- (void)test4 { RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSLog(@&quot;开始请求网络数据&quot;); [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{ [subscriber sendNext:@&quot;1&quot;]; [subscriber sendCompleted]; }]; return nil; }]; RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]]; // RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]]; [connection connect]; [connection.signal subscribeNext:^(id x) { NSLog(@&quot;订阅者1:%@&quot;, x); }]; [connection.signal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者2:%@&quot;, x); }]; [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{ [connection.signal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者3:%@&quot;, x); }]; }]; } 使用RACSubject时RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]]; 使用RACReplaySubject时RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]]; 解决方式二：使用 replayLazily把冷信号转化为热信号- (void)test5 { RACSignal *requestSignal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSLog(@&quot;开始请求网络数据&quot;); [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{ [subscriber sendNext:@&quot;1&quot;]; [subscriber sendCompleted]; }]; return nil; }] replayLazily]; // modify here!! [requestSignal subscribeNext:^(id x) { NSLog(@&quot;订阅者1:%@&quot;, x); }]; [requestSignal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者2:%@&quot;, x); }]; [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{ [requestSignal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者3:%@&quot;, x); }]; }]; } 使用RACCommand把冷信号转化为热信号 - (void)test6 { RACCommand *requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSLog(@&quot;开始请求网络数据&quot;); [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{ [subscriber sendNext:@&quot;1&quot;]; [subscriber sendCompleted]; }]; return nil; }]; }]; RACSignal *requestSignal = [requestCommand execute:nil]; [requestSignal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者1:%@&quot;, x); }]; [requestSignal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者2:%@&quot;, x); }]; [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{ [requestSignal subscribeNext:^(NSArray *x) { NSLog(@&quot;订阅者3:%@&quot;, x); }]; }]; } 总结RACMulticastConnection与RACSubject结合使用时是直播的热信号 RACCommand、replayLazily、RACReplaySubject都是类似于冷信号的情况，不管何时订阅，都会收到所有数据 ReactiveCocoa中潜在的内存泄漏与解决方案 RACObserve中潜在使用了self，要注意循环引用 RACSubject中如果没有调用sendCompleted，调用map等操作将造成内存泄漏（循环引用）。RACSignal不会有这个问题 代码参见https://github.com/action456789/ReactiveCocoaDemo 参考：http://tech.meituan.com/tag/ReactiveCocoa","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"Rx & RAC","slug":"iOS/Rx-RAC","permalink":"http://superkk.top/categories/iOS/Rx-RAC/"}],"tags":[]},{"title":"UITableView的beginUpdates与endUpdates用法详解","slug":"UITableView的`beginUpdates`与`endUpdates`用法详解","date":"2018-06-04T18:05:12.000Z","updated":"2019-08-29T14:57:40.604Z","comments":true,"path":"2018/06/05/UITableView的`beginUpdates`与`endUpdates`用法详解/","link":"","permalink":"http://superkk.top/2018/06/05/UITableView的`beginUpdates`与`endUpdates`用法详解/","excerpt":"","text":"[TOC] UITaUITableView的beginUpdates和endUpdates 这个方法用于在调用插入，删除，选择方法时，同时有动画效果。 用endUpdate能动画改变行高(触发heightForRowAtIndexPath回调)，而无需relaod这个cell。 使用场景一：点击cell，cell的高度就变高Cell点击方法执行 [tableView beginUpdates]; [tableView endUpdates]; 这两句代码中间没有任何其他部分，但是会触发heightForRowAtIndexPath回调，从而修改cell的高度 使用场景二：有一个 TableView，现在我希望每按一次 update 按钮，就动态地在下方加两行。 方法一：简单粗暴的做法 ，更改数据源，然后刷新一下列表 // tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;] @IBAction func update(_ sender: AnyObject) { tableData.append(&quot;\\(tableData.count)&quot;) tableData.append(&quot;\\(tableData.count)&quot;) tableView.reloadData() } 方法二 // tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;] @IBAction func update(_ sender: AnyObject) { tableData.append(&quot;\\(tableData.count)&quot;) tableData.append(&quot;\\(tableData.count)&quot;) tableView.beginUpdates() let indexPaths = [IndexPath(row: tableData.count-2, section: 0), IndexPath(row: tableData.count-1, section: 0)] tableView.insertRows(at: indexPaths, with: UITableViewRowAnimation.automatic) tableView.endUpdates() } 这里 beginUpdates 和 endUpdates 方法的作用是，将这两条语句之间的对 tableView 的 insert/delete 操作聚合起来，然后同时更新 UI。 动态改变tableHeaderView高度view 作为 tableView 的 tableHeaderView，单纯的改变 view 的 frame 是无济于事的，tableView 不会时刻适应它的高度， 所以，如何告诉tableView 它的 tableHeaderView 已经改变了？ headerView.frame = newFrame; [self.tableView setTableHeaderView:headerView]; 或者 [self.tableView beginUpdates]; [self.tableView setTableHeaderView:headerView]; [self.tableView endUpdates]; 如何检测动画在UITableView beginUpdates / endUpdates上结束 [CATransaction begin]; [CATransaction setCompletionBlock:^{ // animation has finished }]; [tableView beginUpdates]; // do some work [tableView endUpdates]; [CATransaction commit];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[]},{"title":"RxSwift基本概念","slug":"RxSwift基本概念","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T16:10:11.474Z","comments":true,"path":"2018/05/21/RxSwift基本概念/","link":"","permalink":"http://superkk.top/2018/05/21/RxSwift基本概念/","excerpt":"","text":"[TOC] ObservableObservables是一个事件流的对象 empty通过empty函数，可以生成一个空的流，在这个流中只会产生一个Completed信息。 let emptyStream: Observable&lt;Int&gt; = Observable.empty() _ = emptyStream.subscribe { event in print(event) completed } never通过never函数产生的流对象，将不会有任何的事件发生。 let neverStream: Observable&lt;Int&gt; = Observable.never() _ = neverStream.subscribe({ _ in print(&quot;这个方法永远都不会被执行&quot;) }) justjust函数调用之后将会产生一个next事件以及一个Completed事件，其中next可以用来传递数据，最后的Completed事件发送之后将不会再有事件了。简单的说：just函数可以发送一个数据。 let justStream = Observable.just(32) _ = justStream.subscribe({ event in print(event) /* next(32) completed */ }) of将一个集合内的数据所有数据顺序的发送出去。 let ofStream = Observable.of(0, 1, 2) _ = ofStream.subscribe({ event in print(event) /* next(0) next(1) next(2) completed */ }) from将一个集合对象（比如数组、Range等）转换成流对象，通过订阅可以获得这个集合对象的所有内容。 let streamFromArray = Observable.from([0, 1, 2]) _ = streamFromArray.subscribe({ (event) in print(event) /* next(0) next(1) next(2) completed */ }) createcreate 函数是通过利用闭包来生成流对象的函数 let myJust = { (singleElement: Int) -&gt; Observable &lt;Int&gt; in return Observable.create({ (observer) -&gt; Disposable in observer.onNext(singleElement) observer.onCompleted() return Disposables.create() }) } let singleElementStream = myJust(32) _ = singleElementStream.subscribe { (event) in print(event) /* next(32) completed */ } error通过error函数将会生成一个终止的流，这个流中只会产生一次error事件并结束掉。 let error = NSError(domain: &quot;com.RxSwiftDemo.kesen&quot;, code: -1, userInfo: nil) let errorStream: Observable&lt;Int&gt; = Observable.error(error) _ = errorStream.subscribe { (event) in print(event) error(Error Domain=com.RxSwiftDemo.kesen Code=-1 &quot;(null)&quot;) } deffereddeffered函数生成的流对象，只有在添加了订阅者才会被创建。 let defferedStream = Observable.deferred { () -&gt; Observable&lt;Int&gt; in return Observable.create({ (observer) -&gt; Disposable in observer.onNext(0) observer.onNext(1) observer.onCompleted() return Disposables.create() }) } _ = defferedStream.subscribe({ (event) in print(event) /* next(0) next(1) completed */ }) SubjectSubject其实就是Observer，拥有Observer的所有功能，也可以认为是热的Observer。 PublishSubject它仅仅会发送observer订阅之后的事件，也就是说如果sequence上有.Next 的到来，但是这个时候某个observer还没有subscribe它，这个observer就收不到这条信息，它只会收到它订阅之后发生的事件。 ReplaySubject它和PublishSubject不同之处在于它不会漏消息。即使observer在subscribe的时候已经有事件发生过了，它也会收到之前的事件序列。 BehaviorSubject当有observer在订阅一个BehaviorSubject的时候，它首先将会收到Observable上最近发送一个信号（或者是默认值），接着才会收到Observable上会发送的序列。 VariableVariable是BehaviorSubject的封装，它和BehaviorSubject不同之处在于，不能向Variable发送.Complete和.Error，它会在生命周期结束被释放的时候自动发送.Complete。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"Rx & RAC","slug":"iOS/Rx-RAC","permalink":"http://superkk.top/categories/iOS/Rx-RAC/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://superkk.top/tags/Swift/"}]},{"title":"JS原型链与prototype","slug":"JS原型链与prototype","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T14:40:08.384Z","comments":true,"path":"2018/05/21/JS原型链与prototype/","link":"","permalink":"http://superkk.top/2018/05/21/JS原型链与prototype/","excerpt":"","text":"闭包：函数+在函数创建时刻关联的父作用域的一个集合体闭包在JavaScript当中就是一个函数和在函数创建时刻关联的父作用域的一个集合体，通过这个集合体，一个函数就可以访问外部函数的变量了。注意：是在函数创建时刻关联父作用域，而不是运行时刻关联。 当执行creatEatFunction的时候， eat函数才会被创建出来，此时eat函数就会把外部函数的作用域链记录下来（其中包含desc=’ is eating’)，以便执行时使用”比如eat函数的作用域链是这样的。输出1 JS中继承的实现：JS中没有类的概念，如何实现继承 1、通过__proto__实现继承：`JavaScriptvar animal = { name: ‘animal’, eat: function() { console.log(this.name+&#39; is eating&#39;); }}; var dog={ name: ‘dog’, proto: animal}; var cat={ name: ‘cat’, proto: animal}; dog.eat();cat.eat(); ![](https://raw.githubusercontent.com/action456789/Image/master/20190829223846.png) - 2、语法糖：`new` ```JavaScript function Student(name){ this.name=name, this.sayHello=function(){ console.log(&quot;Hi, I am &quot;+this.name); } } andy=new Student(&#39;andy&#39;); lisa=new Student(&#39;lisa&#39;); andy.sayHello(); lisa.sayHello(); 3、通过prototype实现继承，避免同一方法的多个副本。`JavaScript// 通过prototype实现继承Student.prototype={ sayHello2:function(){ console.log(&quot;Hi, I am &quot;+this.name); }} andy=new Student(‘andy’);lisa=new Student(‘lisa’); andy.sayHello();lisa.sayHello(); ![](https://raw.githubusercontent.com/action456789/Image/master/20190829223937.png) - 4、语法糖：`class` ```JavaScript // 语法糖 class Student2{ constructor(name){ this.name=name; } sayHello() { console.log(&quot;Hi, I am &quot;+this.name); } } andy=new Student2(&#39;andy&#39;); andy.sayHello();","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"js","slug":"大前端/js","permalink":"http://superkk.top/categories/大前端/js/"}],"tags":[]},{"title":"JS常用点","slug":"JS常用点","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T15:08:41.412Z","comments":true,"path":"2018/05/21/JS常用点/","link":"","permalink":"http://superkk.top/2018/05/21/JS常用点/","excerpt":"","text":"数组遍历for of：遍历数组value TIPS: for of 断点时，获取不到变量信息 const array = [ { name: &quot;张三&quot; }, { name: &quot;李四&quot; }, { name: &quot;王五&quot; }, { name: &quot;小红&quot; }]; let obj = { name: &quot;小红&quot;, age: 19, sex: &#39;女&#39;, } // for of：遍历数组value for (const item of array) { console.log(item.name); } for in：遍历对象key// for in：遍历对象key for (const key in obj) { console.log(`${key}:${obj[key]}`); } maplet nArray = array.map((value, index) =&gt; { return { ...value, type: &#39;哈哈&#39; } }) console.log(nArray); 切片：splice- [start, end) 从下标start开始，到下标end结束，不包括end - end 大于数组长度会截取到数组结束 let subArray = array.splice(0, 6) console.log(subArray) 解构赋值本质是模式匹配 数组 本质：实现了Iterator 接口的对象就可以按顺序解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定 let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 默认值 let [x = 1, y = x] = [2]; // x=2; y=2 let [foo = true] = []; foo // true let [x = 1] = [undefined]; x // 1 对象变量与属性同名 字符串赋值let { bar, foo, hello } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; foo // &quot;aaa&quot; bar // &quot;bbb&quot; hello // &quot;undefined&quot; 对象方法赋值const { log } = console; log(&#39;hello&#39;) // hello 变量名与属性名不同名let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; baz // &quot;aaa&quot; 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者 嵌套对象赋值 注意，对象嵌套赋值里，冒号:代表模式，并不是取值 const node = { loc: { start: { line: 1, column: 5 } } }; let { loc: { start }} = node; start // Object {line: 1, column: 5} loc // undefined let { loc, loc: { start }} start // Object {line: 1, column: 5} loc // Object {start: Object} let { loc: { start: { line }}} = node; line // 1 loc // undefined start // undefined 获取对象继承的属性const obj1 = {}; const obj2 = { foo: &#39;bar&#39; }; Object.setPrototypeOf(obj1, obj2); const { foo } = obj1; foo // &quot;bar&quot; 默认值var {x = 3} = {}; x // 3 var {x = 3} = {x: undefined}; x // 3 已声明变量的解构赋值 错误的写法 let x; {x} = {x: 1}; // SyntaxError: syntax error 正确的写法 let x; ({x} = {x: 1}); 函数参数的解构赋值函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 function add([x, y]){ return x + y; } add([1, 2]); // 3","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"js","slug":"大前端/js","permalink":"http://superkk.top/categories/大前端/js/"}],"tags":[]},{"title":"MacOS安装Jenkins","slug":"Jenkins安装","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T15:10:23.265Z","comments":true,"path":"2018/05/21/Jenkins安装/","link":"","permalink":"http://superkk.top/2018/05/21/Jenkins安装/","excerpt":"","text":"文档建议只看两处，蒲公英和fastlane的常用命令 启动sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist 关闭sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist 解决无法安装插件问题 第一步：插件管理 -&gt; Advanced -&gt; Update Site中，将https改为http 第二部：重启jenkins服务 权限问题导致无法执行脚本有两种解决办法： 方法一：设置用户权限（不推荐）这样设置后依然会存在其他的一系列问题，例如执行fastlane脚本报错 一般情况下，使用jenkins官网下载的安装包安装会出现这个问题。 在官网下载dmg安装包，安装完毕即可在本机搭建jenkins的工作。但是jenkins不会用本地的用户去构建，任何创建的文件都是“jenkins”用户所有，这会造成很多权限问题，无法调用自己写的脚本，执行shell会出现没有权限的错误。 解决办法：修改jenkins用户群组和用户 第一步：查看自己的群组和用户名称： 第二步：更改 Jenkins 用户群组和用户名称 //停止Jenkins sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist // 修改group 和user sudo vim +1 +/daemon +’s/daemon/staff/’ +/daemon +’s/daemon/ks’ +wq org.jenkins-ci.plist sudo chown -R ks:staff /Users/Shared/Jenkins/ // 开始Jenkins sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist 或者你也可以手动修改 org.jenkins-ci.plist 文件中的内容 第三步：若无法打开jenkins，需要修改下权限 $ sudo chown -R userName /Users/Shared/Jenkins $ sudo chown -R userName /var/log/jenkins #重启Jenkins $ sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist WARING: Jenkins更改工作空间会导致原来的数据全部丢失参考：https://www.cnblogs.com/ihojin/p/jenkins-permission.html 方法二：使用gem重新安装jenkins（推荐） 卸载使用安装包安装的jenkins //进入以下目录，双击运行 /Library/Application Support/Jenkins/Uninstall.command //也可以这样运行 sh &quot;/Library/Application Support/Jenkins/Uninstall.command&quot; //删除配置，这个可选 sudo rm -rf /var/root/.jenkins ~/.jenkins sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist sudo rm /Library/LaunchDaemons/org.jenkins-ci.plist sudo rm -rf /Applications/Jenkins &quot;/Library/Application Support/Jenkins&quot; /Library/Documentation/Jenkins sudo rm -rf /Users/Shared/Jenkins sudo dscl . -delete /Users/jenkins sudo dscl . -delete /Groups/jenkins sudo rm -f /etc/newsyslog.d/jenkins.conf pkgutil --pkgs | grep &#39;org\\.jenkins-ci\\.&#39; | xargs -n 1 sudo pkgutil --forget //如果使用brew安装的，可以执行以下命令 brew uninstall jenkins 安装 brew update &amp;&amp; brew install jenkins 启动 jenkins 参考：https://docs.fastlane.tools/best-practices/continuous-integration/jenkins/ Jenkins如何使用本地git仓库git地址填写为本地文件路径即可file:///home/rbkcbeqc/dev/git/gitsandbox.参考：https://stackoverflow.com/questions/10498554/jenkins-linking-to-my-local-git-repository 全局变量如何使用 这里自己添加的变量可以在shell脚本中直接使用。 echo $TOKEN_SIT","categories":[{"name":"工具","slug":"工具","permalink":"http://superkk.top/categories/工具/"}],"tags":[]},{"title":"微信小程序","slug":"微信小程序","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T14:54:14.391Z","comments":true,"path":"2018/05/21/微信小程序/","link":"","permalink":"http://superkk.top/2018/05/21/微信小程序/","excerpt":"","text":"升级（检查更新）https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html 使用mpvue进行小程序开发系列教程一斤代码的简书https://www.jianshu.com/p/8f779950bfd9 在mpvue中使用Vant Weapp组件库 1、将下载的小程序组件的dist目录拷贝到工程static目录下，然后改名，比如van-weapp 2、打开ES6转ES5 3、在需要使用van-weapp组件的页面创建main.json文件，并进行引入然后在main.json中添加如下内容 { &quot;usingComponents&quot;: { &quot;van-tab&quot;: &quot;../../../static/vant-weapp/tab/index&quot;, &quot;van-tabs&quot;: &quot;../../../static/vant-weapp/tabs/index&quot; } } 4、使用自定义组件 &lt;!-- 使用第三方组件 --&gt; &lt;van-tabs v-bind:active=&quot;active&quot; @click=&quot;onChange&quot;&gt; &lt;van-tab title=&quot;标签 1&quot;&gt;内容 1&lt;/van-tab&gt; &lt;van-tab title=&quot;标签 2&quot;&gt;内容 2&lt;/van-tab&gt; &lt;van-tab title=&quot;标签 3&quot;&gt;内容 3&lt;/van-tab&gt; &lt;van-tab title=&quot;标签 4&quot;&gt;内容 4&lt;/van-tab&gt; &lt;/van-tabs&gt; 注意：在vant-weapp的官方文档中的具体用法是使用wxml的语法，所以我们不能直接照搬使用比如官方文档示例代码为：&lt;van-tabs active=&quot;{{ active }}&quot; bind:change=&quot;onChange&quot;&gt; &lt;van-tab title=&quot;标签 1&quot;&gt;内容 1&lt;/van-tab&gt; &lt;van-tab title=&quot;标签 2&quot;&gt;内容 2&lt;/van-tab&gt; &lt;van-tab title=&quot;标签 3&quot;&gt;内容 3&lt;/van-tab&gt; &lt;van-tab title=&quot;标签 4&quot;&gt;内容 4&lt;/van-tab&gt; &lt;/van-tabs&gt; 具体参考https://www.jianshu.com/p/2adff147b8a6 其他参考：https://www.jianshu.com/p/1b3b9e17ac88","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"微信小程序","slug":"大前端/微信小程序","permalink":"http://superkk.top/categories/大前端/微信小程序/"}],"tags":[]},{"title":"React-Native Tips","slug":"React-Native Tips","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T14:25:52.228Z","comments":true,"path":"2018/05/21/React-Native Tips/","link":"","permalink":"http://superkk.top/2018/05/21/React-Native Tips/","excerpt":"","text":"快速进入断点 模拟器开启远程调试 在浏览器上cmd+option+I打开调试页面 代码输入dubugger进入断点 更新node 1、更新npmnpm -vnpm install npm@latest -g 2、更新nodesudo npm cache clean -f sudo npm install -g n sudo n stable 参考：https://www.hostingadvice.com/how-to/update-node-js-latest-version/","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"React-Native","slug":"大前端/React-Native","permalink":"http://superkk.top/categories/大前端/React-Native/"}],"tags":[]},{"title":"React-Native布局","slug":"React-Native 布局","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T14:25:25.038Z","comments":true,"path":"2018/05/21/React-Native 布局/","link":"","permalink":"http://superkk.top/2018/05/21/React-Native 布局/","excerpt":"","text":"https://facebook.github.io/react-native/docs/flexboxhttps://yogalayout.com/playground 颜色字符串backgroundColor: ‘#30576EA0’,前面两位（30）表示透明度，范围是0～99 盒子模型 边框属性(border)用来设定一个元素的边线。 边距属性(margin)是用来设置一个元素所占空间的边缘到相邻元素之间的距离。 间隙属性(padding)是用来设置元素内容到元素边界的距离。 Flexbox布局属性伸缩容器的属性主轴 flexDirection ：决定布局的主轴，默认值是竖直轴(column) row:（默认值） row-reverse column (RN默认值) column-reverse justifyContent ：决定其子元素沿着主轴的排列方式 flex-start:（默认值）从主轴的起点对齐 flex-end: 从主轴的终点对齐 center:从主轴的中间位置对齐 space-between:平均分布在主轴线上 space-around:平均分布在主轴线上，两端留下一半的距离 flexWap伸缩容器在主轴线方向空间不足的情况下，是否换行以及该如何换行 nowrap（默认值） wrap wrap-reverse 次轴 alignItems：决定其子元素沿着次轴的排列方式 flex-start（默认值）交叉轴起点对齐 flex-end 交叉轴终点对齐 center 中点对齐 stretch 拉伸 baseline 基线对齐baseline对齐效果：stretch效果（不设置高度时） align-content用来调整伸缩项目出现换行后在交叉轴上的对齐方式 flex-start flex-end center space-between space-around stretch（默认值） 其他 display flex 块级伸缩容器 inline-flex行内级伸缩容器 none隐藏元素 flex-flow同时定义了伸缩容器的主轴和侧轴, 其默认值为 row nowrap 伸缩项目的属性 order定义项目的排列顺序，数值越小，排列越靠前，默认值为0语法为：order：整数值 flex-grow定义伸缩项目的放大比例，为整数值 0(默认值): 不放大 其他值: 如果存在剩余空间，那么将自动占据全部剩余空间，每个item所占据的空间大小会根据这个值自动调整 flex-shrink定义伸缩项目的收缩能力，默认值为1 ，其语法为：flex-shrink:整数值 1(默认值) 其他值 如果不存在剩余空间，那么将自动缩小 flex-basis用来设置伸缩项目的基准值，剩余的空间按比率进行伸缩 auto(默认值) length flex是flex-grow flex-shrink flex-basis这三个属性的缩写，其语法为：flex:none | flex-grow flex-shrink flex-basis，其中第二个和第三个参数为可选参数，默认值为：0 1 auto alignSelf用来设置单独的伸缩项目在交叉轴上的对齐方式，会覆盖默认的对齐方式 auto 按照自身设置的宽高进行显示 flex-start flex-end center baseline stretch默认,伸缩项目在交叉轴方向占满伸缩容器，如果交叉轴为垂直方向的话，只有在不设置高度的情况下才能看到效果 React Native中的postion定位 relative 相对定位(默认)，以元素本来的位置为基准进行偏移。 absolute 绝对定位，以父元素的边框为基准进行偏移。https://blog.csdn.net/al4fun/article/details/80253364 width:&#39;100%&#39;与width:&#39;auto&#39; width:auto 会将元素撑开至整个父元素width，但是会减去子节点自己的margin，padding或者border的大小。 width:100% 会强制将元素变成和父元素一样的宽，并且添加额外的空间到这个元素的width上。就是因为这个，会导致很多问题。 使用width:100%永远都不是一个好主意。这个属性容易让人产生你正在定义一个元素可视大小，其实，你是在对这个元素的状态做了巨大的改变。 &lt;TouchableOpacity style={[styles.comButton]}&gt; &lt;Text style={[ { width: &quot;100%&quot;, height: &quot;100%&quot;, }]}&gt; {item.title} &lt;/Text&gt; &lt;/TouchableOpacity&gt; comButton: { padding:0, flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot;, color: CommonStyle.col_gray_dark, borderColor: CommonStyle.col_gray_dark, borderWidth: 0.8, borderRadius: 48, height: 44 } &lt;TouchableOpacity style={[styles.comButton]}&gt; &lt;Text style={[ { width: Platform.OS === &#39;ios&#39; ? &#39;auto&#39; : &quot;100%&quot;, height: Platform.OS === &#39;ios&#39; ? &#39;auto&#39; : &quot;100%&quot;, }]}&gt; {item.title} &lt;/Text&gt; &lt;/TouchableOpacity&gt;","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"React-Native","slug":"大前端/React-Native","permalink":"http://superkk.top/categories/大前端/React-Native/"}],"tags":[]},{"title":"React-Native数据传递","slug":"React-Native数据传递","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T15:18:04.779Z","comments":true,"path":"2018/05/21/React-Native数据传递/","link":"","permalink":"http://superkk.top/2018/05/21/React-Native数据传递/","excerpt":"","text":"通过react-navigation传递数据顺传传递数据 _onItemPress = (item) =&gt; { NavigationService.navigate(&quot;Page1&quot;, { data: item }); }; 获取数据 componentDidMount() { // 或者使用 this.props.navigation.getParam(&#39;data&#39;) let data = this.props.navigation.state.params.data; } 逆传传递数据 _callback = (message) =&gt; { console.log(message); } _onItemPress = (item) =&gt; { NavigationService.navigate(&quot;Page1&quot;, { callback: this._callback }); }; 子组件获取回调并执行 render() { return ( &lt;View style={styles.container}&gt; &lt;Button title={&#39;点击测试&#39;} onPress={() =&gt; this.props.navigation.state.params.callback(&#39;hello world&#39;) }&gt; &lt;/Button&gt; &lt;/View&gt; ); } 通过组件传递数据顺传传递数据 _renderItem = ({item, index}) =&gt; { return (&lt;View&gt; &lt;Component1 msg={item} index={index} dataA={this.state.dataA} navigation={this.props.navigation}/&gt; &lt;/View&gt;) }; 子组件获取数据 export default class Component1 extends Component&lt;Props&gt; { constructor(props) { super(props); this.state = { msg: this.props.msg, index: this.props.index, dataA: this.props.dataA, } } //父组件更新数据，子组件不刷新时使用 componentWillReceiveProps(nextProps) { this.setState({ msg: nextProps.msg, index: nextProps.index, dataA: nextProps.dataA, }); } } 逆传组件A传递callback _callback = (message) =&gt; { console.log(message); } render() { return ( &lt;View&gt; &lt;ComponentB callback={this._callback}&gt;&lt;/ComponentB&gt; &lt;/View&gt;) }; 组件B子组件获取传递过来的callback并执行 class ComponentB extends React.PureComponent { _onPress = () =&gt; { this.props.callback(&#39;hello world&#39;) }; render() { return ( &lt;View style={styles.container} &gt; &lt;Button title={&quot;点击测试&quot;} onPress={this._onPress} &gt; &lt;/Button&gt; &lt;/View&gt; ); } }","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"React-Native","slug":"大前端/React-Native","permalink":"http://superkk.top/categories/大前端/React-Native/"}],"tags":[]},{"title":"React-Native模版","slug":"React-Native模版","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T14:37:06.699Z","comments":true,"path":"2018/05/21/React-Native模版/","link":"","permalink":"http://superkk.top/2018/05/21/React-Native模版/","excerpt":"","text":"","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"js","slug":"大前端/js","permalink":"http://superkk.top/categories/大前端/js/"}],"tags":[]},{"title":"RxSwift map,flatMap,flatMapLatest的区别","slug":"RxSwift map,flatMap,flatMapLatest的区别","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T16:19:38.826Z","comments":true,"path":"2018/05/21/RxSwift map,flatMap,flatMapLatest的区别/","link":"","permalink":"http://superkk.top/2018/05/21/RxSwift map,flatMap,flatMapLatest的区别/","excerpt":"","text":"map flatMap flatMapLatest","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"Rx & RAC","slug":"iOS/Rx-RAC","permalink":"http://superkk.top/categories/iOS/Rx-RAC/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://superkk.top/tags/Swift/"}]},{"title":"快捷键","slug":"快捷键","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T14:57:04.784Z","comments":true,"path":"2018/05/21/快捷键/","link":"","permalink":"http://superkk.top/2018/05/21/快捷键/","excerpt":"","text":"Webstrom/IDEA 快捷键 双击 Shift / cmd + shift + A：全局搜索 cmd + B: 跳到变量申明处 cmd + iption + B: 跳转接口实现类 ctrl + F12: 可以显示当前文件的结构 ctrl + D: 行复制 cmd + Home/End：跳到文件头/尾 cmd + K: 代码补全 cmd + option + T：用 if, else, try, catch, for 等来围绕选中的代码块 cmd + N / ctrl + 回车：打开代码生成菜单 cmd + P：显示方法具体信息 ctrl + J：查看方法文档 cmd + E：显示打开的文件历史记录 cmd + U：进入父类 cmd + ⬆️/⬇️：进入上一个/下一个方法 cmd + shift + T：查看类、属性列表 option+ F7：全局找到自己被使用的地方 cmd + F7：在当前文件找到自己被使用的地方 cmd + PgUp / PgDn：左右tab切换 cmd +W：关闭当前tab cmd + option + U：显示类/接口的依赖关系UML图 cmd + option + V：自动生成返回值 cmd + F9：编译（idea热部署） option + shift + ⬆️/⬇️： 移动行 自动import ctrl+option+O：删除未使用的引用 多光标操作 ctrl+G：选中出现的单词并添加光标（Windows上为Alt + J） ctrl+shift+G：取消选中出现的单词（Windows上的Alt + Shift + J） option+shift+鼠标左键单机：在单击处添加光标 option+鼠标拖动：在选中处添加光标 选中操作 option+ ⬆️/⬇️：增加选中范围 / 减少选中范围 cmd+option+M：使用选中代码段生成函数 cmd+option+T：使用try catch等包围代码段 https://blog.jetbrains.com/phpstorm/2014/03/working-with-multiple-selection-in-phpstorm-8-eap/ android模拟器快捷键 cmd + m 显示开发者菜单 R + R reload iOS模拟器快捷键 cmd + d/ctrl+command+z 显示开发者菜单 cmd + r reload单使用模拟器软键盘时，cmd+r/cmd+d可能失效，此时使用ctrl+command+z即可或者：React Native 命令react-native start：启动react native服务器在特定模拟器上启动react-native run-ios --simulator &quot;iPhone 7 Plus”VSCode快捷键JSON 格式化 安装插件JSON Tools https://marketplace.visualstudio.com/items?itemName=eriklynd.json-tools Ctrl(Cmd)+Alt+M for JSON pretty. Alt+M for JSON minify. 其他Cmd + Shift + p打开命令面板 Cmd+T跳转到关键字（全局搜索变量或者函数） Option + Cmd + ⬅️/➡️ 不同tab间切换 Ctrl + - 前进（跳转到函数之后跳转回之前的位置） Ctrl + Shift + - 后退 ctrl + shift + y打开/关闭Debug Console Ctrl + ~ 打开/关闭终端（注意要在英文输入状态下，英文状态下是ctrl + ·导致无效） Cmd+1显示/隐藏侧边栏 Shift+cmd+k删除当前行 Ctrl + G 转到行 Ctrl + P 转到文件 Ctrl + Shift + O 跳转到关键字（文件内搜索变量或者函数） Shift+Option+ ↑ / ↓ 移动当前行到上一行/下一行 Cmd+E打开最近项目目录 多光标操作 cmd+shift+L添加光标到所有出现的单词处，并选中 cmd+g与cmd+shift+L配合可以在选中的单词间跳转 微信小程序编辑器快捷键windows 下ctrl+p 快速查找文件ctrl+e 快速查找最近打开过的文件 eclipse快捷键选中代码，ctrl + 1，打开列表反撤销，ctrl + y vim快捷键 撤销: 退出编辑模式，然后快速输入 u 两次 反撤销: 退出编辑模式，然后快速输入 ctrl + r 两次 粘贴:p Xcode快捷键| 快捷键 | 说明 | |:-|:-| | Command + Shift + O | 快速查找文件/文件夹 | | Ctrl + 6 | 在类中快速查查找方法 | | Ctrl + 2| 显示最近的浏览记录| | Command + Shift + j | 显示当前文件，在导航拦中的位置 | |option + cmd + 回车| 打开辅助视图 | |cmd + 回车 | 取消辅助视图 | | option（即windows下Alt键） + Cmd + 0 | 关闭Xcode右边的窗口 | | Cmd + 上方向键/下方向键 | 跳到代码开头/结尾 | | Control + Cmd + 方向键 | 在.h和.m间切换 | | cmd + 0 | 打开或者取消左边的导航栏 | | option + cmd 0 | 打开或者取消右边的属性视图 | | Control + I | 重新缩进代码 | | Control + Cmd + E | 统一修改变量名 | | Command + [ 或 Command + ] | 左移/右移代码块 | | Option + Command + [ 或 Option + Command + ] | 上移/下移代码 | | Command + Shift + 左/右方向键 | 选中当前行 | | Control + D | 删除光标右边的字符，相当与 windows 下的 Delete | | Command + Alt + ⬅️／➡️ | 折叠展开代码段 | | Command + L | 跳转到指定行 | | Command + option + / | 添加标准注释 | 大小写转换 storyBoard 快捷键 Command + Shift + _ / | 在 storyBoard 上添加辅助线 Command + Shift + 鼠标右键 选中某个 View 使用键盘移动控件 第一步：使用鼠标选中某个控件第二步：使用方向键进行移动，按住shift键 + 方向键可以更快的移动 多个控件层叠时选择某个控件鼠标右键+shift 模拟器快捷键 Cmd + shift + H回到桌面 按住Ctrl + Shift 点击控件，显示这个点上的所有控件 ⌥代表option键 Mac 快捷键 全屏截图：Command-Shift-3 指定区域截图：Command-Shift-4 显示隐藏快捷键：Command+Shift+.","categories":[{"name":"工具","slug":"工具","permalink":"http://superkk.top/categories/工具/"}],"tags":[]},{"title":"Swift中where的使用","slug":"Swift中where的使用","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T16:12:50.689Z","comments":true,"path":"2018/05/21/Swift中where的使用/","link":"","permalink":"http://superkk.top/2018/05/21/Swift中where的使用/","excerpt":"","text":"集合遍历 forEach 中使用let array = [0, 1, 2, 3, 4, 5, 6] test(&quot;集合遍历 forEach&quot;) { //使用switch遍历 array.forEach { switch $0 { case let x where x &gt; 3: //where相当于判断条件 print(x) default: print(&quot;默认值&quot;) } } } 集合遍历 for in 中使用 test(&quot;集合遍历 for in&quot;) { for value in array where value &gt; 2 { print(value) //输出3 4 5 6 } for (index, value) in array.enumerated() where index &gt; 2 &amp;&amp; value &gt; 3 { print(&quot;下标:\\(index), 值：\\(value)&quot;) } } 在补充异常的do/catch里使用enum SomeError: Error { case error1(Int) case error2(String) } func methodError() throws { throw SomeError.error1(3) } test(&quot;在补充异常的do/catch里使用&quot;) { do { try methodError() } catch SomeError.error1(let param) where param &gt; 2 { // 捕获异常时判断参数 print(&quot;判断参数的异常: \\(param)&quot;) } catch { print(&quot;默认异常处理&quot;) } } 协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展也可参考Swift面向协议编程.md protocol SomeProtocolA { func someProtocolMethodA() } class A: SomeProtocolA { let a = 1 func someProtocolMethodA() { print(a) } } class B { let b = 2 } // 针对类 A 扩展协议 // 基类A继承了SomeProtocol协议才能添加扩展 // 说人话：如果类A实现了 SomeProtocol 协议，那么可以进行扩展 extension SomeProtocolA where Self: A { func showParamA() { print(self.a) } } // 针对类 B 扩展协议 // 反例，不符合where条件 extension SomeProtocolA where Self: B { func someProtocolMethodA() { print(&quot;someMethodProtocolA&quot;) } } test(&quot;协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展）&quot;) { // 换个说法， 多个类实现了同一个协议，该语法根据类名分别为这些类添加扩展， 注意是分别(以类名区分)！！！ let objA = A() let objB = B() // 类B没实现SomeProtocol， 所有没有协议方法 objA.showParamA() //输出1 } protocol SomeProtocolB { func someProtocolMethodB() } // 针对协议 A 扩展协议 B extension SomeProtocolB where Self: SomeProtocolA { func someProtocolMethodB() { print(&quot;SomeProtocolB&quot;) } } class C: SomeProtocolA &amp; SomeProtocolB { func someProtocolMethodA() { print(#function) } func someProtocolMethodB() { print(#function) } } 协议使用where:情形二：只有基类同时遵守了另外一个协议才能添加扩展protocol SomeProtocolB { func someProtocolMethodB() } // 针对协议 A 扩展协议 B extension SomeProtocolB where Self: SomeProtocolA { func someProtocolMethodB() { print(&quot;SomeProtocolB&quot;) } } class C: SomeProtocolA &amp; SomeProtocolB { func someProtocolMethodA() { print(#function) } func someProtocolMethodB() { print(#function) } } test(&quot;协议使用where:情形二：只有基类同时遵守了另外一个协议才能添加扩展&quot;) { let objC = C() objC.someProtocolMethodA() }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://superkk.top/tags/Swift/"}]},{"title":"Swift高阶函数","slug":"Swift中的高阶函数","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T16:10:11.476Z","comments":true,"path":"2018/05/21/Swift中的高阶函数/","link":"","permalink":"http://superkk.top/2018/05/21/Swift中的高阶函数/","excerpt":"","text":"Swift高阶函数map对数组中的每个元素执行一次block中的操作 例如，获取数组中对象的某个属性，返回一个新的数组 // 获取字典中所有 value 返回一个数组，然后获取数组中对象的name字段，返回一个数组 let huxingMapDeviceNames:[String : DeviceModal] = Array(huxingMapDevices.values).map {$0.name} flatMap flatMap 与 map 不同之处是 flatMap返回后的数组中不存在 nil 同时它会把Optional解包; flatMap 还能把数组中存有数组的数组 一同打开变成一个新的数组 ; flatMap也能把两个不同的数组合并成一个数组 这个合并的数组元素个数是前面两个数组元素个数的乘积 例如上面的例子中返回的数组每个元素类型是 option(string) 而如果使用 flatmap 那么就是 string Filterfilter 可以取出数组中符合条件的元素 重新组成一个新的数组, 可以帮我们把数组中不需要的值都去掉 let numbers = [1,2,3,4,5,6] let evens = numbers.filter { $0 % 2 == 0 } // [2, 4, 6] Reduce用于把所有元素的值合并成一个新的值 比如我们要获得一个数组中所有元素的和 let numbers = [1,2,3,4,5] // reduce 函数第一个参数是返回值的初始化值 let sum = numbers.reduce(0) { $0 + $1 } 这里我写下完整的格式 let sum1 = numbers.reduce(0) { total, num in // 这里写不写return在Playground都循环5次 但上面用最洁简的方法显示循环6次。。。 What The Fuck 这是什么鬼！！！ return total + num } // 15 合并数组中的字符串 let numbers = [1,5,1,8,8,8,8,8,8,8,8] // reduce 函数第一个参数是返回值的初始化值 let tel = numbers.reduce(&quot;&quot;) { &quot;\\($0)&quot; + &quot;\\($1)&quot; } // 15188888888","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://superkk.top/tags/Swift/"}]},{"title":"Swift要点","slug":"Swift要点","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T16:10:11.480Z","comments":true,"path":"2018/05/21/Swift要点/","link":"","permalink":"http://superkk.top/2018/05/21/Swift要点/","excerpt":"","text":"Swift中的Array与Dictionary为struct类型在 Swift 中所有的基本类型，包括 Array 和 Dictionary 这些传统意义上会是 class 的东西，统统都是 struct 类型，并不能由 AnyObject 来表示，于是 Apple 提出了一个更为特殊的 Any，除了class 以外，它还可以表示包括 struct 和 enum 在内的所有类型。http://swifter.tips/any-anyobject/ Swift中的.self 2 在 Swift 中，.self 可以用在类型后面取得类型本身，也可以用在某个实例后面取得这个实例本身。前一种方法可以用来获得一个表示该类型的值，这在某些时候会很有用；而后者因为拿到的实例本身http://swifter.tips/self-anyclass/ Swift中类转字符串NSStringFromClass(UserProfileCell.self) // &quot;WechatMoments.UserProfileCell&quot; String(describing: UserProfileCell.self) // &quot;UserProfileCell&quot; String(describing: type(of: UserProfileCell.self)) // &quot;UserProfileCell.Type&quot; String(describing: type(of: self)) // &quot;UserProfileSectionController&quot; NSObject, AnyObject, Any NSObject：是OC中的基类 AnyObject： 包含了NSObject以及Swift中定义的类的对象 Any：所有的类型，包括了AnyObject，以及闭包类型 所以在范围上：Any &gt; AnyObject &gt; NSObject is运算符is 用于运行时判断具体类型，类似于isKindOfClass Swift包管理工具https://swift.org/package-manager/#example-usage |命令|描述| |:-|:-| |swift package init --type executable|创建可执行的包| |swift package init --type library|创建库| | swift package update | 更新一个包的依赖 | | swift package generate-xcodeproj | 为包生成 Xcode 项目 | | swift build | 编译库或可执行文件 | | swift test | 运行测试 | swift 中 static 与 class 关键字在类中static方法 与 class方法 class 方法 即 OC 中的类方法 static 方法 类方法，同时不允许子类重载 static变量 与 class变量 class 变量 swift当前版本暂不支持 static 变量 类变量 Swift性能优化分析","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://superkk.top/tags/Swift/"}]},{"title":"Swift要点","slug":"Swift面向协议编程","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T16:17:20.613Z","comments":true,"path":"2018/05/21/Swift面向协议编程/","link":"","permalink":"http://superkk.top/2018/05/21/Swift面向协议编程/","excerpt":"","text":"扩展协议 为协议方法增加默认实现 为协议增加方法，可以扩展系统中的协议 为协议增加计算属性 protocol Recordable: CustomStringConvertible { var wins: Int {get} var losses: Int {get} func winningPercent() -&gt; Double } // 扩展 Record 协议 extension Recordable { // 增加协议默认实现 var description: String { return &quot;Wins: \\(wins), Losses: \\(losses)&quot; } // 增加计算属性 var gamePlayed: Int { return wins + losses } // 增加方法 func winningPercent() -&gt; Double { return Double(wins) / Double(gamePlayed) } } 针对某个类扩展协议protocol SomeProtocolA { func someProtocolMethodA() } class A: SomeProtocolA { let a = 1 func someProtocolMethodA() { print(a) } } class B { let b = 2 } // 针对类 A 扩展协议 // 基类A继承了SomeProtocol协议才能添加扩展 // 说人话：如果类A实现了 SomeProtocol 协议，那么可以进行扩展 extension SomeProtocolA where Self: A { func showParamA() { print(self.a) } } // 针对类 B 扩展协议 // 反例，不符合where条件 extension SomeProtocolA where Self: B { func someProtocolMethodA() { print(&quot;someMethodProtocolA&quot;) } } test(&quot;协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展）&quot;) { // 换个说法， 多个类实现了同一个协议，该语法根据类名分别为这些类添加扩展， 注意是分别(以类名区分)！！！ let objA = A() let objB = B() // 类B没实现SomeProtocol， 所有没有协议方法 objA.showParamA() //输出1 } protocol SomeProtocolB { func someProtocolMethodB() } // 针对协议 A 扩展协议 B extension SomeProtocolB where Self: SomeProtocolA { func someProtocolMethodB() { print(&quot;SomeProtocolB&quot;) } } class C: SomeProtocolA &amp; SomeProtocolB { func someProtocolMethodA() { print(#function) } func someProtocolMethodB() { print(#function) } } 同时满足多个协议才进行扩展只有当类实现了Tieable协议才会进行扩展，换个说法：只有当某个类同时实现了这两个协议，才会有下列扩展的效果。 protocol Tieable { var ties: Int {get set} } // 同时扩展Record协议和Tieable协议（同时遵守了两个协议） extension Recordable where Self: Tieable { var gamePlayed: Int { return wins + losses + ties } // 有平局的情况下，需要计算ties func winningPercent() -&gt; Double { return Double(wins) / Double(gamePlayed) } } 覆盖协议中的默认实现// 棒球 struct BaseballRecord: Recordable { var wins: Int var losses: Int // 覆盖协议中的默认实现 let gamePlayed: Int = 162 } 协议聚合表示某个对象要满足多个协议，使用 &amp;连接多个协议 protocol Prizable { func isPrizable() -&gt; Bool } // one要满足多个协议 func award(one: Prizable &amp; CustomStringConvertible) { if one.isPrizable() { print(one) print(&quot;Congratulation&quot;) } } 为泛型参数增加协议约束// 单个协议 func top&lt;T: Recordable&gt;(seq: [T]) -&gt; T? { return seq.first } // 多个协议 func top&lt;T: Recordable &amp; Prizable&gt;(seq: [T]) -&gt; T? { return seq.first } 可选协议 需要标志位@objc，使得它兼容Objective-C代码，因为Swift要使用Objective-C的运行时来检查类所遵守的可选方法是否存在。 拥有可选方法的协议只能被类遵守，结构体和枚举是不可以遵守该协议的。 @objc protocol Animal { @objc optional func fly() }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://superkk.top/tags/Swift/"}]},{"title":"TextInput","slug":"TextInput","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T13:11:48.965Z","comments":true,"path":"2018/05/21/TextInput/","link":"","permalink":"http://superkk.top/2018/05/21/TextInput/","excerpt":"","text":"通用属性(Android &amp; iOS) (1)支持View的相关属性 (2)autoCapitalize:控制输入的字符进行切换成大写(参数:’none’,’sentences’,’words’,’characters’)none: 不自动切换任何字符大写sentences: 默认每个句子的首字母大写words:每个单词的首字母变成大写characters:每个字母全部变成大写 (3)autoCorrect(bool):设置瓶邪自动修正功能,默认开启(true) (4)autoFocus(bool):设置是否默认获取到焦点,默认为关闭(false).需要comonentDidMount方法调用之后才会获取焦点(componentDidMount是React组件被渲染之后React主动回调的方法) (5)defaultValue(string):给文本框输入一个默认初始值. (6)editable(bool):设置文本框是否可以编辑,默认为true,可以进行编辑 (7)keyboardType:键盘类型(可选参数:”default”, ‘email-address’, ‘numeric’, ‘phone-pad’, “ascii-capable”, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’) 该用来选择默认弹出键盘的类型例如我们甚至numeric就是弹出数字键盘。鉴于平台的原因如下的值是所有平台都可以进行通用的 (8)maxLength(number):可以限制文本输入框最大的输入字符长度 (9)multiline (bool) : 设置可以输入多行文字，默认为false(表示无论文本输入多少，都是单行显示) (10)onBlur (function): 监听方法，文本框失去焦点回调方法 (11)onChange (function): 监听方法,文本框内容发生改变回调方法 (12)onChangeText (function):监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容 (13)onEndEditing (function):监听方法，当文本结束文本输入回调方法 (14)onFocus (function) :监听方法 文本框获取到焦点回调方法 (15)onLayout (function):监听方法 组价布局发生变化的时候调用，调用方法参数为 {x,y,width,height} (16)onSubmitEditing (function):监听方法，当编辑提交的时候回调方法。不过如果multiline={true}的时候，该属性就不生效 (17)placeholder (string) :当文本输入框还没有任何输入的时候，默认显示信息，当有输入的时候该值会被清除 (18)placeholderText Color (string): 设置默认信息颜色(placeholer) (19)secureTextEntry (bool): 设置是否为密码安全输入框 ，默认为false (20)style 风格属性 可以参考Text组件风格 (21)value ( string ):输入框中的内容值 (22)returnKeyType:决定“确定”按钮显示的内容。donegonextsearchsend Android 平台属性 (22)numberOfLines (number):设置文本输入框行数，该需要首先设置multiline为true,设置TextInput为多行文本。 (23)textAlign 设置文本横向布局方式 可选参数(‘start’, ‘center’, ‘end’) (24)textAlignVertical: 设置文本垂直方向布局方式 可选参数(‘top’, ‘center’, ‘bottom’) (25)underlineColorAndroid: 设置文本输入框下划线的颜色 长按出现菜单键为英文，如何改为中文在Xcode中，TARGETS—你的项目名—info，选择Localization native development region，选择China，这样文字都会变成中文啦，包括时间选择器等也会变成中文。 键盘处理参考 const inputAccessoryViewID = &quot;inputAccessoryViewID&quot;; _renderLeaveWordInput() { return &lt;View style={{height: 60}}&gt; &lt;TextInput style={{ fontSize: 13, textAlignVertical: 'top', autoCapitalize: 'none', autoCorrect: false }} multiline={true} maxLength={50} onChangeText={this._onInputCommentsChange} value={this.state.comments} inputAccessoryViewID={inputAccessoryViewID} ref={&#39;LeaveWordTextInput&#39;} placeholder={&#39;请输入留言&#39;}/&gt; &lt;InputAccessoryView nativeID={inputAccessoryViewID}&gt; &lt;View style={{flexDirection:'row-reverse'}}&gt; &lt;Button onPress={() =&gt; {this.refs.LeaveWordTextInput.blur();}} title=&quot;完成&quot; color=&quot;red&quot; /&gt; &lt;/View&gt; &lt;/InputAccessoryView&gt; &lt;/View&gt; }","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"React-Native","slug":"大前端/React-Native","permalink":"http://superkk.top/categories/大前端/React-Native/"}],"tags":[]},{"title":"fastlane","slug":"fastlane","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T15:39:53.109Z","comments":true,"path":"2018/05/21/fastlane/","link":"","permalink":"http://superkk.top/2018/05/21/fastlane/","excerpt":"","text":"[TOC] 官方文档（推荐）https://docs.fastlane.tools/getting-started/ios/setup/ Mac上ruby管理工具 RVM因为rvm可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。 安装rvm $ curl -L get.rvm.io | bash -s stable $ source ~/.rvm/scripts/rvm 等待终端加载完毕,后输入： rvm -v 如果能显示版本好则安装成功了。 相关命令|描述|命令| |:-|:-| | 列出ruby可安装的版本信息 | rvm list known | | 更新RVM | rvm get stable | | 查看当前ruby版本 | rvm -v | | 安装一个ruby版本 | rvm install 2.3.3 | | 设置为默认版本 | rvm use 2.3.3 --default | | 使用某个版本 | rvm use 2.3.3 | | 查看已安装的ruby | rvm list | | 卸载一个已安装ruby版本 | rvm remove 2.3.3 | | 查看已有的源 | gem source -l | gem 常用命令官网https://gems.ruby-china.com/ |描述|命令| |:-|:-| | 更新 gem | sudo gem update --system | | 从Gem源安装gem包 | gem install [gemname] | | 更新所有已安装的gem包 |gem update | | 更新指定的gem包 | gem update [gemname]| | 删除指定的gem包，注意此命令将删除所有已安装的版本| gem uninstall [gemname]| | 查看本机已安装的所有gem包 | gem list [--local] | | 查看镜像 | gem sources -l | | 修改镜像 |gem sources –add https://gems.ruby-china.org/ –remove https://rubygems.org/，可以进入这两个网址查看详细信息 | fastlane官网https://fastlane.tools/ github: https://github.com/fastlane/fastlane/tree/master/snapshot |命令|描述| |:-|:-| | sudo gem install fastlane -NV | 安装/更新 fastlane | | fastlane init| 进入工程目录，初始化 fastlane 配置 | | fastlane update_fastlane | 更新fastlane各种插件等 | | fastlane actions | 列出所有可用fastlane活动 | | fastlane action [action_name] | 显示一个更详细的活动描述| | fastlane lanes | 列出所有可用lanes (有描述) | | fastlane list | 列出所有可用lanes (没有描述) | | fastlane new_action | 在fastlane创建一个活动(集成) | | fastlane search_plugins | 查看所有插件 | | fastlane add_plugin firim | 安装插件 firim | TODO:由于xcodebuild -showBuildSettings -project ./RiciBellSDKDemo.xcodeproj 命令卡死，导致无法继续，暂时没有找到解决办法，可能是因为使用了Xcode9 beta 版的Bug导致，后期再继续 收藏一篇博客http://www.jianshu.com/p/228354881eab gym 类似于shenzhen https://github.com/fastlane/fastlane/tree/master/gym#export-options |命令|描述| |:-|:-| | gym init | 创建Gymfile文件 | fastlane 的工具链在 fastlane 这个大家庭中，包含了下列工具： produce 创建可用于 iTunes Connect 和 Apple Developer Portal 的 iOS app。 cert 自动创建和维护 iOS 代码签名证书。 sigh 创建、更新、下载和修复 provisioning profiles。 snapshot 自动将 App 屏幕截图本地化到每种设备上。 frameit 将屏幕截图适配到适当的设备屏幕大小。 gym 创建和打包 iOS app。 deliver 上传屏幕截图、元数据和 App 到 App 商店。安装 fir 1、安装 |描述|命令| |:-|:-| | 安装 fir-cli | gem install fir-cli | 2、获取token登陆 获取 fir 账号的 token，当使用 fir login 登录了之后, 后续命令都不需要加上 -T 参数, 会默认使用当前用户的 token 进行相关操作 |描述|命令| |:-|:-| | 登陆 fir-cli | fir login XXX_YOUR_API_TOKEN_XXX | 3、编译打包 ipa 文件 |描述|命令| 参数说明| |:-|:-|:- | | 编译打包 ipa 文件 | schema=&quot;testFir&quot; fir build_ipa ~/Developer/$schema -o ~/Developer/build -w -C Release -S &quot;$schema&quot; | -w 是 –workspace 的简写，表示编译 *.xcworkspace, 没有带这个参数则编译 xcodeproj 文件。 -C Release, 以 Release 方式打包，若 Debug 则是打调试包。 -S: 编译用 CocoaPods 做依赖管理的 .ipa 包| 4、上传 ipa |描述|命令| 参数说明| |:-|:-|:- | | 上传 ipa | fir publish -c &quot;first version log&quot; ${schema}*.ipa | -c 后带 log。默认的包名是 schema-版本号-build－build 号，如 testFir-2.5.3-build-576.ipa。 | 使用 fastlane进行持续集成报错：You don&#39;t have write permissions for the /usr/bin directory.sudo gem install fastlane -n /usr/local/bin","categories":[{"name":"工具","slug":"工具","permalink":"http://superkk.top/categories/工具/"}],"tags":[]},{"title":"JS中的this绑定","slug":"JS中的this绑定","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T14:37:06.756Z","comments":true,"path":"2018/05/21/JS中的this绑定/","link":"","permalink":"http://superkk.top/2018/05/21/JS中的this绑定/","excerpt":"","text":"React 中传递闭包会导致this指向丢失// JS中传递闭包会导致this指向丢失 tmp:&#39;No!&#39;; let obj = { tmp:&#39;Yes!&#39;, testLog:function(){ console.log(this.tmp); } }; obj.testLog(); let tmpLog = obj.testLog; tmpLog(); 注意到现在没有直接调用obj对象中的testLog方法，而是使用了一个中间变量tmpLog过渡，当使用括号()调用该方法时，方法中的this丢失了指向，会指向window（或者react中的global），进而window.tmp未定义就是undefined： React在事件发生时调用onClick，由于onClick只是中间变量，所以处理函数中的this指向会丢失，为了解决这个问题，我们需要在实例化对象的时候，需要在构造函数中绑定this，使得无论事件处理函数如何传递，它的this的指向都是固定的，固定指向我们所实例化的对象。 JavaScript中this传递规则1、默认绑定，直接使用不带任何修饰的函数，this会指向全局环境。function foo1() { this.count = 100; } foo1() //直接使用，函数未经修饰 console.log(global.count) //输出全局环境中的count变量，就是函数中的this.count，结果为100 2、隐式绑定，当所调用的函数是某个对象的成员函数时，函数中的this会指向函数所在的对象。function foo() { console.log(this.count); } let obj = { count:1000, foo:foo }; obj.foo(); //输出100 隐式绑定可能会存在绑定丢失的场景，当函数作为参数传入到另外一个函数时，作为参数的函数所绑定的this会失效。 function foo(){ console.log(this.count); } function bar (func){ func(); } let count = 0; let obj = { count : 100, foo : foo }; bar(obj.foo); //会输出undefined 3、显式绑定，使用call()、apply()、bind()函数可以显式强制的绑定函数的thisfunction foo (){ console.log(this.count); } let count = &#39;window!&#39;; let obj1 = { count : 100, foo : foo }; let obj2 = { count : 200, foo : foo }; foo.call(obj1); //输出100 foo.call(obj2); //输出200 4、new 绑定，使用new操作符，可以将函数的this指向新创建的对象。function Foo(name, age){ this.name = name; this.age = age; } var obj = new Foo(&#39;Tom&#39;,99); console.log(obj); 绑定规则的优先级new绑定 &gt; 显示绑定 &gt;隐式绑定 &gt; 默认绑定","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"js","slug":"大前端/js","permalink":"http://superkk.top/categories/大前端/js/"}],"tags":[]},{"title":"JS中的Promise, async, await","slug":"JS中的Promise, async, await","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T15:22:19.814Z","comments":true,"path":"2018/05/21/JS中的Promise, async, await/","link":"","permalink":"http://superkk.top/2018/05/21/JS中的Promise, async, await/","excerpt":"","text":"准备代码//做饭 function cook() { console.log(&#39;开始做饭。&#39;); var p = new Promise(function (resolve, reject) { //做一些异步操作 setTimeout(function () { resolve(&#39;鸡蛋炒饭&#39;); // reject(&#39;烧焦的米饭&#39;); }, 1000); }); return p; } //吃饭 function eat(data) { console.log(&#39;开始吃饭：&#39; + data); var p = new Promise(function (resolve, reject) { //做一些异步操作 setTimeout(function () { resolve(&#39;一块碗和一双筷子&#39;); }, 2000); }); return p; } function wash(data) { console.log(&#39;开始洗碗：&#39; + data); var p = new Promise(function (resolve, reject) { //做一些异步操作 setTimeout(function () { resolve(&#39;干净的碗筷&#39;); }, 2000); }); return p; } //切菜 function cutUp() { var p = new Promise(function (resolve, reject) { //做一些异步操作 setTimeout(function () { resolve(&#39;切好的菜&#39;); }, 1000); }); return p; } //烧水 function boil() { var p = new Promise(function (resolve, reject) { //做一些异步操作 setTimeout(function () { resolve(&#39;烧好的水&#39;); }, 2000); }); return p; } async/await：解决Promise只是减少了嵌套，并不能完全消除嵌套的问题async 当调用一个 async 函数时，会返回一个 Promise 对象 当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值； 当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 当async 函数没有返回值，它会返回 Promise.resolve()。 await await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。 await后面调用的函数需要返回一个promise await 必须出现在 async 函数内部，不能单独使用。 若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行async function。 若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。 若 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。 一. then()：多个异步事件串行执行类似于RxSwift中flatMap 写法一cook() .then(data =&gt; { return eat(data); }) .then(data =&gt; { return wash(data); }) .then(data =&gt; { console.log(data); }); 写法二： 简化的写法// 简化的写法 cook() .then(eat) .then(wash) .then((data) =&gt; { console.log(data); }) .catch(err=&gt;{ console.log(err); }); 抛出异常// 抛出异常 cook() .then(data =&gt; { throw new Error(&#39;米饭被打翻了！&#39;); eat(data); }) .then(wash) .then((data) =&gt; { console.log(data); }) .catch(err =&gt; { console.log(err); }); 写法三：使用async/awaitasync function flatMap() { try { let cookResult = await cook(); let eatResult = await eat(); let washResult = await wash(); console.log(`async await flatMap test: ${cookResult},${eatResult},${washResult}~~~~~`); } catch (err) { console.log(`error: ${err}`); } } flatMap() // async await flatMap test: 鸡蛋炒饭,一块碗和一双筷子,干净的碗筷~~~~~ 二. all(): 多个异步事件并行执行，全部执行完毕后再执行then回调类似于RxSwift中zip 方式一：PromisePromise .all([cutUp(), boil()]) .then(results =&gt; { console.log(results); }); 方式二：使用async awaitasync function zip() { try { let results = await Promise.all([cutUp(), boil()]); console.log(`async await zip test ${results}`) } catch (err) { console.log(`error: ${err}`); } } zip() // async await zip test 切好的菜,烧好的水 三. race(): 多个异步事件同时执行，只要有一个执行完毕立即执行then回调方式一：PromisePromise .race([cutUp(), boil()]) .then(results =&gt; { console.log(results); }); 方式二：使用async awaitasync function race() { try { let results = await Promise.race([cutUp(), boil()]); console.log(`async await race test ${results}`) } catch (err) { console.log(`error: ${err}`); } } race() //async await race test 切好的菜 应用：为异步操作设置超时时间 //请求某个图片资源 function requestImg(){ var p = new Promise(function(resolve, reject){ var img = new Image(); img.onload = function(){ resolve(img); } img.src = &#39;xxxxxx&#39;; }); return p; } //延时函数，用于给请求计时 function timeout(){ var p = new Promise(function(resolve, reject){ setTimeout(function(){ reject(&#39;图片请求超时&#39;); }, 5000); }); return p; } Promise .race([requestImg(), timeout()]) .then(function(results){ console.log(results); }) .catch(function(reason){ console.log(reason); }); 参考：https://www.cnblogs.com/sweeeper/p/8442613.htmlhttps://segmentfault.com/a/1190000011526612?utm_source=tag-newest","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"js","slug":"大前端/js","permalink":"http://superkk.top/categories/大前端/js/"}],"tags":[]},{"title":"iOS自定义对象归档","slug":"iOS自定义对象归档","date":"2018-05-21T10:01:12.000Z","updated":"2019-08-29T15:58:23.411Z","comments":true,"path":"2018/05/21/iOS自定义对象归档/","link":"","permalink":"http://superkk.top/2018/05/21/iOS自定义对象归档/","excerpt":"","text":"自定义对象数据归档 如果想将一个自定义对象保存到文件中必须实现NSCoding协议 NJPerson类如下@interface NJPerson : NSObject &lt;NSCoding&gt; @property (nonatomic, copy) NSString *name; @property (nonatomic, assign) int age; @property (nonatomic, assign) double height; @end #import &quot;NJPerson.h&quot; @implementation NJPerson - (void)encodeWithCoder:(NSCoder *)encoder { NSLog(@&quot;NJPerson encodeWithCoder&quot;); [encoder encodeObject:self.name forKey:@&quot;name&quot;]; [encoder encodeInteger:self.age forKey:@&quot;age&quot;]; [encoder encodeFloat:self.height forKey:@&quot;heigth&quot;]; } - (id)initWithCoder:(NSCoder *)decoder { NSLog(@&quot;NJPerson initWithCoder&quot;); if (self = [super init]) { self.name = [decoder decodeObjectForKey:@&quot;name&quot;]; self.age = [decoder decodeIntegerForKey:@&quot;age&quot;]; self.height = [decoder decodeFloatForKey:@&quot;heigth&quot;]; } return self; } @end NJPerson 类有一个子类 NJStudent@interface NJStudent : NJPerson @property (nonatomic, assign) float weight; @end #import &quot;NJStudent.h&quot; @implementation NJStudent - (void)encodeWithCoder:(NSCoder *)aCoder { [super encodeWithCoder:aCoder]; [aCoder encodeFloat:self.weight forKey:@&quot;weight&quot;]; } - (id)initWithCoder:(NSCoder *)aDecoder { if (self = [super initWithCoder:aDecoder]) { self.weight = [aDecoder decodeFloatForKey:@&quot;weight&quot;]; } return self; } @end 归档NJStudent *stu = [[NJStudent alloc] init]; stu.name = @&quot;lnj&quot;; stu.age = 28; stu.height = 1.8; stu.weight = 60; [NSKeyedArchiver archiveRootObject:stu toFile:path]; 解档NJStudent *stu = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; 归档自定义对象的数组 自定义的对象要实现NSCoding协议 要先将数组归档为NSData，然后写到文件中 class DeviceModal: NSObject, NSCoding { public var id: String? public var name: String? public var frame: CGRect = CGRect.zero public var huxingMapImage: UIImage? func encode(with aCoder: NSCoder) { aCoder.encode(id, forKey: &quot;id&quot;) aCoder.encode(name, forKey: &quot;name&quot;) aCoder.encode(frame, forKey: &quot;frame&quot;) aCoder.encode(huxingMapImage, forKey: &quot;huxingMapImage&quot;) } required init?(coder aDecoder: NSCoder) { super.init() id = aDecoder.decodeObject(forKey: &quot;id&quot;) as? String name = aDecoder.decodeObject(forKey: &quot;name&quot;) as? String frame = aDecoder.decodeCGRect(forKey: &quot;frame&quot;) huxingMapImage = aDecoder.decodeObject(forKey: &quot;huxingMapImage&quot;) as? UIImage } init(id:String, name: String, frame: CGRect, image: UIImage?) { self.id = id self.name = name self.frame = frame self.huxingMapImage = image } } class PersistentTool: NSObject { private var filePath: URL { let documentPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] let filePath = URL(fileURLWithPath: documentPath).appendingPathComponent(&quot;AddedDevices.info&quot;) return filePath } public func saveArray(array: Array&lt;Any&gt;) { let data = NSKeyedArchiver.archivedData(withRootObject: array) try? data.write(to: filePath, options: .atomicWrite) } public func readArrayData() -&gt; Array&lt;Any&gt;? { do { let data = try Data(contentsOf: filePath) let array = NSKeyedUnarchiver.unarchiveObject(with: data) as? Array&lt;Any&gt; return array } catch { print(error) return nil } } }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[]},{"title":"iOS11新特性","slug":"iOS11新特性","date":"2017-12-22T15:02:12.000Z","updated":"2019-08-29T15:27:43.426Z","comments":true,"path":"2017/12/22/iOS11新特性/","link":"","permalink":"http://superkk.top/2017/12/22/iOS11新特性/","excerpt":"","text":"[TOC] iOS11 大标题// 导航控制器的`prefersLargeTitles`为大标题的总开关 navigationController?.navigationBar.prefersLargeTitles = true // 各个控制器可以自己通过 largeTitleDisplayMode，如果导航控制器的 `prefersLargeTitles` 为 NO，largeTitleDisplayMode 将没有效果 navigationItem.largeTitleDisplayMode = .never iOS11 导航栏搜索框let searchResultsVC = SearchResultTabelViewVC(nibName: nil, bundle: nil) lazy var searchController: UISearchController = { let vc = UISearchController(searchResultsController: searchResultsVC) vc.searchResultsUpdater = self.searchResultsVC vc.hidesNavigationBarDuringPresentation = true vc.dimsBackgroundDuringPresentation = true vc.searchBar.placeholder = &quot;搜索设备&quot; vc.searchBar.enablesReturnKeyAutomatically = false vc.searchBar.sizeToFit() return vc }() navigationItem.searchController = searchController navigationItem.hidesSearchBarWhenScrolling = false iOS11 Safe Area InsetsadditionalSafeAreaInsets = UIEdgeInsets(top: 100, left: 0, bottom: 100, right: 100) UITableView separatorInsetReference tableView.estimatedRowHeight = 0 tableView.estimatedSectionHeaderHeight = 0 tableView.estimatedSectionFooterHeight = 0 tableView.separatorInsetReference = .fromAutomaticInsets tableView.separatorInset.left = 60 UITableViewCell 左划、右划// iOS11 UITableViewCell 左划 override func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .normal, title: &quot;收藏&quot;) { (action, view, completionHandler) in // 执行收藏操作 // ... completionHandler(true) } action.image = imageLiteral(resourceName: &quot;favorite&quot;) action.backgroundColor = UIColor.red let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } // iOS11 UITableViewCell 右划 override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { let action = UIContextualAction(style: .destructive, title: &quot;删除&quot;) { (action, view, completionHandler) in // remove item // ... completionHandler(true) } let configuration = UISwipeActionsConfiguration(actions: [action]) return configuration } 代码见https://github.com/action456789/iOS11Demo","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"iOS SDK 开发","slug":"iOS-SDK-开发","date":"2017-12-09T07:07:25.000Z","updated":"2019-08-29T09:07:04.717Z","comments":true,"path":"2017/12/09/iOS-SDK-开发/","link":"","permalink":"http://superkk.top/2017/12/09/iOS-SDK-开发/","excerpt":"","text":"一、Framework与.a基础此处等下一期 二、工程嵌套联调静态库1、新建一个主工程 2、新建一个Library工程 3、将静态库工程拖到主工程文件夹下 如果你要拖到其他目录，就要改Library Search Paths 4、将Library工程下.a文件拖入主工程的Link Binary With Libraries如果有必要（运行时崩溃），将静态库需要加入 Embedded Binaries 中 5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程如下图给主工程添加对子工程的依赖，这样每次编译主工程的时候也会编译子工程。 三、在静态库中使用图片以及 xib 等资源文件1、添加 Bundle Target 因为iOS框架中没有bundle，要选中OS X框架找到bundle，如下图 2、将资源文件加入 bundle 中将工程中的资源文件都加入到刚刚建的bundle中，如xib、图片。点+号或直接拖都行。 3、iOS Deployment Target改为你支持的最低版本 4、设置base SDK 为latest iOS 5、编译 Bundle 6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程 7、加载 Bundle 里的资源文件7.1、加载图片使用运行时替换 [UIImage imageNamed:]方法，减少修改代码的工作量。相关代码在以下几个类中 // 在AppDelegate中执行以下代码即可swizzle 所有 [UIImage imageNamed:] #import &quot;UIImage+Swizzle.h&quot; - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [UIImage kk_autoLoadImageInBundle]; return YES; } UIImage+Swizzle.m`//// 修改所有的 [UIImage imageNamed:]的实现，改为先从同一项目中的 .bundle 文件中加载，没有再使用系统默认实现加载 (void)kk_autoLoadImageInBundle { SEL original = @selector(imageNamed:); SEL new = @selector(hook_kk_imageWithName:); [self kk_swizzleClassMethod:original with:new];} // 1. 从 .bundle 中加载图片// 2. 按照默认的方法加载图片 (instancetype)hook_kk_imageWithName:(NSString )imageName { UIImage image = [NSBundle kk_imageInBundle:kk_BundleName imageName:imageName]; if (!image) { image = [self hook_kk_imageWithName:imageName]; } return image;}` NSObject+Swizzle.m`#import “NSObject+Swizzle.h”#import &lt;objc/objc.h&gt;#import &lt;objc/runtime.h&gt; @implementation NSObject (Swizzle) (BOOL)kk_swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel { Class class = object_getClass(self); Method originalMethod = class_getInstanceMethod(class, originalSel); Method newMethod = class_getInstanceMethod(class, newSel); if (!originalMethod || !newMethod) return NO; method_exchangeImplementations(originalMethod, newMethod); return YES;} (BOOL)kk_swizzleClassMethod:(SEL)originalSel with:(SEL)newSel { Class class = object_getClass(self); Method originalMethod = class_getClassMethod(class, originalSel); Method newMethod = class_getClassMethod(class, newSel); if (!originalMethod || !newMethod) return NO; method_exchangeImplementations(originalMethod, newMethod); return YES;} @end ### 7.2、加载 `xib` #### 7.2.1 加载xib对应的`UIViewController` 需要重写xib对应控制器的 init 方法，否则可能出现找不到xib文件导致crash 参考[bundle打包xib文件](http://www.jianshu.com/p/a8c9e52c80de) (instancetype)init { NSBundle *bundle = [NSBundle kk_bundleWithName:kBundleTargetName]; self = [super initWithNibName:@”CalculatePriceViewController” bundle:bundle]; return self; } 代码参见：[github]([https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)](https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)) #### 7.2.1 加载xib对应的`UIVIew` 需要重写xib对应View的 init 方法，，否则可能出现找不到xib文件导致crash @implementation OfflineView //重写要加载的view的init方法 (instancetype)init { if (self = [super init]) { NSBundle *bundle = [NSBundle kk_bundleWithName:kk_BundleName]; self = [[bundle loadNibNamed:@&quot;OfflineView&quot; owner:self options:nil] lastObject]; } return self;} @end ### 7.3、加载 `Localizable.strings` #### 第一步：在Bundle中新建国际化文件 ![image.png](https://upload-images.jianshu.io/upload_images/1120923-6f11bf3b8f5d2236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) #### 第二步：添加语言，并将之前的国际化文件中的代码复制过来 ![image.png](https://upload-images.jianshu.io/upload_images/1120923-37cc110dd92a5079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) #### 第三步： 使用 NSBundle+Resource 如下方法 (NSString )mj_localizedStringForKey:(NSString )key; (NSString )mj_localizedStringForKey:(NSString )key value:(NSString *)value;然后使用如下宏定义 // 加载 Bundle 中的国际化语句#undef NSLocalizedString#define NSLocalizedString(key, comment) \\[NSBundle mj_localizedStringForKey:(key)]`然后就可以自动的加载Bundle中的字符串了 四、将整个App打包为Framework需要注意的地方 整个项目都要解除 AppDelegate 的依赖，AppDelegate不能打入Framework中 图片和xib文件需要按照 三 中的处理 可以使用 runtime 动态加载图片和xib文件，减少工作量 注意点：bundle中的国际化文件需要重新新建，添加语言，然后将之前App中的内容复制过来，直接拖进去是无效的 实际操作中存在的问题 图片同时存在@2x和@3x后缀导致加载的图片为nil的问题解决办法为只要@2x的图片 五、使用 appledoc 生成文档官网 安装brew install appledoc 查看版本appledoc --version 查看帮助appledoc --help 生成文档appledoc --output ./doc --project-name &quot;D103Framework&quot; --project-company &quot;RICISUNG&quot; --company-id &quot;RICISUNG&quot; . ”.“ 和前面的符号一定要加 空格 否则就会报错。 参考iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调](http://www.cnblogs.com/zhanglinfeng/p/5494762.html))iOS framework静态库中使用xib和图片资源详解","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"高级","slug":"iOS/高级","permalink":"http://superkk.top/categories/iOS/高级/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"git命令大全","slug":"git命令大全","date":"2017-09-09T13:09:46.000Z","updated":"2019-08-29T15:44:23.284Z","comments":true,"path":"2017/09/09/git命令大全/","link":"","permalink":"http://superkk.top/2017/09/09/git命令大全/","excerpt":"","text":"[TOC] 基本概念 master指针：指向最新的提交 资料http://sfault-image.b0.upaiyun.com/37/92/37923f2478edc5709b36562b26c9e008 全局配置$ git config --global user.name &quot;kk&quot;$ git config --global user.email &quot;superkesen@gmail.com&quot; 编辑模式查看全局设置：git config --global -e 列表形式查看全局设置：git config --global -l 使用GitHub时，在本地创建SSH Keyssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果一切顺利的话，可以在用户主目录里（~/.ssh）找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 远程仓库 克隆远程仓库到本地git clone git@github.com:michaelliao/gitskills.git 克隆远程仓库某个分支到本地git clone -b &lt;branch&gt; &lt;remote_repo&gt;例如： git clone -b 指定的分支名字 给本地仓库指定远程仓库 关联GitHub仓库：git remote add origin git@github.com:michaelliao/learngit.git 显示远程仓库：git remote show origin第一次推送使用：git push -u origin 分支名称之后推送使用：git push origin maste 查看远程仓库地址git remote -v 取消关联远程仓库git remote rm origin 初始化git仓库git initgit add .git commit -m “xxxx&quot; 文件操作删除所有文件git rm * -r删除文件夹git rm filename -r忽略无需版本控制的文档echo “*.txt” &gt; .gitignore 日志查看commit日志git reflog或git log 分支管理 查看当前所在分支git branch -a 切换到某个分支git checkout 分支名字 创建本地分支并切换到创建的分支：git checkout -b your_branch 提交该分支到远程仓库git push origin dev 追踪远程分支git branch --track release_2.3.0 origin/HEAD:refs/for/release_2.3.0 将本地分支push到远程分支，（远程会自动创建your_branch分支），并关联本地分支与远程分支git push -u origin your_branch 删除远程分支git push origin --delete &lt;branchName&gt; 删除本地分支git branch -d your_branch 本地提交回滚 先重置本地在上次提交之后的修改（如果需要的话）git checkout *.m 重置为远程仓库的最新版本soft表示本地的修改还在本地文件中，不加的话那么本地的修改也没了git reset HEAD^ --soft 拉取远程代码时冲突 保存本地修改到暂存区git stash 拉取远程代码git pull 将暂存区内容恢复到本地，有冲突时先解决冲突git stash pop git stash 的使用 列出所有暂时保存的工作git stash list 恢复某个暂时保存的工作 git stash apply stash@{1} 保存stash时设置stash名称git stash save &quot;my_stash&quot; 丢弃最近一次stash的文件git stash drop 合并某次提交 merge a specific commit in Gitgit cherry-pick d42c389f git merge 后 push 到 Gerrit 失败，提示 no new changes 在 git merge 的时候，加上 --no-ff 参数，是为了让它生成一个新的 commit，这样就可以提交了~（不过生成的 gerrit change 是看不到改动信息的） tag 操作 查看taggit tag 创建 本地 taggit tag 1.0.0或者git tag -m &quot;first release&quot; 0.1.0 推送 本地 tag 到远程服务器git push origin 1.0.0 或者推送所有tags到远程服务器git push --tags 删除本地 taggit tag -d 1.0.0 删除远程 tag 先删除本地 taggit tag -d 1.0.0 然后pushgit push origin --delete tag 1.0.0fatal: remote origin already exists.错误解决 先删除远程 Git 仓库 git remote rm origin2 再添加远程 Git 仓库 git remote add origin git@github.com:FBing/Java-code-generator git ignore 创建.gitignore文件touch .gitignore忽略规则示例# 这是注释行，将被忽略 *.a # 忽略所有以.a为扩展名的文件 !lib.a # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略 /TODO # 只忽略此目录下的TODO文件，子目录中的TODO文件不忽略 build/ # 忽略所有build目录下的文件，但如果是名为build的文件则不忽略 doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略 例如忽略下图的GPUImage.framework框架SystemVedio/GPUImage/GPUImage.framework 只追踪某几个文件 #忽略所有文件，注意放在开头 /* #除src文件夹外 !/src #除bin文件夹外 !/bin #总的效果就是git只跟踪src和bin两个文件夹 merge 与 rebase 的区别 作者：王靖轩链接：https://www.zhihu.com/question/36509119/answer/131513261来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 搞清楚这个问题首先要搞清楚merge和rebase背后的含义。 merge：会产生一次合并提交先看merge，官方文档给的说明是：git-merge - Join two or more development histories together 顾名思义，当你想要两个分支交汇的时候应该使用merge。根据官方文档给的例子，是master merge topic，如图：A—B—C topic/ \\D—E—F—G—H master然而在实践中，在H这个commit上的merge经常会出现merge conflict。为了避免解决冲突的时候引入一些不必要的问题，工程中一般都会规定no conflict merge。比如你在github上发pull request，如果有conflict就会禁止merge。 所以才会有题主问的问题：在当前的topic分支，想要引入master分支的F、G commit上的内容以避免merge conflict，方便最终合并到master。 这种情况下用merge当然是一个选项。用merge代表了topic分支与master分支交汇，并解决了所有合并冲突。然而merge的缺点是引入了一次不必要的history join。如图：A–B–C-X topic/ / \\D—E—F—G—H master其实仔细想一下就会发现，在引入master分支的F、G commit这个问题上，我们并没有要求两个分支必须进行交汇(join)，我们只是想避免最终的merge conflict而已。 rebase：将其他分支的内容整合到当前分支，改变当前分支branch out的位置rebase是另一个选项。rebase的含义是改变当前分支branch out的位置。这个时候进行rebase其实意味着，将topic分支branch out的位置从E改为G，如图：A—B—C topic/D—E—F—G master在这个过程中会解决引入F、G导致的冲突，同时没有多余的history join。但是rebase的缺点是，改变了当前分支branch out的节点。如果这个信息对你很重要的话，那么rebase应该不是你想要的。rebase过程中也会有多次解决同一个地方的冲突的问题，不过可以用squash之类的选项解决。个人并不认为这个是rebase的主要问题。 综上，其实选用merge还是rebase取决于你到底是以什么意图来避免merge conflict。实践上个人还是偏爱rebase。一个是因为branch out节点不能改变的情况实在太少。另外就是频繁从master merge导致的冗余的history join会提高所有人的认知成本。","categories":[{"name":"git","slug":"git","permalink":"http://superkk.top/categories/git/"}],"tags":[]},{"title":"Mac安装MQTT服务器","slug":"Mac安装MQTT服务器","date":"2017-03-03T07:08:59.000Z","updated":"2019-08-29T09:07:04.722Z","comments":true,"path":"2017/03/03/Mac安装MQTT服务器/","link":"","permalink":"http://superkk.top/2017/03/03/Mac安装MQTT服务器/","excerpt":"emqttd windows版安装具体以官方文档为主 下载http://emqtt.io/docs/v2/install.html#installing-on-windows 进入下载后的bin目录下cd C:\\Users\\kk\\Desktop\\emqttd\\bin\\然后执行emqttd console 进入Web管理控制台(Dashboard)控制台地址: http://127.0.0.1:18083默认用户: admin，密码：public","text":"emqttd windows版安装具体以官方文档为主 下载http://emqtt.io/docs/v2/install.html#installing-on-windows 进入下载后的bin目录下cd C:\\Users\\kk\\Desktop\\emqttd\\bin\\然后执行emqttd console 进入Web管理控制台(Dashboard)控制台地址: http://127.0.0.1:18083默认用户: admin，密码：public 或者使用 mosquitto 安装brew install mosquitto 配置服务器进入目录/usr/local/Cellar/mosquitto 进入响应版本下目录，我这里是1.4.11_2找到/etc/mosquitto/mosquitto.conf文件，修改mosquitto.conf可以对服务器进行配置 启动服务器进入sbin目录：/usr/local/Cellar/mosquitto/1.4.11_2/sbin然后执行：./mosquitto -c /usr/local/Cellar/mosquitto/1.4.11_2/etc/mosquitto/mosquitto.conf -d 参考：http://blog.csdn.net/pz0605/article/details/51970568","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"Autolayout高级","slug":"Autolayout高级","date":"2016-11-09T12:23:21.000Z","updated":"2019-08-29T15:12:28.199Z","comments":true,"path":"2016/11/09/Autolayout高级/","link":"","permalink":"http://superkk.top/2016/11/09/Autolayout高级/","excerpt":"","text":"[TOC] intrinsicContentSizeIntrinsic Content Size：固有大小。意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。 比如：大家都知道在使用 AutoLayout 的时候，UILabel 就不用指定尺寸大小，只需指定位置即可，就是因为，只要确定了文字内容，字体等信息，它自己就能计算出大小来。 UILabel，UIImageView，UIButton 等组件及某些包含它们的系统组件都有 Intrinsic Content Size 属性。 Content Hugging 约束（不想变大约束）如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要拉伸的时候拉伸。 Content Compression Resistance 约束（不想变小约束）如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要压缩的时候压缩。 例如： Top Layout GuidetopLayoutGuide属性表示不希望被透明的状态栏或导航栏遮挡的内容范围的最高位置。这个属性的值是它的length属性的值（topLayoutGuide.length） 这个值可能由当前的ViewController或这个ViewController所属的NavigationController或TabBarController决定，有如下情况： 一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。 包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义： 如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。 如果状态栏可见，topLayoutGuide表示状态栏的底部。 如果都不可见，表示ViewController的上边缘。 总之是屏幕上方任何遮挡内容的栏的最底部。 Safe Area*作用：取代topLayoutGuide和bottomLayoutGuide** safeArea是描述你的视图部分不被任何内容遮挡的方法。 改变布局的方法一、 setNeedsLayout与layoutIfNeeded更新Autolayout后，如何要立即刷新布局，还要依次调用以下两个方法 // 立即刷新布局（自己和subview的） self.view.setNeedsLayout() self.view.layoutIfNeeded() setNeedsLayout给当前 UIView 立一个 flag，以表示后续应该调用 layoutSubviews方法，以调整当前视图及其子视图的布局。 layoutIfNeeded如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews） 二、 layoutSubviews触发时机——Frame改变就会触发，具体如下 初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发 addSubview会触发layoutSubviews 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化 滚动一个UIScrollView会触发layoutSubviews 旋转Screen会触发父UIView上的layoutSubviews事件 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 何时重写 layoutSubviews 方法当我们在某个类的内部调整子视图位置时，需要调用；如果你想要在外部设置subviews的位置，就不要重写。 三、sizeToFit调用sizeToFit的时候，系统会根据内容的帮我布局一个它认为最合适的大小。 我们一般在不方便手动布局的时候才调用sizeToFit方法。比如 navigationBar中对navigationItem的设置，（添加两个视图以上的控件到Item） toolBar中的对UIBarButtonItem的设置（一般我们还要添加弹簧控件） 上述两种场合就可以用sizeToFit这个方法，来让系统给我们做自动布局。（注意：如果就添加一个控件的话，我们直接设置fram也是可以的） 在tabBar中我们不能手动的添加的子控件，因为tabBar是根据控制器系统默认自动添加的tabBarItem。（猜想系统可能也会自动调用了这个方法） UILabel中添加文字，然后让调整label的大小来适应文字，我们也调用sizeToFit的方法。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"高级","slug":"iOS/高级","permalink":"http://superkk.top/categories/iOS/高级/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"iOS调试内存泄露","slug":"iOS调试内存泄露","date":"2016-10-18T15:11:07.000Z","updated":"2019-08-29T15:33:04.189Z","comments":true,"path":"2016/10/18/iOS调试内存泄露/","link":"","permalink":"http://superkk.top/2016/10/18/iOS调试内存泄露/","excerpt":"","text":"[TOC] Xcode8使用Memory Graph 第一步：真机下运行APP后，点击 第二步：查看issue面板，注意选择右边Runtime 第三步：查看可能出现的内存泄露比如上图的 1 instance of __NSMallocBlock_leaked，点击后出现下图原因在于如下代码 group.didSelectedRowBlock = { [unowned self, group] row in guard let indexPaths = group.selectedIndexPaths else {return} if indexPaths.count &gt; 0 { self.shouldAdd = true let row = (indexPaths.firstObject as! IndexPath).row self.deviceAttri?.attrValue = String(row) } else { self.shouldAdd = false } } group的block中又使用了group，导致了循环引用，虽然使用了[unowned group]，事实证明并没有效果最后的解决办法是修改didSelectedRowBlock的接口，直接将selectedIndexPaths参数传入block参数中: group.didSelectedRowBlock = { [unowned self] indexPaths in guard let indexPaths = indexPaths else {return} if indexPaths.count &gt; 0 { self.shouldAdd = true self.deviceAttri?.attrValue = String(indexPaths.first!.row) } else { self.shouldAdd = false } } 第四步：在 debug 页面查看内存泄露情况有叹号说明需要注意可能存在内存泄露，可以看到 CoreFoundation中也可能存在内存泄露情况 使用Instruments的Leaks工具Time Profiler 查看多个线程里那些方法费时过多的方法 Call Tree上会默认按照费时的线程进行排序，单个线程中会也会按照对应的费时方法排序 Allocations 可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置 具体操作 在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation， 切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation， 这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。 Leak可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics&gt;Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。 其他调试方法勾选Address Sanitizer可以在运行时看到坏内存访问情况","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"使用WireShark 调试真机网络","slug":"使用WireShark-调试真机网络","date":"2016-10-09T07:09:37.000Z","updated":"2019-08-29T09:07:04.728Z","comments":true,"path":"2016/10/09/使用WireShark-调试真机网络/","link":"","permalink":"http://superkk.top/2016/10/09/使用WireShark-调试真机网络/","excerpt":"","text":"使用WireShark 调试真机网络需求：调试UIWebView加载缓慢问题 获取iPhone的UDID 2：根据获取的 UDID 创建一个虚拟的网卡rvictl -s &lt;UDID&gt; 通过 ifconfig 可以看到多了一个 rvi0接口通过 rvictl -l 命令可以列出所有挂接的虚拟接口 3: 在 Wireshark 首页选择 rvi0，使用默认的 Capture Options 即可开始对 iPhone 进行抓包。 其中 iPhone 手机连接 WiFi 动态获取的 IP 地址为 192.168.100.1。 黑色的内容表示遇到错误，需要重点关注关闭wifi，可以抓取移动网络数据包 -4 ： 使用rvictl -x命令删除虚拟接口, 使用 iPhone 的 UDID 作为参数。 WireShark 抓包技巧 第一步：找到请求网址的 IP 地址方法一：用ping命令得到对应的IP地址（可能不对，此时要用方法二） 方法二：使用DNS包来确定IP地址 注意手机上 DNS 解析的结果并不总是和电脑上的解析结果一致。这种情况下我们可以通过查看 DNS 数据包来确定DNS 是基于 UDP 的协议，不会有 TCP 重传 第二步：过滤 IP 地址 第三步：确定端口号 注意红框中的 SourcePort，这是客户端端口。我们知道 HTTP 支持并发请求，不同的并发请求肯定是占用不同的端口。所以在图中看到的上下两个数据包，并非一定是请求与响应的关系，他们可能属于两个不同的端口，彼此之间毫无关系，只是恰好在时间上最接近而已。 如果只想显示某个端口的数据，可以使用: ip.addr == 220.194.203.68 and tcp.dstport == 52914 如果只想看 HTTP 协议的 GET 请求与响应，可以使用 ip.addr == 220.194.203.68 and (http.request.method == “GET” || http.response.code == 200)来过滤。 如果想看丢包方面的数据，可以用 ip.addr == 220.194.203.68 and (tcp.analysis.fast_retransmission || tcp.analysis.retransmission) # 参考 http://ios.jobbole.com/93159/ http://blog.csdn.net/phunxm/article/details/38590561","categories":[{"name":"工具","slug":"工具","permalink":"http://superkk.top/categories/工具/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"《Effective Objective-C 2.0》读书笔记","slug":"《Effective-Objective-C-2-0》读书笔记","date":"2016-08-12T15:05:51.000Z","updated":"2019-08-29T09:07:04.747Z","comments":true,"path":"2016/08/12/《Effective-Objective-C-2-0》读书笔记/","link":"","permalink":"http://superkk.top/2016/08/12/《Effective-Objective-C-2-0》读书笔记/","excerpt":"","text":"[TOC] 多用类型常量，少用 #define 对于局部常量(.m文件中)， 使用 static 声明表明变量只在本文件中可见，所以无需前缀 同时使用 static const 关键字与#define 效果相同，好处在于带有类型信息。static const CGFloat kTopViewHeight = 40; 对于全局常量 由于全局使用，使用类名做前缀 在 .h 文件中使用 extern 声明extern NSString * const KKSlideTabBarBgColor; 在 .m 文件中定义NSString * const KKSlideTabBarBgColor = @&quot;name&quot;; NS_ENUM 与 NS_OPTIONS 使用 NS_ENUM 和 NS_OPTIONS 可以指定底层数据类型，而且可以保证系统兼容 当多种状态可以互相组合时，使用 NS_OPTIONS，否则使用 NS_ENUM 命名规则：前缀+状态 typedef NS_ENUM(NSUInteger, GDFConnectionState) { GDFConnectionStateDisconnected, GDFConnectionStateConnecting, GDFConnectionStateConnected, }; GDFConnectionStateDisconnected, GDFConnectionStateConnecting, GDFConnectionStateConnected, }; typedef NS_OPTIONS(NSUInteger, GDFDirection) { GDFDirectionUp = 1 &lt;&lt; 0, GDFDirectionDown = 1 &lt;&lt; 1, GDFDirectionLeft = 1 &lt;&lt; 2, GDFDirectionRight = 1 &lt;&lt; 3, }; 消息转发 message forwarding 动态方法解析 resolve method 动态方法解析是消息转发的第一步，在这里处理，效率最高@dynamic 属性 使编译器不自动生成实例变量及存储方法调用的方法：`Objective-C (BOOL)resolveInstanceMethod:(SEL)selector` 代码参见：Runtime.md 动态方法解析 resolve method 方法调配 method swizzling 作用1：在运行死交换两个方法的实现 // 根据方法名找到方法的实现 class_getInstanceMethod(__unsafe_unretained Class cls, SEL name) // 交换两个方法的实现 method_exchangeImplementations(Method m1, Method m2) 作用2：为既有的方法实现添加新功能——调试黑盒方法，为完全不知道具体实现的方法添加日志功能 @implementation NSString (EOC) + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } - (NSString *)eoc_myLowercaseString { NSString *lowercase = [self eoc_myLowercaseString]; NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase); return lowercase; } 类对象// 对象结构体 // isa 指针指向类对象 struct objc_object { Class isa; }; // 类结构体 // 1. 这个结构存放类的元数据，实例中的方法，变量等信息就存储在类对象中 // 2. isa 指针指向元类(metaclass)，元类描述类对象本身所具有的元数据，类方法就存储在元类中 // 3. 每个类只有一个类对象，每个类对象只有一个元类 typedef struct objc_class *Class; struct objc_class { Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols; }; 前缀 苹果保留了两字符前缀，我们应该使用三字符前缀 C函数名应该加上前缀 头文件中的全局变量需要加上前缀 为私有方法名添加前缀（例如p_），用于区分哪些方法是私有的，哪些是公有的，私有方法可以随意改动，公有方法则要三思而后行。 为第三方类添加分类时，分类中的方法要增加前缀，可以避免覆盖原有方法。 使用段位缓存代理能否响应某个方法 段位：结构体可以设置其成员所占的二进制位数struct { unsigned int fieldA : 8; // fieldA 占 8 个二进制位，即 0 ~ 255 unsigned int fieldB : 4; unsigned int fieldC : 2; unsigned int fieldD : 1;}_delegateFlag; 实例：`Objective-C@protocol KKSlideTabBarViewDelegate @optional; (void)slideTabBarView:(KKSlideTabBarView *)tabBar pageChangedFromIndex:(NSUInteger)from toIndex:(NSUInteger)to; (void)slideTabBarView:(KKSlideTabBarView )tabBar itemMoreClicked:(UIButton )itemMore;@end@interface KKSlideTabBarView : UIView@property (nonatomic,weak) id delegate;@endObjective-C@implementation KKSlideTabBarView {struct {unsigned int didPageChangedHandle : 1;unsigned int didItemMoreClickdHandle : 1;}_delegateFlags;} (void)setDelegate:(id)delegate {_delegate = delegate;_delegateFlags.didPageChangedHandle = [self.delegate respondsToSelector:@selector(slideTabBarView:pageChangedFromIndex:toIndex:)];_delegateFlags.didItemMoreClickdHandle = [self.delegate respondsToSelector:@selector(itemMoreClicked:)]; } ```Objective-C - (void)itemMoreClicked:(UIButton *)sender { if (_delegateFlags.didItemMoreClickdHandle) { [self.delegate slideTabBarView:self itemMoreClicked:sender]; }} } NSOperation 与 GCD 优缺点 GCD 优点：纯 C api，更加轻量级。而operation 是对象，更加重量级 NSOperation 优点： 操作加入队列后可以取消（已经启动的任务无法取消） 可以自动操作之间的依赖关系 可以使用 KVO 监控 NSOperation 对象的属性，比如通过 isCancelled 判断任务是否取消， isFinished 属性判断任务是否完成 可以指定每个操作的优先级，而 GCD 只能指定队列的优先级 可以自定义 operation 对象 使用 NSCache 和 NSPurgeableData 缓存数据 只有费时操作才值得放入缓存，比如需要从网络获取的数据、从磁盘读取的数据`Objective-C@interface KKSlideTabBarViewController (){NSCache *_cache;}@end _cache = [NSCache new];_cache.countLimit = 100;_cache.totalCostLimit = 5 1024 1024; NSPurgeableData *cacheData = [_cacheobjectForKey:@”url…”];if (cacheData) {// stop the data being purged[cacheData beginContentAccess]; // 使用数据// …… // Mark that the data may be purged again[cacheData endContentAccess];} else {NSData data = [NSData dataWithContentsOfURL:@”xxx”];NSPurgeableData purgeableData = [NSPurgeableData dataWithData:data];[_cache setObject:purgeableDataforKey:@”url…”cost:data.length]; // With access already maked // user data// ….. // Mark that the data may be purged now[purgeableData endContentAccess];} # 精简 + load 与 + initialize 方法 它们都是在类载入系统时由运行时系统调用，不能手动调用。 `+ load` 方法: 在类加载时调用。 系统会先调用父类的 load 再调用子类的 load，先调用类本身 load，再调用 categery load。 在 load 方法中，运行时系统处于脆弱状态，不能确定其他类是否加载完毕。不能在 load 方法中使用其他类对象，因为无法知道这个类是否加载了。 `+ initialize` 方法 `+ initialize` 方法是惰性加载，使用到类时才会调用。 `+ initialize` 方法调用时，系统处于正常状态，可以在 + initialize 方法中使用其他类对象。 `+ initialize` 方法一定会在线程安全的环境中执行，那么执行 + initialize 方法时会阻塞其他线程 如果子类没有实现 + initialize 方法，而父类实现了，那么会调用夫类的。所以应该这么实现： ```Objective-C + (void)initialize { if (self == [KKSlideTabBarView class]) { // 只有当 KKSlideTabBarView 类载入系统时才执行这里的代码 // 不然的话 KKSlideTabBarView 的父类载入系统也会调用 initialize } }","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"GCD用法全解","slug":"GCD用法全解","date":"2016-08-02T09:16:17.000Z","updated":"2019-08-29T09:07:04.724Z","comments":true,"path":"2016/08/02/GCD用法全解/","link":"","permalink":"http://superkk.top/2016/08/02/GCD用法全解/","excerpt":"","text":"[TOC] dispatch_time与dispatch_walltime的区别所有定时器dispatch source都是间隔定时器，一旦创建，会按你指定的间隔定期递送事件。当计算机睡眠时，定时器dispatch source会被挂起，稍后系统唤醒时，定时器dispatch source也会自动唤醒。定时器dispatch source会使用系统默认时钟来确定何时触发，但是默认时钟在计算机睡眠时不会继续。 如果你使用 dispatch_walltime 函数来设置定时器dispatch source，则定时器会根据挂钟时间来跟踪，这种定时器比较适合触发间隔相对比较大的场合，可以防止定时器触发间隔出现太大的误差。 区别： dispatch_time_t类型的时间我们可以通过dispatch_time来创建，也可以通过dispatch_walltime来创建。dispatch_time创建的时间多以第一个参数为参照物，之后过多久执行任务。dispatch_walltime多用于创建绝对时间，如某年某月某日某时某分执行某任务，比如闹钟的设置。 dispatch_time在计算机睡眠时会停止dispatch_walltime不会 例如以下情景 情景：希望一小时后执行任务，5分钟后计算机进入睡眠操作：50分钟后唤醒计算机实际：使用dispatch_walltime时: 5分钟后开始执行使用dispatch_time: 55分钟后开始执行 GCD 定时器的使用dispatch_source_set_timer 最后一个参数 leeway 详解 leeway 这个参数告诉系统我们需要计时器触发的精准程度。所有的计时器都不会保证100%精准，这个参数用来告诉系统你希望系统保证精准的努力程度。如果你希望一个计时器没五秒触发一次，并且越准越好，那么你传递0为参数。 如果是一个周期性任务，比如检查email，那么你会希望每十分钟检查一次，但是不用那么精准。所以你可以传入60，告诉系统60秒的误差是可接受的。 这样有什么意义呢？——降低资源消耗。如果系统可以让cpu休息足够长的时间，并在每次醒来的时候执行一个任务集合，而不是不断的醒来睡去以执行任务，那么系统会更高效。如果传入一个比较大的leeway给你的计时器，意味着你允许系统拖延你的计时器来将计时器任务与其他任务联合起来一起执行。 dispatch_queue_t mainQueue = dispatch_get_main_queue(); NSTimeInterval interval = 1.0f; NSTimeInterval delay = 1.0f; dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, mainQueue); dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, delay), interval * NSEC_PER_SEC, 1.0 * NSEC_PER_SEC); dispatch_source_set_event_handler(timer, ^{ NSLog(@&quot;%s&quot;, __func__); }); dispatch_resume(timer); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ dispatch_source_cancel(timer); }); 测试代码执行效率func testPerformance(closure: ()-&gt;()) { let startTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) closure() let endTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) print(endTime - startTime) } func testFunctionPerformance(selector: Selector) { let startTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) self.performSelector(selector) let endTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0) print(endTime - startTime) } GCD 加锁GCD 信号量的使用 设置信号量的个数为1时，可以当锁来使用 设置信号量的个数与CPU个数相近时（比如CPU个数 * 2），可以用来限制线程个数。 var semaphore: dispatch_semaphore_t = dispatch_semaphore_create(1) //MARK: ------------------- 使用信号量进行加锁操作 -------------------- func test_semaphore() { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in self.tast_first() } dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in self.tast_second() } dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in self.tast_third() } } func tast_first() { // p操作，进入临界区 dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) print(&quot;First tast starting&quot;) sleep(1) NSLog(&quot;%@&quot;, &quot;First task is done&quot;) // v操作，离开临界区 dispatch_semaphore_signal(self.semaphore) } func tast_second() { dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) print(&quot;Second tast starting&quot;) sleep(1) NSLog(&quot;%@&quot;, &quot;Second task is done&quot;) dispatch_semaphore_signal(self.semaphore) } func tast_third() { dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) print(&quot;Third tast starting&quot;) sleep(1) NSLog(&quot;%@&quot;, &quot;Thrid task is done&quot;) dispatch_semaphore_signal(self.semaphore) } 使用信号量控制多线程中代码执行顺序- (void)test_dispatch_semaphore_t_0 { dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [self method1]; sleep(10); dispatch_semaphore_signal(semaphore); }); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self method2]; } 延时执行//MARK: ------------------- dispatch_after 的使用-------------------- func dispatchAfter() { let delay: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, Int64(5 * Double(NSEC_PER_SEC))) dispatch_after(delay, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in print(&quot;viewDidLoad()&quot;) } } # GCD 多任务异步执行与 `dispatch_notify` 的使用 ```Objective-C //MARK: ------------------- 多任务异步执行 与 dispatch_group_notify 的使用 -------------------- func dispatchGroup() { let group: dispatch_group_t = dispatch_group_create() let globalQueueDefault: dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) // 串行队列按照先进先出的顺序执行（FIFO） let userQueueSerie: dispatch_queue_t = dispatch_queue_create(&quot;com.dispatchGroup.demo&quot;, DISPATCH_QUEUE_SERIAL) // 下载任务1 dispatch_group_async(group, userQueueSerie){ sleep(3) NSLog(&quot;Task1 is done&quot;) } // 下载任务2 dispatch_group_async(group, userQueueSerie){ sleep(3) NSLog(&quot;Task2 is done&quot;) } // 下载任务3 dispatch_group_async(group, globalQueueDefault){ sleep(3) NSLog(&quot;Task3 is done&quot;) } // 监听任务组事件的执行完毕 dispatch_group_notify(group, dispatch_get_main_queue()){ NSLog(&quot;Group tasks are done&quot;) } // 设置等待时间(即设置超时)，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败 // 等待直到完成 let result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER) if (result != 0) { print(&quot;Now viewDidLoad is done&quot;) } } # dispatch_group_apply ```Objective-C //MARK: ------------------- 多任务异步执行/同步执行 与 dispatch_apply 的使用 -------------------- func dispatchApply() { let iterations: Int = 20 // 迭代次数 let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) // 同步执行 self.testPerformance { () -&gt; () in dispatch_apply(iterations, globalQueue) { (index: Int) -&gt; Void in print(index, NSThread.currentThread()) } NSLog(&quot;iterations is over&quot;) } print(&quot;------------------------------------&quot;) // 异步执行 self.testPerformance { () -&gt; () in dispatch_apply(iterations, globalQueue, { (index: Int) -&gt; Void in dispatch_async(globalQueue, { () -&gt; Void in print(index, NSThread.currentThread()) }) }) NSLog(&quot;iterations is over&quot;) } print(&quot;------------------------------------&quot;) self.testPerformance { () -&gt; () in for i:Int in 1...iterations { print(i, NSThread.currentThread()) } } } dispatch_group_enter / dispatch_group_leave//MARK: ------------------- dispatch_group_enter / dispatch_group_leave ------------------- // 将任务组中的任务未执行完毕的任务数目加减1，这种方式不使用 dispatch_group_async 来提交任务， // 注意：这两个函数要配合使用，有enter要有leave，这样才能保证功能完整实现。 // 串行执行三个任务 func dispatchGroup_EnterAndLeave_Seriel() { let group = dispatch_group_create() for index:UInt32 in 1...3{ dispatch_group_enter(group)//提交了一个任务，任务数目加1 manualDownLoad(index){ print(&quot;Task \\(index) is done&quot;) dispatch_group_leave(group)//完成一个任务，任务数目减1 } } } func manualDownLoad(num: UInt32, block:()-&gt;()){ print(&quot;Downloading task &quot;, num) sleep(num) block() } // 并行执行三个任务 func dispatchGroup_EnterAndLeave_Concurrent() { let group = dispatch_group_create()//创建group let globalQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0) for index:UInt32 in 1...3 { dispatch_group_enter(group)//提交了一个任务，任务数目加1 manualDownLoad(index, queue: globalQueueDefault){ NSLog(&quot;Task\\(index) is done&quot;) dispatch_group_leave(group)//完成一个任务，任务数目减1 } } } func manualDownLoad(num: UInt32, queue:dispatch_queue_t, block:()-&gt;()){ dispatch_async(queue){ NSLog(&quot;Downloading task\\(num)&quot;) sleep(num) block() } } GCD 实战：资源竞争//MARK: ------------------- 多线程测试：资源竞争 -------------------- func test_mutiThread() { let userSerialQueue = dispatch_queue_create(&quot;com.test.mutiThread.userSerialQueue&quot;, DISPATCH_QUEUE_SERIAL) let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) let group = dispatch_group_create() // 当 &quot;Processing data&quot;（CUP处理速度） 速度远小于 &quot;Reading file&quot;（磁盘处理速度） 速度时，线程数占用过多 // 使用信号量来限制同时执行的任务的数量 let cupCount = NSProcessInfo.processInfo().processorCount // CPU 数量 let jobSemaphore = dispatch_semaphore_create(cupCount * 2) // 限制线程个数 for i:Int in 1...50 { dispatch_semaphore_wait(jobSemaphore, DISPATCH_TIME_FOREVER); dispatch_group_async(group, userSerialQueue, { () -&gt; Void in print(&quot;Reading file&quot;, i, NSThread.currentThread()) // sleep(2) dispatch_group_async(group, globalQueue, { () -&gt; Void in print(&quot; Processing data&quot;, i, NSThread.currentThread()) sleep(1) dispatch_group_async(group, userSerialQueue, { () -&gt; Void in print(&quot; writing file&quot;, i, NSThread.currentThread()) // sleep(2) dispatch_semaphore_signal(jobSemaphore); }) }) }) } dispatch_group_wait(group, DISPATCH_TIME_FOREVER) } 参考http://www.jianshu.com/p/6670cdbb1ebbhttp://www.dreamingwish.com/article/gcd-practice-io-race.html","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"CocoaPods 管理私有库","slug":"CocoaPods-管理私有库","date":"2016-06-09T10:02:18.000Z","updated":"2019-08-29T15:13:30.625Z","comments":true,"path":"2016/06/09/CocoaPods-管理私有库/","link":"","permalink":"http://superkk.top/2016/06/09/CocoaPods-管理私有库/","excerpt":"","text":"[toc] 一、创建私有 Cocoapod Spec Repo 仓库Spec Repo 是所有 pod 的索引，自己创建的私有 pod 库都将放在这里 创建一个空的私有 Cocoapod Spec Repo 的远程 git 仓库 执行命令pod repo add KSSpecPods https://coding.net/u/action456789/p/KSSpecPods.git 查看是否创建成功进入到~/.cocoapods/repos目录下，如果看到 KSSpecPods ，说明创建成功 二、创建需要放入 Cocoapod Spec Repo 仓库进行管理的私有库创建全新的私有库时 创建私有库的远程 git 仓库 创建本地私有库pod lib create podTestLibrary 关联本地私有库与远程仓库，并打上版本号，然后推送到远程 git 仓库git tag -m &quot;first release&quot; 0.1.0git push --tags #推送tag到远端仓库 编辑podspec文件例如： Pod::Spec.new do |s| s.name = &#39;TAFNetwork&#39; s.version = &#39;0.1.0&#39; s.summary = &#39;Just Testing.&#39; s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don&#39;t worry about the indent, we strip it! DESC s.homepage = &#39;https://github.com/action456789/CocoapodsPrivateLibTest&#39; #主页,这里要填写可以访问到的地址，不然验证不通过 # s.screenshots = &#39;www.example.com/screenshots_1&#39;, &#39;www.example.com/screenshots_2&#39; #截图 s.license = &#39;MIT&#39; #开源协议 s.author = { &#39;kesen&#39; =&gt; &#39;317331820@qq.com&#39; } s.source = { :git =&gt; &#39;https://github.com/action456789/CocoapodsPrivateLibTest.git&#39;, :tag =&gt; s.version} #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # s.social_media_url = &#39;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#39; #多媒体介绍地址 s.platform = :ios, &#39;7.0&#39; #支持的平台及版本 s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC s.source_files = &#39;TAFNetwork/Classes/**/*&#39; #代码源文件地址，**/*表示Classes目录及其子目录下所有文件， # s.resource_bundles = { #资源文件地址 # &#39;TAFNetwork&#39; =&gt; [&#39;TAFNetwork/Assets/*.png&#39;] # } s.public_header_files = &#39;TAFNetwork/Classes/**/*.h&#39; #NAME_OF_POD/Classes/**/*&#39;，公开头文件地址 s.frameworks = &#39;UIKit&#39; #所需的framework，多个用逗号隔开 # s.dependency &#39;CocoaAsyncSocket&#39;, &#39;~&gt; 7.5.0&#39; # s.dependency &#39;FMDB&#39;, &#39;~&gt; 2.5&#39; # s.dependency &#39;Reachability&#39;, &#39;~&gt; 3.2&#39; # s.dependency &#39;SAMKeychain&#39;, &#39;~&gt; 1.5.2&#39; end 验证podspec执行pod lib lint 私有库项目已经存在时 创建 podspec 文件pod spec create PodTestLibrary git@coding.net:wtlucky/podTestLibrary.git 验证podspec执行pod lib lint 三、本地测试podspec文件1）新建一个项目，在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。 在Podfile中我们可以这样编辑，有两种方式 pod &#39;podTestLibrary&#39;, :podspec =&gt; &#39;/Users/kesen/Desktop/Repository/KSSpecPods/podTestLibrary/podTestLibrary.podspec&#39; # 指定podspec文件 # pod &#39;podTestLibrary&#39;, :path =&gt; &#39;/Users/kesen/Desktop/Repository/KSSpecPods&#39; # 指定路径 2）安装依赖pod install 四、提交私有库到私有 Cocoapod Spec Repo 仓库 进入私有库目录，执行pod repo push KSSpecPods podTestLibrary.podspec 进入/Users/kesen/.cocoapods/KSSpecPods查看是否提交成功 五、私有制作好的私有库1）在 podfile 文件中加入代码 pod &#39;PodTestLibrary&#39;, &#39;~&gt; 0.1.0&#39; 2）执行 pod update然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了 六、更新私有库参考http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"cocoapods","slug":"iOS/cocoapods","permalink":"http://superkk.top/categories/iOS/cocoapods/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"如何更新React Native","slug":"如何更新React-Native","date":"2016-04-12T07:32:04.000Z","updated":"2019-08-29T09:07:04.744Z","comments":true,"path":"2016/04/12/如何更新React-Native/","link":"","permalink":"http://superkk.top/2016/04/12/如何更新React-Native/","excerpt":"","text":"最新的React Native已经更新到了0.33.0，如何更新自己已经搭建好的React Native开发环境呢，我按照以下步骤完成了更新，现记录下来，供有需要的人参考。 1.查看 react native 的最新版本。进入项目根目录，命令行执行npm info react-native 查看当前版本react-native --version 2.在项目目录下修改package.json文件，将下列代码中的 react-native 改为最新版本 &quot;dependencies&quot;: { &quot;react&quot;: &quot;^0.14.8&quot;, &quot;react-native&quot;: &quot;^0.33.0&quot; } 3. 命令行执行npm install --save react-native@0.33.0如果升级后出现类似于`react-native@0.33.0 requires a peer of react@~15.3.1 but none was installed.` 执行npm install --save react@~15.3.1 4. 运行程序如果更新后执行react-native run-android不能正确运行，而是出现类似：Could not find com.facebook.react:react-native:0.23.0.错误，或者在Android Studio中直接运行app时报错：Android Studio failed to resolve com.facebook.react:react-native:0.23.0那么可以按照下列命令修复，首先在命令行中执行：npm i执行完毕且不报错后，执行下面的命令，注意，在执行命令之后，某些文件可能会产生冲突，请确保你的本地文件记录可以恢复（在Android Studio中可以查看历史记录来恢复文件）react-native upgrade执行上面的命令可能会提示你是否覆盖文件。在解决冲突之后重新运行App即可。 如果还有问题，可以更新一下npm和Node.js再试 如何更新npmnpm install -g npm 如何更新Node.jsnpm update node.js","categories":[{"name":"大前端","slug":"大前端","permalink":"http://superkk.top/categories/大前端/"},{"name":"React-Native","slug":"大前端/React-Native","permalink":"http://superkk.top/categories/大前端/React-Native/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"消除编译器警告","slug":"消除编译器警告","date":"2016-01-09T09:54:41.000Z","updated":"2019-08-29T09:07:04.732Z","comments":true,"path":"2016/01/09/消除编译器警告/","link":"","permalink":"http://superkk.top/2016/01/09/消除编译器警告/","excerpt":"","text":"[TOC] 关闭 deprecated-declarations 警告.基本流程: push 当前警告入栈 忽略我们要消除的警告 执行会产生警告的代码 pop 警告出栈——恢复之前的状态`Objective-C#pragma clang diagnostic push#pragma clang diagnostic ignored “-Wdeprecated-declarations”/要屏蔽掉deprecated警告的代码 /#pragma clang diagnostic pop # 关闭 XCode8 `Convenience initializer missing a self call to....` 警告 ```Objective-C #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wobjc-designated-initializers&quot; /* 要屏蔽掉deprecated警告的代码 */ #pragma clang diagnostic pop undeclared selector警告#pragma clang diagnostic push #pragma clang diagnostic ignored&quot;-Wundeclared-selector&quot; //...... #pragma clang diagnostic pop Category is implementing a method which will also be implemented by its primary class当category重写类已有的方法时会出现此警告。 #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wobjc-protocol-method-implementation” //..... #pragma clang diagnostic pop","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[]},{"title":"iOS编译ffmpeg","slug":"iOS编译ffmpeg","date":"2015-11-06T02:59:45.000Z","updated":"2019-08-29T15:35:41.300Z","comments":true,"path":"2015/11/06/iOS编译ffmpeg/","link":"","permalink":"http://superkk.top/2015/11/06/iOS编译ffmpeg/","excerpt":"","text":"[TOC] iOS编译ffmpeg参考http://www.jianshu.com/p/08107176d5bb 1） 下载”一键编译”脚本https://github.com/kewlbear/FFmpeg-iOS-build-script 2）编译能在iOS下使用的FFMPEG library库进入脚本目录，执行./build-ffmpeg.sh 3）在xcode中引入FFMPEG library库新建工程，把上面编译好的FFmpeg-iOS拖到xcode工程中 编译后的文件夹中ffmpeg-2.5.3 是源码FFmpeg-iOS 是编译出来的库，里面有我们需要的.a静态库，一共有7个 执行lipo -info libavcodec.a，查看.a包支持的架构，这几个包都支持了armv7 armv7s i386 x86_64 arm64这几个架构，这个脚本果真是业界良心啊～～～ 4）加入依赖库libz.tbd libbz2.tbd libiconv.tbd等 5）为TARGETS 添加 search paths项目根目录用 $(SRCROOT) 表示 添加 Header Search Paths$(inherited)$(SRCROOT)/FfmpegDemo/FFmpeg-iOS/lib 添加 Library Search Paths （系统可能已经添加）$(inherited)`$(SRCROOT)/FfmpegDemo/FFmpeg-iOS/include 如果编译不过（如缺少文件）一般都是search paths路径没写对 5）修改某个.m文件为.mm注意，不能是引入FFmpeg库的文件，否则编译不过 6）引入头文件#include &quot;avformat.h&quot; 如果编译成功，说明 search patchs 设置成功 7）添加代码#include &quot;avutil.h&quot; av_register_all(); // 获取 ffmpeg 版本号 const char *version = av_version_info(); NSLog(@&quot;version: %s&quot;, version); 执行成功说明集成成功 各个CPU构架支持的设备","categories":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://superkk.top/categories/ffmpeg/"}],"tags":[]},{"title":"KVO深入解析","slug":"KVO深入解析","date":"2015-10-24T09:18:51.000Z","updated":"2019-08-29T09:07:04.705Z","comments":true,"path":"2015/10/24/KVO深入解析/","link":"","permalink":"http://superkk.top/2015/10/24/KVO深入解析/","excerpt":"","text":"[TOC] iOS 中监听某个值的改变有哪些方法？在一个复杂的，有状态的系统中，当一个对象的状态发生改变，如何通知系统，并对状态改变做出相应的行为是必需考虑的一个问题，在iOS中为这类问题提供了4种解决方法： NSNotifiactaion 和 NSNotificationCenter：通知中心 Delegates：代理， Callback：回调， KVO（Key-Value Observing）：键值观察 Key-Value Observing (简写为KVO)：当指定的对象的属性被修改了，允许对象接受到通知的机制。每次指定的被观察对象的属性被修改的时候，KVO都会自动的去通知相应的观察者。 KVO 是什么？ Objective-C 中的键(key)-值(value)观察(KVO)并不是什么新鲜事物，它来源于设计模式中的观察者模式，其基本思想就是：一个目标对象管理所有依赖于它的观察者对象，并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。 KVO 的用法 如果要监听“对象A”属性值的改变，先要为＂对象A＂的属性注册观察者（假设观察者为“对象B”）。`Objective-C (void)addObserver:(NSObject _Nonnull)anObserverforKeyPath:(NSString _Nonnull)keyPathoptions:(NSKeyValueObservingOptions)optionscontext:(void * _Nullable)context`anObserver : 观察者，注册 KVO 通知的对象. 其必须实现方法 observeValueForKeyPath:ofObject:change:context:.keyPath : 被观察的属性，其不能为nil.options : 表示要监听那些通知，一般为写 0context : 一些其他的需要传递给观察者的上下文信息，通常设置为 nil options 解释如下：NSKeyValueObservingOptionNew : change 字典中包含 key 改变后的新值NSKeyValueObservingOptionOld : change 字典中包含 key 改变前的旧值NSKeyValueObservingOptionInitial : 在添加观察者的时候立即发送一个通知给观察者,并且是在注册观察者方法返回之前NSKeyValueObservingOptionPrior : 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，这与-willChangeValueForKey:被触发的时间是相对应的。这样，在每次修改属性时，实际上是会发送两条通知。２. 观察者“对象B”实现 observeValueForKeyPath:ofObject:change:context:. 方法３. “对象A”移除监听者 - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;另外注意：keyPath 即被观察的属性只能是 NSString 类型 注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行 KVO 的实现原理键值编码和键值观察是根据 isa-swizzling 技术来实现的，主要依据runtime的强大动态能力。当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法实现真正的通知机制。同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。 重写新类的 class 方法重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。`Objective-C//打印如下内容：NSLog(@”self-&gt;isa:%@”,self-&gt;isa);NSLog(@”self class:%@”,[self class]); //在建立KVO监听前，打印结果为：self-&gt;isa:Personself class:Person //在建立KVO监听之后，打印结果为：self-&gt;isa:NSKVONotifying_Person self class:Person 2. 重写新类的 set 方法 新类会重写对应的set方法，是为了在set方法中增加另外两个方法的调用： ```Objective-C - (void)willChangeValueForKey:(NSString *)key - (void)didChangeValueForKey:(NSString *)key 其中，didChangeValueForKey:方法负责调用： - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 如果没有 setter 方法，那么 -setValue:forKey 方法会直接调用： - (void)willChangeValueForKey:(NSString *)key - (void)didChangeValueForKey:(NSString *)key 如果在没有使用键值编码且没有使用适当命名的访问起方法的时候，我们只需要显示调用上述两个方法，同样可以使用KVO！ 例子// // ViewController.m // KVO test // // Created by KeSen on 15/9/1. // Copyright (c) 2015年 KeSen. All rights reserved. // #import &quot;ViewController.h&quot; #import &quot;KSBaby.h&quot; @interface ViewController () { KSBaby *_baby; } @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO]; _baby = baby; // 一般如下使用 // [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil]; // 在 self 中监听 _baby 的 cry 属性变化 [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld| NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionPrior context:@&quot;ssss&quot;]; } - (void)dealloc { [_baby removeObserver:self forKeyPath:@&quot;cry&quot;]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { NSLog(@&quot;keyPath: %@\\n change: %@\\n context: %@\\n&quot;, keyPath, change, context); } - (IBAction)click:(UIButton *)sender { _baby.cry = @&quot;crying&quot;; } @end // // ViewController.m // KVO test // // Created by KeSen on 15/9/1. // Copyright (c) 2015年 KeSen. All rights reserved. // #import &quot;ViewController.h&quot; #import &quot;KSBaby.h&quot; @interface ViewController () { KSBaby *_baby; } @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO]; _baby = baby; // 一般如下使用 // [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil]; // 在 self 中监听 _baby 的 cry 属性变化 [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld| NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionPrior context:@&quot;ssss&quot;]; } - (void)dealloc { [_baby removeObserver:self forKeyPath:@&quot;cry&quot;]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { NSLog(@&quot;keyPath: %@\\n change: %@\\n context: %@\\n&quot;, keyPath, change, context); } - (IBAction)click:(UIButton *)sender { _baby.cry = @&quot;crying&quot;; } @end 那么：程序启动时输出： 点击按钮后输出： KVO与多线程注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行 // // ViewController.m // KVO test // // Created by KeSen on 15/9/1. // Copyright (c) 2015年 KeSen. All rights reserved. // #import &quot;ViewController.h&quot; #import &quot;KSBaby.h&quot; #import &quot;FBKVOController.h&quot; @interface ViewController () { KSBaby *_baby; FBKVOController *_observer; } @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO]; _baby = baby; // NSKeyValueObservingOptionNew : change 字典中包含 key 改变后的新值 // NSKeyValueObservingOptionOld : change 字典中包含 key 改变前的旧值 // NSKeyValueObservingOptionInitial : 在添加观察者的时候立即发送一个通知给观察者,并且是在注册观察者方法返回之前 // NSKeyValueObservingOptionPrior : 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，这与-willChangeValueForKey:被触发的时间是相对应的。这样，在每次修改属性时，实际上是会发送两条通知。 // 1. 一般用法如下 [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil]; // dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew context:@&quot;ssss&quot;]; // // }); // 2. 第三方库 FBKVOController 的用法 _observer = [[FBKVOController alloc] initWithObserver:self]; [_observer observe:_baby keyPath:@&quot;cry&quot; options:NSKeyValueObservingOptionNew block:^(id observer, id object, NSDictionary *change) { NSLog(@&quot;%@, %@&quot;, @&quot;FBKVOController&quot;, change[NSKeyValueChangeNewKey]); }]; } - (void)dealloc { [_baby removeObserver:self forKeyPath:@&quot;cry&quot;]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { NSLog(@&quot;%@&quot;, [NSThread currentThread]); NSLog(@&quot;keyPath: %@\\n change: %@\\n context: %@\\n&quot;, keyPath, change, context); } - (IBAction)click:(UIButton *)sender { // _baby.cry = @&quot;crying&quot;; // 1. 注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ _baby.cry = @&quot;cry again&quot;; }); } @end KVO 监听 NSMutableArray 的内容变化 将数组封装到一个对象中 给这个对象添加 KVO 监听 使用 [self.arrayObject mutableArrayValueForKey:@”array”] 获取数组对象，对数组对象今天添加删除操作，只有这样触发的数组才会触发 kvo 参考：http://www.cppblog.com/kesalin/archive/2012/11/17/kvo.htmlhttp://ningandjiao.iteye.com/blog/2009729http://www.bkjia.com/IOSjc/993206.htmlhttp://blog.csdn.net/wzzvictory/article/details/9674431","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"Hexo GitHub博客搭建","slug":"Hexo-GitHub博客搭建","date":"2015-09-09T04:01:05.000Z","updated":"2019-08-29T09:14:56.615Z","comments":true,"path":"2015/09/09/Hexo-GitHub博客搭建/","link":"","permalink":"http://superkk.top/2015/09/09/Hexo-GitHub博客搭建/","excerpt":"","text":"[TOC] 相关网站https://hexo.io/zh-cn/docs/ 准备工作 1、安装Node.jshttps://blog.csdn.net/u011619283/article/details/52368759 2、安装hexonpm install -g hexo-cli 本地站点搭建 1、初始化 Hexo进入自己创建的目录下hexo init 2、生成静态页面hexo generate 自动监视文件变化hexo generate --watch 3、启动服务hexo server 4、查看效果打开浏览器，输入 http://localhost:4000/ 部署到github 1、创建仓库仓库名称固定格式如下：yourGitbubUsername.github.io注意yourGitbubUsername必须与你的github用户名相同，否则无法部署 2、安装github部署器npm install hexo-deployer-git –save 3、修改本地配置文件_config.yml deploy: type: git repo: https://github.com/action456789/action456789.github.io.git branch: master 4、部署hexo generatehexo deploy 或者hexo g -d 5、测试部署成功以后，在浏览器中输入 http://action456789.github.io 即可在线浏览自己的博客啦 绑定域名https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html（亲测可行） 一定要创建CNAME文件，并且由于这种方式只支持单域名访问，CNAME文件中只有第一个域名会生效。 修改主题 直接去查找最流行的主题，github上有安装说明，这个是最靠谱的安装方法。 安装完成之后：输入hexo s --debug进行测试 hexo clean hexo generate hexo server (若是想本地预览和执行该命令预览) hexo deploy NexT主题官方文档http://theme-next.iissnan.com/getting-started.html 添加taghexo new page &quot;tags&quot; 博客的创建、修改与删除 1、创建新博客hexo new &quot;test_blog&quot; 删除博客删除博客文件后重新发布更新即可可能需要等几分钟才有效果 2、发布更新 hexo clean hexo generate hexo deploy 3、一些快捷键 hexo g == hexo generate hexo d == hexo deploy hexo s == hexo server hexo n == hexo new","categories":[{"name":"工具","slug":"工具","permalink":"http://superkk.top/categories/工具/"}],"tags":[]},{"title":"iOS中的时间","slug":"iOS中的时间","date":"2015-08-13T14:10:18.000Z","updated":"2019-08-29T09:07:04.731Z","comments":true,"path":"2015/08/13/iOS中的时间/","link":"","permalink":"http://superkk.top/2015/08/13/iOS中的时间/","excerpt":"","text":"[TOC] 设备开机后的时间 CACurrentMediaTime() 设备从开机时起到现在的时间，设备重启会重置，单位为秒 [[NSProcessInfo processInfo] systemUptime] 与CACurrentMediaTime()等价 相对某个参考系的时间 Date().timeIntervalSince1970 1970年1月1日凌晨为参考系，到现在的时间，一般用于表示时间戳 Date().timeIntervalSinceReferenceDate 世界时间（UTC）2001年1月1日凌晨到现在经过的时间，单位为秒 CFAbsoluteTimeGetCurrent() 与Date().timeIntervalSinceReferenceDate等价 当用户手动改变了设备上的系统时间后，基于系统时钟的上述方法返回的结果也会一同改变 print(CACurrentMediaTime()) // 设备刚重启 print(Date().timeIntervalSince1970) print(Date().timeIntervalSinceReferenceDate) print(CFAbsoluteTimeGetCurrent()) 必要时，从服务器上获取时间如果App本身对获取的时间精度要求很高，还是直接通过网络从服务器获取时间戳会比较保险。 当网络可用时，直接从服务器获取； 网络不可用时，且设备没有被重启过，可以根据上一次获取服务器时间戳的时刻到此时的时间差来推算出正确的时间","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"《黑客与画家》摘录","slug":"《黑客与画家》摘录","date":"2015-05-09T10:40:00.000Z","updated":"2019-08-29T09:07:04.738Z","comments":true,"path":"2015/05/09/《黑客与画家》摘录/","link":"","permalink":"http://superkk.top/2015/05/09/《黑客与画家》摘录/","excerpt":"","text":"“表面上这是一个机器的时代，但是实际上机器的设计者决定了我们的时代。程序员的审美决定了你看到的软件界面，程序员的爱好决定了你有什么样的软件可以使用。” ——《黑客与画家》 黑客如何才能做自己喜欢的事情？我认为这个问题的解决方法是一个几乎所有创作者都知道的方法：找一份养家糊口的“白天工作”（day job）。这个词是从音乐家身上来的，他们晚上表演音乐，所以白天可以找一份其他工作。更一般地说，“白天工作”的意思是，你有一份为了赚钱的工作，还有一份为了爱好的工作。 几乎所有的创作者在职业生涯的早期都有一份“白天工作”。画家和作家尤其显著。如果幸运的话，你能找到一份与你的“真正工作”非常相关的“白天工作”。音乐家似乎常常是在唱片行工作。同样地，钻研某种编程语言或操作系统的黑客，很可能会得到一份使用这些工具的“白天工作”。——《黑客与画家》 所有学员刚刚来到YC的时候，每人都会拿到一件白色T恤衫，上面写着“Make something people want”，等到他们的项目得到风险投资以后，又会收到一件黑色T恤衫，上面写着“I made something people want” ——《黑客与画家》 2014-12-17塞缪尔·约翰逊^说过，人们对一个作家的评价，需要100年才能达成一致^^。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。 2014-12-22坚持一丝不苟，就能取得优秀的成果。因为那些看不见的细节累加起来，就变得可见了。 2014-12-23要是能坐上时间机器回到过去，不管哪一个年代，有一件事都是不会改变的，那就是“祸从口出”。你一定要小心自己说的话。自以为无害的言论会给你惹来大麻烦。 2014-12-23历史的常态似乎就是，任何一个年代的人们，都会对一些荒谬的东西深信不疑。他们的信念还很坚定，只要有人稍微表示一点怀疑，就会惹来大麻烦。 2014-12-23如果别人告诉你应该相信什么，你就真的相信了，那么你就会和别人一样犯下同样的错误。如果你是南北战争前的南方庄园主，你会与北方开战；如果你是20世纪30年代的德国人，你会相信希特勒。 2015-01-04这时你要明白，自由思考比畅所欲言更重要。如果你感到一定要跟那些人辩个明自，绝不咽下这口气，一定要把话说清楚，结果很可能是从此你再也无法自由理性地思考了。我认为这样傲不可取，更好的方法是在思想和言论之间划一条明确的界线。在心里无所不想，但是不一定要说出来。我就鼓励自己在心里默默思考那些最无法无天的想法。你的思想是一个地下组织，绝不要把那里发生的事情一股脑说给外人听。“格斗俱乐部”的第一条规则，就是不要提到格斗俱乐部^。 2015-01-04守口如瓶，笑脸相迎 2015-01-08没有盗版是一种“优势”，但也是一个问题。一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。 2015-01-10要致富，你需要两样东西：可测量性和可放大性。你的职位产生的业绩，应该是可测量的，否则你做得再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。 2015-01-10乔布斯曾经说过，创业的成败取决于最早加入公司的那十个人。我基本同意这个观点，虽然我觉得真正决定成败的其实只是前五人。小团队的优势不在于它本身的小，而在于你可以选择成员。我们不需要小村庄的那种“小”，而需要全明星第一阵容的那种“小”。 2015-01-10团队越大，每个人的贡献就越接近于整体的平均值。所以，在不考虑其他因素的情况下，一个非常能干的人待在大公司里可能对他本人是一件很糟的事情，因为他的表现被其他不能干的人拖累了 2015-01-11「总的来说，这也是很好的处事原则。如果你有两个选择，就选较难的那个。如果你要选择是坐在家里看电视，还是外出跑步，那就出去跑步吧。这个方法有效的原因可能是遇到两个一难一易的选择时，往往出于懒惰的缘故，你会选择较易的那个选项。在意识深处，你其实知道不懒惰的做法会带来更好的结果，这个方法只是迫使你接受这一点。」 2015-01-12将公司管理视同软件优化还能帮助你避免VC担心的另一个陷阱——开发某种产品的时间过长。现在，黑客都已经熟知这一点，并总结出一个术语“过早优化”（premature optimization）。尽快拿出1.0版，然后根据用户的反映而不是自己的猜测进行软件优化。 2015-01-12你必须时刻牢记的最基本的原则就是，创造人们需要的东西，也就是创造财富。如果你想通过创造财富使得自己致富，那么你必须知道人们需要什么。 2015-01-12冷战、第二次世界大战、近代的大多数战争都说明了这个道理。要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。 2015-01-12财富与金钱是两个概念。金钱只是用来交易财富的一种手段，财富才是有价值的东西，我们购买的商品和服务都属于财富。 2015-01-12我们大多数人都在为其他人创造财富，然后用创造出来的财富交换金钱，再用金钱交换我们需要的另一种财富 2015-01-12现代社会的收入差距扩大是一种健康的信号。技术使得生产率的差异加速扩大，如果这种扩大没有反映在收入上面，只有三种可能的解释：（a）技术革新停顿了；（b）那些创造大部分财富的人停止工作了；（c）创造财富的人没有获得报酬。 2015-01-13美感是第一道关卡，丑陋的数学在世界上无法生存。 2015-01-13喜欢一件东西，却不知道为什么自己喜欢它，原因可能是这件东西是美的，但也可能因为他们的母亲也拥有同样的东西，或者杂志上某个明星使用它，或者仅仅因为它的价格很昂贵。人类的思想就是没有经过整理的无数杂念的混合。注: 因为它的价格很昂贵。人类的思想就是没有经过整理的无数杂念的混合。 2015-01-13好设计是简单的设计。 2015-01-13好设计是解决主要问题的设计 2015-01-13并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前沖刺的痛苦，而不是脚被钉子扎破的痛苦。 2015-01-14有一句俗话说，如果你自己做不到，那就去当老师。这在语言设计领域不成立，我认识的一些最出色的黑客就在当教授。但是，当老师的人确实有很多事情不能做。研究性职位给黑客带来了一些限制。在任何学术领域，都有一些题目是可以做的，另一些题目是不可以做的。不幸的是，这两类题目的区别通常取决于它们写成论文后看上去是不是很高深，而不是取决于它们对软件业的发展是否重要。最极端的例子可能就是文学，文学研究者的任何成果几乎对文学创作者都毫无影响。 2015-01-14认为所有语言都一样的看法的缺点是自欺欺人，但是优点是可以使许多事情变得很简单。我想这就是为什么它被广泛接受的主要原因。它是一个令人舒服的想法。 2015-01-14大家都觉得Java—定有过人之处，因为它是一种很酷的新兴编程语言。但是真的如此吗？如果你站在远处观察编程语言的世界，似乎Java就是最新的东西。（如果你站得足够远，那么你看到的所有东西就是Sun公司出钱制作的大型霓虹广告牌。）但是，如果你靠近观察这个世界，就会发现不同的人对“酷”的理解是不一样的。在黑客圏子里，Perl被公认比Java酷得多。黑客社区网站Slashdot就是用Perl开发的。我估计你不可能看到黑客愿意使用Java的JSP技术开发网站。可是，还有一种更新的语言叫做Python，它的使用者往往看不起Perl。另一些人则认为Ruby语言是取代Python的最佳选择。 当你按照Java、Perl，Python，Ruby这样的顺序观察这些语言，你会发现一个有趣的结果。至少，如果你是一个Lisp黑客，你就看得出来，排在越后面的语言越像Lisp。Python语言模仿Lisp，甚至把许多Lisp黑客认为属于设计错误的功能也一起模仿了。至于Ruby语言，如果回到1975年，你声称它是一种有着自己句法的Lisp方言，没有人会提出反对意见。编程语言现在的发展不过刚刚赶上1958年Lisp语言的水平。 2015-01-15 如果你创业的话，千万不要为了取悦风险投资商或潜在并购方而设计你的产品。让用户感到满意才是你的设计方向。只要赢得用户，其他事情就会接踵而来。 2015-01-15 在大型组织内部，有一个专门的术语描述这种跟随大多数人的选择的做法，叫做“业界最佳实践”。这个词出现的原因其实就是为了让你的经理可以推卸责任。既然我选择的是“业界最佳实践”，如果不成功，项目失败了，那么你也无法指责我，因为做出选择的人不是我，而是整个“业界”。 2015-01-15 第一，不同语言的编程能力不一样。第二，大多数经理故意忽视第一点 2015-01-15 Fortran和Cobol是早期IBM大型机的脚本语言。C是Unix的脚本语言，后来的Perl和Python也是如此。Tel是Tk的脚本语言，Visual Basic是Windows的脚本语言，（某种形式的）Lisp是Emacs的脚本语言，PHP是网络服务器的脚本语言，Java和JavaScript是浏览器的脚本语言。 2015-01-15 有一个笑话说，黑客动手写程序之前，至少会在心里盘算一下哪种语言的打字工作量最小，然后就选择使用该语言。","categories":[{"name":"读书","slug":"读书","permalink":"http://superkk.top/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://superkk.top/tags/读书/"}]},{"title":"cocoapods 安装与使用","slug":"cocoapods-安装与使用","date":"2014-09-03T01:10:54.000Z","updated":"2019-08-29T09:02:37.969Z","comments":true,"path":"2014/09/03/cocoapods-安装与使用/","link":"","permalink":"http://superkk.top/2014/09/03/cocoapods-安装与使用/","excerpt":"","text":"常见命令更新本地索引库需要经常手动进行更新，尤其在苹果有大的版本发布之后，各个第三方库会在随后更新pod repo update 更新cocoapod版本gem install cocoapods --pre 单独更新某个库pod update MJRefresh 安装 1.安装 rvm参考：http://ruby-china.org/wiki/rvm-guide，测试可行 2.安装ruby同样参考上面的网站 3.开始安装cocoapods升级ruby的gemsudo gem update --system安装cocoapodssudo gem install cocoapods还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。 请参见cocoapods官网 https://cocoapods.org 4.更新ruby的源 最新的国内安装源可以在这里看到 https://gems.ruby-china.org gem sources --remove https://rubygems.org/ gem sources -a https://ruby.taobao.org/ gem sources -l 参考唐巧博客：http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/ 二、重装 更新了 Xcode 7 和 OSX 0.11.1 后，install pod 不好使了。试了下重新安装 cocoapods。遇到了一些问题 1. 执行 sudo gem install cocoapods 出现了如下错误： ERROR: Could not find a valid gem ‘cocospods’ (&gt;= 0), here is why:Unable to download data from http://ruby.taobao.org/ - bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz) 解决办法：将http 替换成 https，具体如下 gem sources –remove http://ruby.taobao.org/ gem sources -a https://ruby.taobao.org/ 查看源对不对gem sources -l 再安装就好了sudo gem install cocoapods 2. 然后可以执行 sudo gem install cocoapods 了。但是执行到一半又出现了如下错误 While executing gem … (Errno::EPERM)Operation not permitted - /usr/bin/xcodeproj 解决办法：自定义GEM_HOME命令行操作： $ mkdir -p $HOME/Software/ruby $ export GEM_HOME=$HOME/Software/ruby $ gem install cocoapods [...] 1 gem installed $ export PATH=$PATH:$HOME/Sofware/ruby/bin $ pod --version 0.39.0 然后就顺利安装成功了 ## 三、使用 cocoapods ~### 更换clone github镜像，加快 pod 代码下载速度~ $ cd ~/.cocoapods/repos $ pod repo remove master $ git clone https://git.coding.net/hging/Specs.git master ~然后需要在 podfile文件中加入如下代码~ // 如果不加这一句话，它默认还是从github镜像源地址去下载的 source &#39;https://git.coding.net/hging/Specs.git&#39; 目前没有发现比较好的镜像，上面的镜像pod里库的版本已经很低，不建议使用了，所以暂时无法解决慢的问题。 —- ### 常用命令 pod search pop pod init pod install pod install --verbose --no-repo-update pod update pod update --verbose --no-repo-update ### 注意点 * 如果 import 的时候没有提示 POP.h 的文件，可以在 target-Build Settings 下修改 User Header Search Paths 项，新增 ${SRCROOT} 并选择 rcursive，如下图。 ## 四、参考： 安装Cocoapods， 更新gem出现的问题 Mac OS X 跟新到10.11后cocoapods安装出现的问题（- bad response Not Found 404 (http://ruby.taobao.org/latest_spe 使用CocoaPods管理依赖库 解决CocoaPods慢的小技巧","categories":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/categories/iOS/"},{"name":"cocoapods","slug":"iOS/cocoapods","permalink":"http://superkk.top/categories/iOS/cocoapods/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://superkk.top/tags/iOS/"}]},{"title":"2013读书摘录","slug":"读闲书 摘录一","date":"2013-12-30T10:52:43.000Z","updated":"2019-08-29T09:07:04.711Z","comments":true,"path":"2013/12/30/读闲书 摘录一/","link":"","permalink":"http://superkk.top/2013/12/30/读闲书 摘录一/","excerpt":"","text":"《月亮和六便士》 人们在仰望月亮时常常忘了脚下的六便士——月亮与六便士 《且听风吟》 于是我一只手拿尺，开始惶惶不安地张望周围的世界。那年大概是肯尼迪总统惨死的那年，距今已有15年之久。这15年里我的确扔掉了很多很多东西。就像发动机出了故障的飞机为减轻重量而甩掉货物、甩掉座椅、最后连可怜的男乘务员也甩掉一样。十五年里我舍弃了一切，身上几乎一无所有。至于这样做是否正确，我无从断定。心情变得痛快这点倒是确确实实的。然而每当我想起临终时身上将剩何物，我便觉得格外恐惧。一旦付诸火炬，想必连一截残骨也断难剩下。死去的祖母常说，“心情抑郁的人只能做抑郁的梦，要是更加抑郁，连梦都不做的。”——《且听风吟》 “不存在十全十美的文章，如同不存在彻头彻尾的绝望。”或者说 “不存在十全十美的人物，如同不存在彻头彻尾的绝望。——《且听风吟》 《了不起的盖茨比》 “每当你要批评别人，要记住，世上不是每个人都有你这么好的条件。” “在大都市迷人的黄昏时刻，我有时感到一种难以排遣的寂寞，同时也觉得别人有同感——那些在橱窗面前踯躅的穷困的青年小职员，等到了时候独个儿上小饭馆去吃一顿晚饭——黄昏中的青年小职员，虚度着夜晚和生活中最令人陶醉的时光。” “盖茨比深切地体会到财富怎样禁甸和保存青春与神秘，体会到一套套衣装怎样使人保持清析，体会到黛西像白银一样皎皎发光，安然高踞于穷苦人激烈的生存斗争之上。” “不是因为时间令我遗忘当时的心情，而是在时间中希望又失望又希望，循环往复，终于证明快乐的确不用发觉，是正觉，“原来”两个字，提醒了我，所谓感觉，是随心境而生灭，并无绝对的真相或事实的概念. 《原来你并非不快乐》 “钱可以帮你，贪心的话，钱便可以主宰你。够好心钱更可以救助天地，但愿别为钱而忧，亦别独独为钱而喜，足够，便足以忘记。 “假如买不起一个高清电视弥补失恋之苦，不如买本《庄子》看一下更能放下前度的阴影，假如去不其欧洲奖励自己半年无休的辛劳，去一次郊区观鸟，更会发现钱除了买到享受，最重要是买到将来选择的自由” 旅游，不是太早，就是太迟。 不是因为时间令我遗忘当时的心情，而是在时间中希望又失望又希望，循环往复，终于证明快乐的确不用发觉，是正觉，“原来”两个字，提醒了我，所谓感觉，是随心境而生灭，并无绝对的真相或事实的概念 《登天的感觉，我在哈佛大学做心理咨询》 《鲁迅经典全集》 其实人禽之辨，本不必这样严。在动物界，虽然并不如古人所幻想的那样舒适自由，可是噜苏做作的事总比人间少。它们适性任情，对就对，错就错，不说一句分辩话。虫蛆也许是不干净的，但它们并没有自命清高；鸷禽猛兽以较弱的动物为饵，不妨说是凶残的罢，但它们从来就没有竖过 “ 公理 ”“ 正义 ” 的旗子，使牺牲者直到被吃的时候为止，还是一味佩服赞叹它们。人呢，能直立了，自然是一大进步；能说话了，自然又是一大进步；能写字作文了，自然又是一大进步。然而也就堕落，因为那时也开始了说空话。说空话尚无不可，甚至于连自己也不知道说着违心之论，则对于只能嗥叫的动物，实在免不得 “ 颜厚有忸怩 ”。假使真有一位一视同仁的造物主，高高在上，那么，对于人类的这些小聪明，也许倒以为多事，正如我们在万生园里，看见猴子翻筋斗，母象请安，虽然往往破颜一笑，但同时也觉得不舒服，甚至于感到悲哀，以为这些多余的聪明，倒不如没有的好罢。然而，既经为人，便也只好“ 党同伐异 ” ，学着人们的说话，随俗来谈一谈，辩一辩了。《朝花夕拾》 《独自上场》 你不可能从现在这个点上看到将来；只有回头看时，才会发现它们之间的关系。所以你必须相信，那些点点滴滴，会在你未来的生命里，以某种方式串联起来。”——李娜《独自上场》 愤怒比悲伤更有力，愤怒不会让一个人垮掉。——李娜《独自上场》 杨绛《我两的故事》 见她之前，从未想结婚；娶她之后，从未后悔娶她。 《文化苦旅》 《沉默的大多数》 此人之肉，彼人之毒；一件对此人有利的事，难免会伤害另一个人。真正的君子知道，自己的见解受所处环境左右，未必是公平的；——《沉默的大多数》 话语有一个神圣的使命，就是想要证明说话者本身与众不同，是芸芸众生中的娇娇者。假设这些都是实情，我们不妨把这些保藏在内心处不说，“闷兹蜜”。——《沉默的大多数》原来王小波先生也是”闷骚”型。其实这个世界不缺沉默。 《突然就走到西藏》 亲友或爱人之间争吵，有时候争得面红耳赤不如一个拥抱来得温暖直接。——《突然就走到了西藏 纯文字》 感谢那个残酷对你的人——《突然就走到了西藏 纯文字》，否则你会沉浸于梦境中，梦总有会醒的时候。 自卑常常以骄傲的面目出现。人的自傲与自卑是一对孪生兄弟，有时候过于自傲反倒说明你是自卑的。——《突然就走到了西藏 纯文字》 《生命不能承受之轻》 人的生命只有一次，我们既不能把它与我们以前的生活相此较，也无法使其完美之后再来度过。——《生命中不能承受之轻》 也许最沉重的负担同时也是一种生活最为充实的象征，负担越沉，我们的生活也就越贴近大地，越趋近真切和实在。——《生命中不能承受之轻》 《张爱玲文集》 如果你不调戏女人，她说你不是一个男人，如果你调戏她，她说你不是一个上等人。——《张爱玲文集(全5卷)》 用别人的钱，即使是父母的遗产，也不如用自己赚来的钱来得自由自在，良心上痛快。可是用丈夫的钱，如果爱他的话，那却是一种快乐，愿意想自己是吃他的饭，穿他的衣服。那是女人的传统的权利，即使女人现在有了职业，还是舍不得放弃的。——《张爱玲文集(全5卷)》 王朔《过把瘾就死》 “就像童话中两个贪心人挖地下的财宝，结果挖出一个人的骸骨，虽然迅速埋上了，甚至在上面种了树，栽了花，但都清楚地知道底下埋的是什么。看见树，看见花，想的却是地下的那具骸骨。” ——王朔《过把瘾就死》 路遥《人生》 我们当今的现实生活中有马占胜和高明楼这样的人。他们为了个人的利益。有时毫不顾忌地给这些徘徊在生活十字路口的人当头一棒，使他们对生活更加悲观；有时，还是出于个人目的，他们又一下子把这些人推到生活的顺风船上。——《人生》看到这里，生活不过如此了 劳动啊，它是艰苦的，但也有它本身的欢乐！《人生》 生活的变化真如同春夏秋冬，一寒一暑，差别甚远！三年前，这样的夜晚，他此刻或者在明亮温馨的教室里读书；或者在电影院散场的人群里，和同学们说说笑笑走向学校. 现在，他却拉着茅粪桶，东避西躲，鬼鬼祟祟，像一个夜游鬼一样。——《人生》 现在他一屁股坐下来，浑身骨头似乎全掉了，两只手像抓着两把葛针，疼得万箭钻心！ 不过，他也感到了一种无法言语的愉快。他让所有的庄稼人看见：他们衡量一个优秀庄稼人最重在的品质――吃苦精神，他高加林也具备。从性格上说，他的确是个强者；而这个优点在某些情况下又使他犯错误。——《人生》 爱情就像一条河，我们都是瞎子，谁不是摸着石头过河。 柴静《看见》 “但痛苦也是一种清洗，是对牺牲的人的告慰。”——《看见》 当一个人关心别人的时候，才会忘记自己。——《看见》 我知道自己身上已经开始散发失败者的味儿，再这样下去谁都会闻出来了–在动物界，你知道，只要你散发出那样的气味，几乎就意味着没有指望了，很快，很快，就会被盯上，毫不留情地被扑倒在地，同伴会四奔逃散，甚至顾不上看你一眼。——《看见》 “人们声称的最美好的岁月其实都是最痛苦的，只是事后回忆起来的时候才那么幸福。”——《看见》 《牧羊少年的奇幻之旅》 “我就像大多数人一样－－只肯相信自己要相信的，不肯去看清事情究竟真正是怎么一回事。”——《牧羊少年奇幻之旅》 幸福的秘密就是去欣赏世界上所有的奇妙景观，但不要忘了汤匙里的油。’——《牧羊少年奇幻之旅》 《雪国》 “山头上罩满了月色，这是原野尽头惟一的景色，月色虽以淡淡消去，但余韵无穷，不禁使人产生冬夜寥峭的感觉。”“盈盈皓月，深深地射了进来，照亮得连驹子的耳朵的凹凸线条都清晰地浮现出来。”——《雪国》 诗句不都是句句真言吗？像一道彩虹悬挂在虚空，瞬间出现五彩缤纷像。当白日空中辉照时，虚无又明亮起来了。然而虚空本来无光，也是无色可装点的。我也在这如虚空般的心上，着上种种情趣盎然的色彩，但没有留下一丝踪迹——《雪国》现实的事物遮住了眼睛，充斥了双耳，而诗歌呢，就如虚空中的彩虹一样。 以前觉得“感冒一直纠缠不休，鼻子堵塞”。当一到雪国这清冷的环境中，“这时一下子通了气，穿到头顶心。”——《雪国》 弗洛伊德说：“女人越是轻浮放荡，就越使男人爱得发狂。同这种女人相爱，往往使他们魂销骨酥，不能自拔。……但一旦爱上之后，又要求她们对自己忠实。”《雪国》序 《目送》 我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站立在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追。——《目送》 只有一个人能听的音乐，是一扇紧闭的门。——《目送》 一件事情的毕业，永远是另一件事情的开启。——《目送》 《乡关何处》 我们不是我们污脏的外表，我们的心中一直盛开着一朵圣洁的向日葵。——《乡关何处》 命运未卜，何敢触碰爱情这种高贵的话题。即便心中藏有一个重洋，流出来也只是两颗泪珠。——《乡关何处》 最美的生活是善良、平等和文明，最好的工作是为未来做几件切实有益的事情，最甜的笑由于淡淡的幽默。人们不以权势扰乱平静无辜的心灵的时代，才是人性真正解放的时代。——《乡关何处》 一个人滥情是罪过，但一个人独身也同样难容于大众。一个人因为穷或残障而不能成婚，已多蒙歧视，如果他健康且尚可谋生而不婚，则难逃物议。——《乡关何处》 雪夜访戴，兴至而往，兴尽而归，何必见戴。——《乡关何处》 当“访旧半为鬼”时，当“故人日以稀”时，当在暮烟的幻象中遥见你曾朝夕与共甚或唇齿相依的大队面容时，你何曾有一丝幸存者的窃喜。就像此夜，当我枯坐于天涯客馆，燃一炬烟，吞吐几十年的往事时，我恍若一个同谋共犯——他们去了，我却苟活于斯——我怎堪独自直面这残酷的余生。——《乡关何处》 死亡，在许多时候，真是一件近乎日常的琐事。你买菜的路上，邂逅车轮下的一摊血；你拎着一堆肉食回来，看见邻居的一张讣告——在你行经的地方，人们竞相奔赴道路的尽头。你才发现，生命竟然确实薄如蝉翼。——《乡关何处》 可是好人却无好命，这几乎已经是这个世界的潜规则。这些好人来到这个世界，就是来承担磨难的；他们像一粒糖抛进大海，永远无法改变那深重的苦涩，也许只有经过的鱼才会知道那一丝稀有的甜蜜。——《乡关何处》 即使在此过程中已经深知这一结局的无法回避，但一个活生生的人真正在你手里呼出最后一口气时，你依然难以接受——你在那一刻无法不痛感人的弱小和不堪一击。我们有谁能与死神相争呢？——《乡关何处》 巴金《家》 顺受的，毫不抱怨，毫不诉苦的。像大海一样，它接受了一切，吞下了一切，可是它连一点吼声也没有。——《家》鸣凤的对待不公的表情 有人说过，路本没有，因为走的人多了，便成了一条路。又有人说路是有的，正因为有了路才有许多人走。谁是谁非，我不想判断。我还年轻，我还要活下去，我还要征服生活。我知道生活的激流是不会停止的，且看它把我载到什么地方去！——《家》 黑暗到了尽头，黎明就出现了。——《家》 几年前我流着眼泪读完托尔斯泰的小说《复活》，曾经在扉页上写了一句话：“生活本身就是一个悲剧。” 事实并不是这样。生活并不是悲剧。它是一场“搏斗”。我们生活来做什么？或者说我们为什么要有这生命？罗曼罗兰的回答是“为的是来征服它”。《家》巴金 《傲慢与偏见》 大凡一个人爱上一个人，都是因为先有了感激之心，器重之意。《傲慢与偏见》 虚荣与骄傲是截然不同的两件事，尽管字面上常常当作同义词用，一个人可以骄傲而不虚荣。骄傲多半不外乎我们对我们自己的估价，虚荣却牵涉到我们希望别人对我们的看法。——《傲慢与偏见》 《潜规则》 合法伤害权是很值钱的。有了这种权力，没有钱可以有钱，没有敛钱的规矩可以创造出规矩。用古汉语一个简洁贴切的词来表达，这叫势所必至。势之所至，潜规则生焉。即使这规则不合法，也可以转弯抹角将它装扮起来–广大群众爱护人民警察，凑点钱表达他们的感激之情，这难道有什么不对吗？——《潜规则》 合法地祸害别人的能力，乃是官吏们的看家本领。这是一门真正的艺术，种种资源和财富正要据此分肥并重新调整。——《潜规则》","categories":[{"name":"读书","slug":"读书","permalink":"http://superkk.top/categories/读书/"}],"tags":[]},{"title":"让StringGrid控件显示下拉菜单","slug":"让StringGrid控件显示下拉菜单","date":"2013-12-17T10:13:51.000Z","updated":"2019-08-29T09:27:58.382Z","comments":true,"path":"2013/12/17/让StringGrid控件显示下拉菜单/","link":"","permalink":"http://superkk.top/2013/12/17/让StringGrid控件显示下拉菜单/","excerpt":"","text":"效果预览 关键代码void __fastcall TForm1::FormCreate(TObject *Sender) { StringGrid1-&gt;ColCount = 4; StringGrid1-&gt;RowCount = 6; StringGrid1-&gt;DefaultRowHeight = ComboBox1-&gt;Height; StringGrid1-&gt;RowHeights[0] = 18; StringGrid1-&gt;ColWidths[2] = 80; StringGrid1-&gt;Cells[0][0] = &quot;FirstName&quot;; StringGrid1-&gt;Cells[1][0] = &quot;LastName&quot;; StringGrid1-&gt;Cells[2][0] = &quot;SBVLEdit LV1&quot;; StringGrid1-&gt;Cells[3][0] = &quot;Action&quot;; ComboBox1-&gt;Text = &quot;&quot;; ComboBox1-&gt;Items-&gt;Add(&quot;Teen&quot;); ComboBox1-&gt;Items-&gt;Add(&quot;Adult&quot;); ComboBox1-&gt;Items-&gt;Add(&quot;Senior&quot;); ComboBox1-&gt;Visible = False; } void __fastcall TForm1::ComboBox1Change(TObject *Sender) { StringGrid1-&gt;Cells[StringGrid1-&gt;Col][StringGrid1-&gt;Row] = ComboBox1-&gt;Items-&gt;Strings[ComboBox1-&gt;ItemIndex]; } void __fastcall TForm1::StringGrid1DblClick(TObject *Sender) //双击事件 { TRect r; if(StringGrid1-&gt;Col == 2) { int ACol = StringGrid1-&gt;Col; int ARow = StringGrid1-&gt;Row; r = StringGrid1-&gt;CellRect(ACol,ARow); ComboBox1-&gt;Top = StringGrid1-&gt;Top + r.Top + StringGrid1-&gt;GridLineWidth + 1; ComboBox1-&gt;Left = StringGrid1-&gt;Left + r.Left + StringGrid1-&gt;GridLineWidth +1; ComboBox1-&gt;Width = r.Right - r.Left; ComboBox1-&gt;ItemIndex = ComboBox1-&gt;Items-&gt;IndexOf(StringGrid1-&gt;Cells[ACol][ARow]); ComboBox1-&gt;Visible = true; } else { ComboBox1-&gt;Visible = false; } } 参考http://ymg97526.blog.163.com/blog/static/17365816020135264552765/","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://superkk.top/categories/C-C/"}],"tags":[{"name":"Boardland C++","slug":"Boardland-C","permalink":"http://superkk.top/tags/Boardland-C/"}]},{"title":"《C语言深度剖析》读书笔记","slug":"《C语言深度剖析》读书笔记","date":"2013-07-15T06:19:07.000Z","updated":"2019-08-29T09:07:04.736Z","comments":true,"path":"2013/07/15/《C语言深度剖析》读书笔记/","link":"","permalink":"http://superkk.top/2013/07/15/《C语言深度剖析》读书笔记/","excerpt":"","text":"registerregister 变量必须是一个单个的值,并且其长度应小 于或等于整型的长度。 而且 register 变量可能不存放在内存中,所以不能用取址运算符“&amp;” 来获取 register 变量的地址。 float 变量与“零值”进行比较//EPSINON 为定义好的 精度。 if((fTestVal &gt;= -EPSINON) &amp;&amp; (fTestVal &lt;= EPSINON)); volatilevolatile 关键字告诉编译器 i 是随时可能发生变化的,每次使用它的时候必须从内存中取出 i 的值,因而编译器生成的汇编代码会重新从 i 的地址处读取数据放在 k 中。 这样看来,如果 i 是一个寄存器变量或者表示一个端口数据或者是多个线程的共享数 据,就容易出错,所以说 volatile 可以保证对特殊地址的稳定访问。 externextern 可以置于变量或者函数前,以 标示变量或者函数的定义在别的文件中,下面的代码用到的这些变量或函数是外来的,不 是本文件定义的,提示编译器遇到此变量和函数时在其他模块中寻找其定义 空结构体占用空间大小struct student { }stu; sizeof(stu)的值是多少呢?Visual C++ 6.0上为 1编译器认为你构造一个结构体数据类型是用来打包一些数据成员的,而最小的数据成员需要 1 个 byte,编译器为每个结构体类型数据至少预留 1 个 byte 的空间。所以,空结构体的大小就定位 1 个 byte。 struct 与 class 的区别struct 的成 员默认情况下属性是 public 的,而 class 成员却是 private 的。 union 关键字union 维护足够的空间来置放多个数据成员中的“一种”,而不是为每一个数据成员配置 空间,在 union 中所有的数据成员共用一个空间,同一时间只能储存其中一个数据成员,所 有的数据成员具有相同的起始地址。 union StateMachine { char character; int number; char *str; double exp; }; 一个 union 只配置一个足够大的空间以来容纳最大长度的数据成员,以上例而言,最大 长度是 double 型态,所以 StateMachine 的空间大小就是 double 数据类型的大小。另外，注意大小端模式对 union 类型数据存储的空间有影响 typedef 关键字typedef struct student { //code }Stu_st,*Stu_pst; A),struct student stu1;和 Stu_st stu1;没有区别。 B),struct student *stu2;和 Stu_pst stu2;和 Stu_st *stu2;没有区别。 这个地方很多初学者迷惑,B)的两个定义为什么相等呢?其实很好 const const int *p; //p指向的对象不可变（*p不可变） int const *p; //p指向的对象不可变（*p不可变） int *const p; //p不可变，p指向的对象可变 const int *const p; //前一个 const 修饰*p,后一个 const 修饰 p,指针 p 和 p 指向的对象 都不可变 void Fun(const int i); //不希望这个参数值被函数体内意外改变。 const int Fun (void); //返回值不可被改变。 运算符SQR(8) 输出的是:The square of 8 is 64. #预算符 ##运算符可以用于宏函数的替换部分。这个运算符把两个语言符号组 合成单个语言符号。 #define XNAME(n) x ## n 如果这样使用宏: XNAME(8) 则会被展开成这样:x8 指针和数组A) int* p1[10]; // 指针数组，数组的每个值都是指针 “[]”的优先级比“”要高。p1 先与“[]”结合,构成一个数组的定义,数组名为 p1,int 修饰的是数组的内容,即数组的每个元素。那现在我们清楚,这是一个数组,其包含 10 个 指向 int 类型数据的指针,即指针数组。B) int (*p2)[10]; //数组指针，可以理解为 int (*)[10] p2，实际上就是二维数组p[][10]; “()”的优先级比 “[]”高,“*”号和 p2 构成一个指针的定义，指针变量名为 p2,int 修饰的是数组的内容, 即数组的每个元素。数组在这里并没有名字,是个匿名数组。那现在我们清楚 p2 是一个指 针,它指向一个包含 10 个 int 类型数据的数组,即数组指针。 函数指针A) char * fun3(char * p1,char * p2); //fun3是函数名,p1,p2是参数,其类型为char*型,函数的返回值为char * 类型。 B) char * *fun2(char * p1,char * p2); //与 C)表达式相比,唯一不同的就是函数的返回值类型为 char** C) char * (*fun1)(char * p1,char * p2); //fun1 不是什么函数名,而是一个 指针变量,它指向一个函数。这个函数有两个指针类型的参数,函数的返回值也是一个指 针。我们把这个表达式改写一下:char * (*)(char * p1,char * p2) fun1; 这样子是不 是好看一些呢?只可惜编译器不这么想。 函数指针数组char * (*pf)(char * p) //函数指针 char * (*pf[3])(char * p); //这是定义一个函数指针数组。它是一个数组,数组名为 pf,数组内存储了 3 个指向函数的 指针。pf是数组名 函数指针数组的指针char * (*(*pf)[3])(char * p); //pf是指针，这个指针指向一个包含了 3 个元素的数组;这个数字里 面存的是指向函数的指针;这些指针指向一些返回值类型为指向字符的指针、参数为一个 指向字符的指针的函数。 实战练习 参考答案：a) int a;b) int a;c) int **a;d) int a[10];e) int a[10];f) int (a)[10];g) int (func)(int a);h) int (*func[10])(int a);","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://superkk.top/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://superkk.top/tags/C-C/"}]}]}
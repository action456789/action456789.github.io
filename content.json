{"meta":{"title":"SuperKK","subtitle":"action456789","description":null,"author":"SuperKK","url":"http://liumengxia.shop"},"pages":[],"posts":[{"title":"iOS SDK 开发","slug":"iOS-SDK-开发","date":"2018-05-09T07:07:25.000Z","updated":"2018-05-09T07:08:26.614Z","comments":true,"path":"2018/05/09/iOS-SDK-开发/","link":"","permalink":"http://liumengxia.shop/2018/05/09/iOS-SDK-开发/","excerpt":"","text":"一、Framework与.a基础此处等下一期 二、工程嵌套联调静态库1、新建一个主工程 2、新建一个Library工程 3、将静态库工程拖到主工程文件夹下 如果你要拖到其他目录，就要改Library Search Paths 4、将Library工程下.a文件拖入主工程的Link Binary With Libraries如果有必要（运行时崩溃），将静态库需要加入 Embedded Binaries 中 5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程如下图给主工程添加对子工程的依赖，这样每次编译主工程的时候也会编译子工程。 三、在静态库中使用图片以及 xib 等资源文件1、添加 Bundle Target 因为iOS框架中没有bundle，要选中OS X框架找到bundle，如下图 2、将资源文件加入 bundle 中将工程中的资源文件都加入到刚刚建的bundle中，如xib、图片。点+号或直接拖都行。 3、iOS Deployment Target改为你支持的最低版本 4、设置base SDK 为latest iOS 5、编译 Bundle 6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程 7、加载 Bundle 里的资源文件7.1、加载图片使用运行时替换 [UIImage imageNamed:]方法，减少修改代码的工作量。相关代码在以下几个类中12345678// 在AppDelegate中执行以下代码即可swizzle 所有 [UIImage imageNamed:]#import &quot;UIImage+Swizzle.h&quot;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [UIImage kk_autoLoadImageInBundle]; return YES;&#125; UIImage+Swizzle.m 123456789101112131415161718// // 修改所有的 [UIImage imageNamed:]的实现，改为先从同一项目中的 .bundle 文件中加载，没有再使用系统默认实现加载+ (void)kk_autoLoadImageInBundle &#123; SEL original = @selector(imageNamed:); SEL new = @selector(hook_kk_imageWithName:); [self kk_swizzleClassMethod:original with:new];&#125;// 1. 从 .bundle 中加载图片// 2. 按照默认的方法加载图片+ (instancetype)hook_kk_imageWithName:(NSString *)imageName &#123; UIImage *image = [NSBundle kk_imageInBundle:kk_BundleName imageName:imageName]; if (!image) &#123; image = [self hook_kk_imageWithName:imageName]; &#125; return image;&#125; NSObject+Swizzle.m 1234567891011121314151617181920212223242526272829#import &quot;NSObject+Swizzle.h&quot;#import &lt;objc/objc.h&gt;#import &lt;objc/runtime.h&gt;@implementation NSObject (Swizzle)+ (BOOL)kk_swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel &#123; Class class = object_getClass(self); Method originalMethod = class_getInstanceMethod(class, originalSel); Method newMethod = class_getInstanceMethod(class, newSel); if (!originalMethod || !newMethod) return NO; method_exchangeImplementations(originalMethod, newMethod); return YES;&#125;+ (BOOL)kk_swizzleClassMethod:(SEL)originalSel with:(SEL)newSel &#123; Class class = object_getClass(self); Method originalMethod = class_getClassMethod(class, originalSel); Method newMethod = class_getClassMethod(class, newSel); if (!originalMethod || !newMethod) return NO; method_exchangeImplementations(originalMethod, newMethod); return YES;&#125;@end 7.2、加载 xib7.2.1 加载xib对应的UIViewController需要重写xib对应控制器的 init 方法，否则可能出现找不到xib文件导致crash参考bundle打包xib文件 12345678910- (instancetype)init &#123; NSBundle *bundle = [NSBundle kk_bundleWithName:kBundleTargetName]; self = [super initWithNibName:@&quot;CalculatePriceViewController&quot; bundle:bundle]; return self;&#125; 代码参见：github](https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)) 7.2.1 加载xib对应的UIVIew需要重写xib对应View的 init 方法，，否则可能出现找不到xib文件导致crash123456789101112@implementation OfflineView//重写要加载的view的init方法- (instancetype)init &#123; if (self = [super init]) &#123; NSBundle *bundle = [NSBundle kk_bundleWithName:kk_BundleName]; self = [[bundle loadNibNamed:@&quot;OfflineView&quot; owner:self options:nil] lastObject]; &#125; return self;&#125;@end 7.3、加载 Localizable.strings第一步：在Bundle中新建国际化文件 第二步：添加语言，并将之前的国际化文件中的代码复制过来 第三步：使用 NSBundle+Resource 如下方法12+ (NSString *)mj_localizedStringForKey:(NSString *)key;+ (NSString *)mj_localizedStringForKey:(NSString *)key value:(NSString *)value; 然后使用如下宏定义1234// 加载 Bundle 中的国际化语句#undef NSLocalizedString#define NSLocalizedString(key, comment) \\[NSBundle mj_localizedStringForKey:(key)] 然后就可以自动的加载Bundle中的字符串了 四、将整个App打包为Framework需要注意的地方 整个项目都要解除 AppDelegate 的依赖，AppDelegate不能打入Framework中 图片和xib文件需要按照 三 中的处理 可以使用 runtime 动态加载图片和xib文件，减少工作量 注意点：bundle中的国际化文件需要重新新建，添加语言，然后将之前App中的内容复制过来，直接拖进去是无效的 实际操作中存在的问题 图片同时存在@2x和@3x后缀导致加载的图片为nil的问题解决办法为只要@2x的图片 五、使用 appledoc 生成文档官网 安装brew install appledoc 查看版本appledoc --version 查看帮助appledoc --help 生成文档1appledoc --output ./doc --project-name &quot;D103Framework&quot; --project-company &quot;RICISUNG&quot; --company-id &quot;RICISUNG&quot; . ”.“ 和前面的符号一定要加 空格 否则就会报错。 参考iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调](http://www.cnblogs.com/zhanglinfeng/p/5494762.html))iOS framework静态库中使用xib和图片资源详解","categories":[],"tags":[]},{"title":"iOS11新特性","slug":"iOS11新特性","date":"2017-12-22T15:02:12.000Z","updated":"2018-05-09T07:13:31.254Z","comments":true,"path":"2017/12/22/iOS11新特性/","link":"","permalink":"http://liumengxia.shop/2017/12/22/iOS11新特性/","excerpt":"","text":"[TOC] iOS11 大标题12345// 导航控制器的`prefersLargeTitles`为大标题的总开关navigationController?.navigationBar.prefersLargeTitles = true// 各个控制器可以自己通过 largeTitleDisplayMode，如果导航控制器的 `prefersLargeTitles` 为 NO，largeTitleDisplayMode 将没有效果navigationItem.largeTitleDisplayMode = .never iOS11 导航栏搜索框1234567891011121314151617let searchResultsVC = SearchResultTabelViewVC(nibName: nil, bundle: nil)lazy var searchController: UISearchController = &#123;let vc = UISearchController(searchResultsController: searchResultsVC)vc.searchResultsUpdater = self.searchResultsVCvc.hidesNavigationBarDuringPresentation = truevc.dimsBackgroundDuringPresentation = truevc.searchBar.placeholder = &quot;搜索设备&quot;vc.searchBar.enablesReturnKeyAutomatically = falsevc.searchBar.sizeToFit()return vc&#125;()navigationItem.searchController = searchControllernavigationItem.hidesSearchBarWhenScrolling = false iOS11 Safe Area Insets1additionalSafeAreaInsets = UIEdgeInsets(top: 100, left: 0, bottom: 100, right: 100) UITableView separatorInsetReference123456tableView.estimatedRowHeight = 0tableView.estimatedSectionHeaderHeight = 0tableView.estimatedSectionFooterHeight = 0tableView.separatorInsetReference = .fromAutomaticInsetstableView.separatorInset.left = 60 UITableViewCell 左划、右划123456789101112131415161718192021222324252627// iOS11 UITableViewCell 左划override func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? &#123;let action = UIContextualAction(style: .normal, title: &quot;收藏&quot;) &#123; (action, view, completionHandler) in// 执行收藏操作// ...completionHandler(true)&#125;action.image = imageLiteral(resourceName: &quot;favorite&quot;)action.backgroundColor = UIColor.redlet configuration = UISwipeActionsConfiguration(actions: [action])return configuration&#125;// iOS11 UITableViewCell 右划override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? &#123;let action = UIContextualAction(style: .destructive, title: &quot;删除&quot;) &#123; (action, view, completionHandler) in// remove item// ...completionHandler(true)&#125;let configuration = UISwipeActionsConfiguration(actions: [action])return configuration&#125; 代码见https://github.com/action456789/iOS11Demo","categories":[],"tags":[]},{"title":"Mac安装MQTT服务器","slug":"Mac安装MQTT服务器","date":"2017-03-09T07:08:59.000Z","updated":"2018-05-09T07:37:03.965Z","comments":true,"path":"2017/03/09/Mac安装MQTT服务器/","link":"","permalink":"http://liumengxia.shop/2017/03/09/Mac安装MQTT服务器/","excerpt":"emqttd windows版安装具体以官方文档为主 下载http://emqtt.io/docs/v2/install.html#installing-on-windows 进入下载后的bin目录下cd C:\\Users\\kk\\Desktop\\emqttd\\bin\\然后执行emqttd console 进入Web管理控制台(Dashboard)控制台地址: http://127.0.0.1:18083默认用户: admin，密码：public","text":"emqttd windows版安装具体以官方文档为主 下载http://emqtt.io/docs/v2/install.html#installing-on-windows 进入下载后的bin目录下cd C:\\Users\\kk\\Desktop\\emqttd\\bin\\然后执行emqttd console 进入Web管理控制台(Dashboard)控制台地址: http://127.0.0.1:18083默认用户: admin，密码：public 或者使用 mosquitto 安装brew install mosquitto 配置服务器进入目录/usr/local/Cellar/mosquitto 进入响应版本下目录，我这里是1.4.11_2找到/etc/mosquitto/mosquitto.conf文件，修改mosquitto.conf可以对服务器进行配置 启动服务器进入sbin目录：/usr/local/Cellar/mosquitto/1.4.11_2/sbin然后执行：./mosquitto -c /usr/local/Cellar/mosquitto/1.4.11_2/etc/mosquitto/mosquitto.conf -d 参考：http://blog.csdn.net/pz0605/article/details/51970568","categories":[],"tags":[]},{"title":"Autolayout高级","slug":"Autolayout高级","date":"2016-11-09T12:23:21.000Z","updated":"2018-05-09T07:12:24.519Z","comments":true,"path":"2016/11/09/Autolayout高级/","link":"","permalink":"http://liumengxia.shop/2016/11/09/Autolayout高级/","excerpt":"","text":"[TOC] intrinsicContentSizeIntrinsic Content Size：固有大小。意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。 比如：大家都知道在使用 AutoLayout 的时候，UILabel 就不用指定尺寸大小，只需指定位置即可，就是因为，只要确定了文字内容，字体等信息，它自己就能计算出大小来。 UILabel，UIImageView，UIButton 等组件及某些包含它们的系统组件都有 Intrinsic Content Size 属性。 Content Hugging 约束（不想变大约束）如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要拉伸的时候拉伸。 Content Compression Resistance 约束（不想变小约束）如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要压缩的时候压缩。 例如： Top Layout GuidetopLayoutGuide属性表示不希望被透明的状态栏或导航栏遮挡的内容范围的最高位置。这个属性的值是它的length属性的值（topLayoutGuide.length） 这个值可能由当前的ViewController或这个ViewController所属的NavigationController或TabBarController决定，有如下情况： 一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。 包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义： 如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。 如果状态栏可见，topLayoutGuide表示状态栏的底部。 如果都不可见，表示ViewController的上边缘。 总之是屏幕上方任何遮挡内容的栏的最底部。 Safe Area*作用：取代topLayoutGuide和bottomLayoutGuide** safeArea是描述你的视图部分不被任何内容遮挡的方法。 改变布局的方法一、 setNeedsLayout与layoutIfNeeded更新Autolayout后，如何要立即刷新布局，还要依次调用以下两个方法 123456// 立即刷新布局（自己和subview的）self.view.setNeedsLayout()self.view.layoutIfNeeded() setNeedsLayout给当前 UIView 立一个 flag，以表示后续应该调用 layoutSubviews方法，以调整当前视图及其子视图的布局。 layoutIfNeeded如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews） 二、 layoutSubviews触发时机——Frame改变就会触发，具体如下 初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发 addSubview会触发layoutSubviews 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化 滚动一个UIScrollView会触发layoutSubviews 旋转Screen会触发父UIView上的layoutSubviews事件 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 何时重写 layoutSubviews 方法1当我们在某个类的内部调整子视图位置时，需要调用；如果你想要在外部设置subviews的位置，就不要重写。 三、sizeToFit调用sizeToFit的时候，系统会根据内容的帮我布局一个它认为最合适的大小。 我们一般在不方便手动布局的时候才调用sizeToFit方法。比如 navigationBar中对navigationItem的设置，（添加两个视图以上的控件到Item） toolBar中的对UIBarButtonItem的设置（一般我们还要添加弹簧控件） 上述两种场合就可以用sizeToFit这个方法，来让系统给我们做自动布局。（注意：如果就添加一个控件的话，我们直接设置fram也是可以的） 在tabBar中我们不能手动的添加的子控件，因为tabBar是根据控制器系统默认自动添加的tabBarItem。（猜想系统可能也会自动调用了这个方法） UILabel中添加文字，然后让调整label的大小来适应文字，我们也调用sizeToFit的方法。","categories":[],"tags":[]},{"title":"iOS调试内存泄露","slug":"iOS调试内存泄露","date":"2016-10-09T15:11:07.000Z","updated":"2018-05-09T07:11:30.298Z","comments":true,"path":"2016/10/09/iOS调试内存泄露/","link":"","permalink":"http://liumengxia.shop/2016/10/09/iOS调试内存泄露/","excerpt":"","text":"[TOC] Xcode8使用Memory Graph 第一步：真机下运行APP后，点击 第二步：查看issue面板，注意选择右边Runtime 第三步：查看可能出现的内存泄露比如上图的 1 instance of __NSMallocBlock_leaked，点击后出现下图原因在于如下代码 12345678910group.didSelectedRowBlock = &#123; [unowned self, group] row inguard let indexPaths = group.selectedIndexPaths else &#123;return&#125;if indexPaths.count &gt; 0 &#123;self.shouldAdd = truelet row = (indexPaths.firstObject as! IndexPath).rowself.deviceAttri?.attrValue = String(row)&#125; else &#123;self.shouldAdd = false&#125;&#125; group的block中又使用了group，导致了循环引用，虽然使用了[unowned group]，事实证明并没有效果最后的解决办法是修改didSelectedRowBlock的接口，直接将selectedIndexPaths参数传入block参数中:123456789group.didSelectedRowBlock = &#123; [unowned self] indexPaths inguard let indexPaths = indexPaths else &#123;return&#125;if indexPaths.count &gt; 0 &#123;self.shouldAdd = trueself.deviceAttri?.attrValue = String(indexPaths.first!.row)&#125; else &#123;self.shouldAdd = false&#125;&#125; 第四步：在 debug 页面查看内存泄露情况有叹号说明需要注意可能存在内存泄露，可以看到 CoreFoundation中也可能存在内存泄露情况 使用Instruments的Leaks工具Time Profiler 查看多个线程里那些方法费时过多的方法 Call Tree上会默认按照费时的线程进行排序，单个线程中会也会按照对应的费时方法排序 Allocations 可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置 具体操作 在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation， 切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation， 这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。 Leak可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics&gt;Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。 其他调试方法勾选Address Sanitizer可以在运行时看到坏内存访问情况","categories":[],"tags":[]},{"title":"使用WireShark 调试真机网络","slug":"使用WireShark-调试真机网络","date":"2016-10-09T07:09:37.000Z","updated":"2018-05-09T07:10:02.378Z","comments":true,"path":"2016/10/09/使用WireShark-调试真机网络/","link":"","permalink":"http://liumengxia.shop/2016/10/09/使用WireShark-调试真机网络/","excerpt":"","text":"使用WireShark 调试真机网络需求：调试UIWebView加载缓慢问题 获取iPhone的UDID 2：根据获取的 UDID 创建一个虚拟的网卡rvictl -s &lt;UDID&gt; 通过 ifconfig 可以看到多了一个 rvi0接口通过 rvictl -l 命令可以列出所有挂接的虚拟接口 3: 在 Wireshark 首页选择 rvi0，使用默认的 Capture Options 即可开始对 iPhone 进行抓包。 其中 iPhone 手机连接 WiFi 动态获取的 IP 地址为 192.168.100.1。 黑色的内容表示遇到错误，需要重点关注关闭wifi，可以抓取移动网络数据包 -4 ： 使用rvictl -x命令删除虚拟接口, 使用 iPhone 的 UDID 作为参数。 WireShark 抓包技巧 第一步：找到请求网址的 IP 地址方法一：用ping命令得到对应的IP地址（可能不对，此时要用方法二） 方法二：使用DNS包来确定IP地址 注意手机上 DNS 解析的结果并不总是和电脑上的解析结果一致。这种情况下我们可以通过查看 DNS 数据包来确定DNS 是基于 UDP 的协议，不会有 TCP 重传 第二步：过滤 IP 地址 第三步：确定端口号 注意红框中的 SourcePort，这是客户端端口。我们知道 HTTP 支持并发请求，不同的并发请求肯定是占用不同的端口。所以在图中看到的上下两个数据包，并非一定是请求与响应的关系，他们可能属于两个不同的端口，彼此之间毫无关系，只是恰好在时间上最接近而已。 如果只想显示某个端口的数据，可以使用: ip.addr == 220.194.203.68 and tcp.dstport == 52914 如果只想看 HTTP 协议的 GET 请求与响应，可以使用 ip.addr == 220.194.203.68 and (http.request.method == “GET” || http.response.code == 200)来过滤。 如果想看丢包方面的数据，可以用 ip.addr == 220.194.203.68 and (tcp.analysis.fast_retransmission || tcp.analysis.retransmission) # 参考 http://ios.jobbole.com/93159/ http://blog.csdn.net/phunxm/article/details/38590561","categories":[],"tags":[]},{"title":"如何更新React Native","slug":"如何更新React-Native","date":"2016-04-12T07:32:04.000Z","updated":"2018-05-09T07:14:41.107Z","comments":true,"path":"2016/04/12/如何更新React-Native/","link":"","permalink":"http://liumengxia.shop/2016/04/12/如何更新React-Native/","excerpt":"","text":"最新的React Native已经更新到了0.33.0，如何更新自己已经搭建好的React Native开发环境呢，我按照以下步骤完成了更新，现记录下来，供有需要的人参考。 1.查看 react native 的最新版本。进入项目根目录，命令行执行npm info react-native 查看当前版本react-native --version 2.在项目目录下修改package.json文件，将下列代码中的 react-native 改为最新版本1234 &quot;dependencies&quot;: &#123; &quot;react&quot;: &quot;^0.14.8&quot;, &quot;react-native&quot;: &quot;^0.33.0&quot; &#125; ## 3. 命令行执行 `npm install --save react-native@0.33.0` 如果升级后出现类似于 `react-native@0.33.0 requires a peer of react@~15.3.1 but none was installed.` 执行 `npm install --save react@~15.3.1` ## 4. 运行程序 如果更新后执行react-native run-android不能正确运行，而是出现类似： Could not find com.facebook.react:react-native:0.23.0. 错误，或者在Android Studio中直接运行app时报错： Android Studio failed to resolve com.facebook.react:react-native:0.23.0 那么可以按照下列命令修复，首先在命令行中执行： `npm i` 执行完毕且不报错后，执行下面的命令，**注意，在执行命令之后，某些文件可能会产生冲突，请确保你的本地文件记录可以恢复**（在Android Studio中可以查看历史记录来恢复文件） `react-native upgrade` 执行上面的命令可能会提示你是否覆盖文件。在解决冲突之后重新运行App即可。 ## 如果还有问题，可以更新一下npm和Node.js再试 - 如何更新npm `npm install -g npm` - 如何更新Node.js `npm update node.js`","categories":[],"tags":[]},{"title":"Hexo GitHub博客搭建","slug":"Hexo-GitHub博客搭建","date":"2015-09-09T04:01:05.000Z","updated":"2018-05-09T07:06:11.014Z","comments":true,"path":"2015/09/09/Hexo-GitHub博客搭建/","link":"","permalink":"http://liumengxia.shop/2015/09/09/Hexo-GitHub博客搭建/","excerpt":"","text":"[TOC] 相关网站https://hexo.io/zh-cn/docs/ 准备工作 1、安装Node.jshttps://blog.csdn.net/u011619283/article/details/52368759 2、安装hexonpm install -g hexo-cli 本地站点搭建 1、初始化 Hexo进入自己创建的目录下 1hexo init 2、生成静态页面 1hexo generate 3、启动服务 1hexo server 4、查看效果打开浏览器，输入 http://localhost:4000/ 部署到github 1、创建仓库仓库名称固定格式如下：yourGitbubUsername.github.io注意yourGitbubUsername必须与你的github用户名相同，否则无法部署 2、安装github部署器 1npm install hexo-deployer-git –save 3、修改本地配置文件_config.yml 1234deploy:type: gitrepo: https://github.com/action456789/action456789.github.io.gitbranch: master 4、部署 12hexo generatehexo deploy 5、测试部署成功以后，在浏览器中输入 http://action456789.github.io 即可在线浏览自己的博客啦 绑定域名https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html（亲测可行） 修改主题后输入hexo s --debug进行测试1234hexo clean hexo generate hexo server (若是想本地预览和执行该命令预览) hexo deploy 博客的创建、修改与删除 1、创建新博客 1hexo new &quot;test_blog&quot; 删除博客删除博客文件后重新发布更新即可可能需要等几分钟才有效果 2、发布更新 123hexo cleanhexo generatehexo deploy 3、一些快捷键 1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new","categories":[],"tags":[]},{"title":"iOS中的时间","slug":"iOS中的时间","date":"2015-08-12T14:10:18.000Z","updated":"2018-05-09T07:10:45.770Z","comments":true,"path":"2015/08/12/iOS中的时间/","link":"","permalink":"http://liumengxia.shop/2015/08/12/iOS中的时间/","excerpt":"","text":"[TOC] 设备开机后的时间 CACurrentMediaTime() 设备从开机时起到现在的时间，设备重启会重置，单位为秒 [[NSProcessInfo processInfo] systemUptime] 与CACurrentMediaTime()等价 相对某个参考系的时间 Date().timeIntervalSince1970 1970年1月1日凌晨为参考系，到现在的时间，一般用于表示时间戳 Date().timeIntervalSinceReferenceDate 世界时间（UTC）2001年1月1日凌晨到现在经过的时间，单位为秒 CFAbsoluteTimeGetCurrent() 与Date().timeIntervalSinceReferenceDate等价 当用户手动改变了设备上的系统时间后，基于系统时钟的上述方法返回的结果也会一同改变 12345678print(CACurrentMediaTime()) // 设备刚重启print(Date().timeIntervalSince1970)print(Date().timeIntervalSinceReferenceDate)print(CFAbsoluteTimeGetCurrent()) 必要时，从服务器上获取时间如果App本身对获取的时间精度要求很高，还是直接通过网络从服务器获取时间戳会比较保险。 当网络可用时，直接从服务器获取； 网络不可用时，且设备没有被重启过，可以根据上一次获取服务器时间戳的时刻到此时的时间差来推算出正确的时间","categories":[],"tags":[]}]}
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>组件化模块间通信方案</title>
      <link href="/2018/08/22/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%9D%97%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/"/>
      <url>/2018/08/22/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%9D%97%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="组件化模块间通信方案"><a href="#组件化模块间通信方案" class="headerlink" title="组件化模块间通信方案"></a>组件化模块间通信方案</h1><h3 id="1、公共模块下沉"><a href="#1、公共模块下沉" class="headerlink" title="1、公共模块下沉"></a>1、公共模块下沉</h3><p>比如一些公共的基础UI组件应该互相独立，并且可以下沉为一个单独的层（比如通用业务层），供其他业务模块调用。</p><h3 id="2、OpenURL统跳协议"><a href="#2、OpenURL统跳协议" class="headerlink" title="2、OpenURL统跳协议"></a>2、<code>OpenURL统跳协议</code></h3><p>用一个url表示一个页面（Controller），或者UI控件，或者任意一个类的对象。</p><p>需要创建一个字典，key是url，value是相应的对象，这个字典由路由类去管理，典型的方案就是<code>MGJRouter</code>。</p><ul><li><p>优点：能解决组件间的依赖，并且方案成熟，有很多知名公司都在用这种方案（蘑菇街）；</p></li><li><p>缺点：编译阶段无法发现潜在bug，并且需要去注册&amp;维护路由表。</p></li></ul><pre><code class="Objective-C">// 注册路由[[Router sharedInstance] registerURL:@&quot;myapp://good/detail&quot; with:^UIViewController *{     return [GoodDetailViewController new];}];// 通过url获取UIViewController *vc = [[Router sharedInstance] openURL:@&quot;myapp://good/detail&quot;]</code></pre><p><a href="https://www.jianshu.com/p/2af9c063fd85" target="_blank" rel="noopener">参考</a></p><h3 id="3、Target-Action-反射"><a href="#3、Target-Action-反射" class="headerlink" title="3、Target-Action(反射)"></a>3、<code>Target-Action</code>(反射)</h3><p>例如从A中push到BViewController，需要在AViewController类文件中import进BViewController，这样二者就会产生耦合<br>现在利用Target-Action机制，我们不再直接import进BViewController，而是利用<code>NSClassFromString(&lt;#NSString * _Nonnull aClassName#&gt;)</code>这个api将BViewController这个字符串反射成BViewController这个类，这样我们就可以根据反射后的类进行实例化，再调用实例化对象的各种方法。</p><ul><li>优点：相比于URL Router，Target-Action也不需要注册和内存占用。</li><li>缺点：编译阶段无法发现潜在的BUG，而且，开发者所创建的类和定义的方法必须要遵守Target-Action的命名规则，调用者可能会因为硬编码问题导致调用失败。</li></ul><p>第三方框架有<code>CTMediator</code>和<code>BeeHive</code>在github</p><h3 id="4、NSNotificationCenter"><a href="#4、NSNotificationCenter" class="headerlink" title="4、NSNotificationCenter"></a>4、<code>NSNotificationCenter</code></h3><ul><li>优点：简单直接。</li><li>缺点：遍地都是通知，如果同事间协调不好会使得代码很混乱。</li></ul><h3 id="5、依赖注入：推荐方法"><a href="#5、依赖注入：推荐方法" class="headerlink" title="5、依赖注入：推荐方法"></a>5、<code>依赖注入</code>：推荐方法</h3><p>比如业务C将自己注入中间层，业务A去中间层去获取依赖的方法和变量。</p><ul><li>实现方式：通过中间层协议实现<br>业务B遵从这个协议，实现协议的代理方法，返回与中间层商量好的一个实际对象。<br>业务A通过中间层的某个方法（与B商量），获取遵从了这个协议的实例B，将其当做一个遵从了这个协议的透明对象来使用。</li><li><p>编程实现：具体运用了java的<code>面向接口编程`</code>Protocol - Class<code>，即iOS的</code>面向协议编程`</p></li><li><p>优点：<br>1、接口类似代码，可以非常灵活的定义函数和回调等。</p></li><li><p>缺点：<br>1、接口定义文件需要放在一个模块以供依赖，但是这个模块不会贡献代码，所以还好。<br>2、使用较为麻烦，每各调用都需要定义一个service，并实现, 对于一些具有普适性规律的场景不太合适，比如页面统一跳转</p></li><li><p>面向接口的调用会产生依赖<br><code>`</code>Objective-C<br>// A 模块</p></li><li>(void)getSomeDataFromB {<br>  B.getSomeData();<br>}</li></ul><p>// B 模块</p><ul><li>(void)getSomeData {<br>  return self.data;<br>}<br><code>`</code></li></ul><ul><li>示例<br><code>ServiceBProtocol</code><pre><code class="Swift">protocol ServiceBProtocol {  func getSomeDataFromServiceB() -&gt; String;}</code></pre></li></ul><p><code>MiddleLayer</code></p><pre><code class="Swift">class MiddleLayer: NSObject {    class func findServiceB() -&gt; ServiceBProtocol {        return ServiceB()    }}</code></pre><p><code>ServiceB</code></p><pre><code class="Swift">// 模块Bclass ServiceB: NSObject {    let serviceB_Data = &quot;ServiceB&quot;}extension ServiceB: ServiceBProtocol {    func getSomeDataFromServiceB() -&gt; String {        return self.serviceB_Data    }}</code></pre><p><code>ServiceA</code></p><pre><code class="Swift">// 模块Aclass ServiceA: NSObject {    func getDataFromB() {        print(MiddleLayer.findServiceB().getSomeDataFromServiceB())    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveCocoa冷热信号详解</title>
      <link href="/2018/07/30/ReactiveCocoa%E5%86%B7%E7%83%AD%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/07/30/ReactiveCocoa%E5%86%B7%E7%83%AD%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>函数响应式编程(Functional Reactive Programming:FRP)，ReactiveCocoa 版本 2.5</p><h1 id="冷热信号"><a href="#冷热信号" class="headerlink" title="冷热信号"></a>冷热信号</h1><ul><li><p>冷信号<br>只有当你订阅的时候，它才会发布消息，<br>一对一，当有不同的订阅者，消息是重新完整发送。</p></li><li><p>热信号<br>尽管你并没有订阅事件，但是它会时刻推送，类似“直播”，错过了就不再处理。<br>可以有多个订阅者，是一对多</p></li></ul><h1 id="RACSignal-与RACSubject-的区别"><a href="#RACSignal-与RACSubject-的区别" class="headerlink" title="RACSignal 与RACSubject 的区别"></a><code>RACSignal</code> 与<code>RACSubject</code> 的区别</h1><ul><li><code>RACSignal</code>是冷信号</li><li><code>RACSubject</code>是热信号</li></ul><p>如下图</p><ul><li><code>signal</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-cba016d495b9a1b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><code>subject</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5974af889c88a7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><code>replaySubject</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-282c50256b5bae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>Subject可以附加行为，例如<code>RACReplaySubject</code>具备为未来订阅者缓冲事件的能力。（这一点与冷信号类似，即使是在数据发送之后才订阅的，依然会收到全部消息）</p></blockquote><h1 id="冷信号示例：延时订阅，依然能收到所有信号数据"><a href="#冷信号示例：延时订阅，依然能收到所有信号数据" class="headerlink" title="冷信号示例：延时订阅，依然能收到所有信号数据"></a>冷信号示例：延时订阅，依然能收到所有信号数据</h1><pre><code>- (void)test1 {    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [subscriber sendNext:@1];        [subscriber sendNext:@2];        [subscriber sendNext:@3];        [subscriber sendCompleted];        return nil;    }];    NSLog(@&quot;Signal was created.&quot;);    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber1 recveive: %@&quot;, x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber2 recveive: %@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-419d5730a235a595.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="热信号示例：错过了订阅时机，就收不到信号数据，类似于直播"><a href="#热信号示例：错过了订阅时机，就收不到信号数据，类似于直播" class="headerlink" title="热信号示例：错过了订阅时机，就收不到信号数据，类似于直播"></a>热信号示例：错过了订阅时机，就收不到信号数据，类似于直播</h1><blockquote><p>冷信号会收到全部的数据，即使是在数据发送之后才订阅的</p></blockquote><pre><code>- (void)test2 {    RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{            [subscriber sendNext:@1];        }];        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{            [subscriber sendNext:@2];        }];        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{            [subscriber sendNext:@3];            [subscriber sendCompleted];        }];        return nil;    }] publish];    [connection connect];    NSLog(@&quot;Signal was created.&quot;);    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{        [connection.signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber1 recveive: %@&quot;, x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{        [connection.signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber2 recveive: %@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5e7083e9f1760611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="SideEffect示例：多次订阅导致信号block多次执行"><a href="#SideEffect示例：多次订阅导致信号block多次执行" class="headerlink" title="SideEffect示例：多次订阅导致信号block多次执行"></a>SideEffect示例：多次订阅导致信号block多次执行</h1><pre><code>- (void)test3 {    // 多次订阅会多次执行    RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];        }];        return nil;    }];    // 【请求数据次数 +1】    [requestSignal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1&quot;);    }];    // 【请求数据次数 +1】    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2&quot;);    }];    // 将信号转换为内容为2的信号    RACSignal *signal1 = [requestSignal flattenMap:^RACStream *(id value) {        return [RACSignal return:@&quot;2&quot;];    }];    // 将signal1信号所有错误信息转换为字符串@&quot;Error&quot;    [signal1 catchTo:[RACSignal return:@&quot;Error&quot;]];    // 在没有获取值之前以字符串@&quot;Loading...&quot;占位    [signal1 startWith:@&quot;Loading...&quot;];    // 将信号进行绑定    // 【请求数据次数 +1】    RAC(self.acountField, text) = signal1;    // 订阅多个信号的任何错误，并且弹出UIAlertView    // 【请求数据次数 +2】    [[RACSignal merge:@[requestSignal, signal1]] subscribeError:^(NSError *error) {        NSLog(@&quot;发生错误&quot;);    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-465cde44e32e9612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="解决方式一：使用-RACMulticastConnection把冷信号转化为热信号"><a href="#解决方式一：使用-RACMulticastConnection把冷信号转化为热信号" class="headerlink" title="解决方式一：使用 RACMulticastConnection把冷信号转化为热信号"></a>解决方式一：使用 <code>RACMulticastConnection</code>把冷信号转化为热信号</h2><pre><code>- (void)test4 {    RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];            [subscriber sendCompleted];        }];        return nil;    }];    RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]];//    RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]];    [connection connect];    [connection.signal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [connection.signal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [connection.signal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><h3 id="使用RACSubject时"><a href="#使用RACSubject时" class="headerlink" title="使用RACSubject时"></a>使用<code>RACSubject</code>时</h3><pre><code>RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]];</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-85b4314b53586f26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="使用RACReplaySubject时"><a href="#使用RACReplaySubject时" class="headerlink" title="使用RACReplaySubject时"></a>使用<code>RACReplaySubject</code>时</h3><pre><code>RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]];</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-4ae4c9e7dbfebe09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="解决方式二：使用-replayLazily把冷信号转化为热信号"><a href="#解决方式二：使用-replayLazily把冷信号转化为热信号" class="headerlink" title="解决方式二：使用 replayLazily把冷信号转化为热信号"></a>解决方式二：使用 <code>replayLazily</code>把冷信号转化为热信号</h2><pre><code>- (void)test5 {    RACSignal *requestSignal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];            [subscriber sendCompleted];        }];        return nil;    }] replayLazily]; // modify here!!    [requestSignal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [requestSignal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-437a9f7928924eaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="使用RACCommand把冷信号转化为热信号"><a href="#使用RACCommand把冷信号转化为热信号" class="headerlink" title="使用RACCommand把冷信号转化为热信号"></a>使用<code>RACCommand</code>把冷信号转化为热信号</h2><pre><code>- (void)test6 {    RACCommand *requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {        return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {            NSLog(@&quot;开始请求网络数据&quot;);            [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{                [subscriber sendNext:@&quot;1&quot;];                [subscriber sendCompleted];            }];            return nil;        }];    }];    RACSignal *requestSignal = [requestCommand execute:nil];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [requestSignal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-e1f4373d8b49a171.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>RACMulticastConnection</code>与<code>RACSubject</code>结合使用时是直播的热信号</p><p><code>RACCommand</code>、<code>replayLazily</code>、<code>RACReplaySubject</code>都是类似于冷信号的情况，不管何时订阅，都会收到所有数据</p><h1 id="ReactiveCocoa中潜在的内存泄漏与解决方案"><a href="#ReactiveCocoa中潜在的内存泄漏与解决方案" class="headerlink" title="ReactiveCocoa中潜在的内存泄漏与解决方案"></a>ReactiveCocoa中潜在的内存泄漏与解决方案</h1><ul><li><p><code>RACObserve</code>中潜在使用了self，要注意循环引用</p></li><li><p><code>RACSubject</code>中如果没有调用<code>sendCompleted</code>，调用map等操作将造成内存泄漏（循环引用）。RACSignal不会有这个问题</p></li></ul><p>代码参见<a href="http://fromwiz.com/share/s/3rEj7C20FAXK2jIwRi1uhc1v0WQKj83L7k142p7dil0ygtoZ" target="_blank" rel="noopener">https://github.com/action456789/ReactiveCocoaDemo</a></p><p>参考：<a href="http://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="noopener">http://tech.meituan.com/tag/ReactiveCocoa</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Rx &amp; RAC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UITableView的`beginUpdates`与`endUpdates`用法详解</title>
      <link href="/2018/06/05/UITableView%E7%9A%84%60beginUpdates%60%E4%B8%8E%60endUpdates%60%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/05/UITableView%E7%9A%84%60beginUpdates%60%E4%B8%8E%60endUpdates%60%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="UITaUITableView的beginUpdates和endUpdates"><a href="#UITaUITableView的beginUpdates和endUpdates" class="headerlink" title="UITaUITableView的beginUpdates和endUpdates"></a>UITaUITableView的<code>beginUpdates</code>和<code>endUpdates</code></h1><ol><li>这个方法用于在调用插入，删除，选择方法时，同时有动画效果。 </li><li>用endUpdate能动画改变行高(触发<code>heightForRowAtIndexPath</code>回调)，而无需relaod这个cell。</li></ol><h2 id="使用场景一：点击cell，cell的高度就变高"><a href="#使用场景一：点击cell，cell的高度就变高" class="headerlink" title="使用场景一：点击cell，cell的高度就变高"></a>使用场景一：点击cell，cell的高度就变高</h2><p>Cell点击方法执行</p><pre><code class="Objective-C">  [tableView beginUpdates];  [tableView endUpdates];</code></pre><p>这两句代码中间没有任何其他部分，但是会触发<code>heightForRowAtIndexPath</code>回调，从而修改cell的高度</p><h2 id="使用场景二：有一个-TableView，现在我希望每按一次-update-按钮，就动态地在下方加两行。"><a href="#使用场景二：有一个-TableView，现在我希望每按一次-update-按钮，就动态地在下方加两行。" class="headerlink" title="使用场景二：有一个 TableView，现在我希望每按一次 update 按钮，就动态地在下方加两行。"></a>使用场景二：有一个 TableView，现在我希望每按一次 update 按钮，就动态地在下方加两行。</h2><ul><li>方法一：简单粗暴的做法 ，更改数据源，然后刷新一下列表</li></ul><pre><code class="Objective-C">// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;] @IBAction func update(_ sender: AnyObject) {     tableData.append(&quot;\(tableData.count)&quot;)     tableData.append(&quot;\(tableData.count)&quot;)     tableView.reloadData() }</code></pre><ul><li>方法二</li></ul><pre><code class="Objective-C">// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]@IBAction func update(_ sender: AnyObject) {    tableData.append(&quot;\(tableData.count)&quot;)    tableData.append(&quot;\(tableData.count)&quot;)    tableView.beginUpdates()    let indexPaths = [IndexPath(row: tableData.count-2, section: 0), IndexPath(row: tableData.count-1, section: 0)]    tableView.insertRows(at: indexPaths, with: UITableViewRowAnimation.automatic)    tableView.endUpdates()}</code></pre><p>这里 beginUpdates 和 endUpdates 方法的作用是，将这两条语句之间的对 tableView 的 insert/delete 操作聚合起来，然后同时更新 UI。</p><h1 id="动态改变tableHeaderView高度"><a href="#动态改变tableHeaderView高度" class="headerlink" title="动态改变tableHeaderView高度"></a>动态改变<code>tableHeaderView</code>高度</h1><p>view 作为 tableView 的 tableHeaderView，单纯的改变 view 的 frame 是无济于事的，tableView 不会时刻适应它的高度，</p><p>所以，如何告诉tableView 它的 tableHeaderView 已经改变了？</p><pre><code class="Objective-C">headerView.frame = newFrame;[self.tableView setTableHeaderView:headerView];</code></pre><p>或者</p><pre><code class="Objective-C">[self.tableView beginUpdates];[self.tableView setTableHeaderView:headerView];[self.tableView endUpdates];</code></pre><h2 id="如何检测动画在UITableView-beginUpdates-endUpdates上结束"><a href="#如何检测动画在UITableView-beginUpdates-endUpdates上结束" class="headerlink" title="如何检测动画在UITableView beginUpdates / endUpdates上结束"></a>如何检测动画在UITableView beginUpdates / endUpdates上结束</h2><pre><code class="Objective-C">[CATransaction begin];[CATransaction setCompletionBlock:^{    // animation has finished}];[tableView beginUpdates];// do some work[tableView endUpdates];[CATransaction commit];</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift入门：基本概念</title>
      <link href="/2018/05/21/RxSwift%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/05/21/RxSwift%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><p>Observables是一个事件流的对象</p><h2 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h2><p>通过empty函数，可以生成一个空的流，在这个流中只会产生一个Completed信息。</p><pre><code class="Swift">let emptyStream: Observable&lt;Int&gt; = Observable.empty()_ = emptyStream.subscribe { event inprint(event)  completed}</code></pre><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>通过never函数产生的流对象，将不会有任何的事件发生。</p><pre><code class="Swift">let neverStream: Observable&lt;Int&gt; = Observable.never()_ = neverStream.subscribe({ _ inprint(&quot;这个方法永远都不会被执行&quot;)})</code></pre><h2 id="just"><a href="#just" class="headerlink" title="just"></a>just</h2><p>just函数调用之后将会产生一个next事件以及一个Completed事件，其中next可以用来传递数据，最后的Completed事件发送之后将不会再有事件了。<br>简单的说：just函数可以发送一个数据。</p><pre><code class="Swift">let justStream = Observable.just(32)_ = justStream.subscribe({ event inprint(event)/*next(32)completed*/})</code></pre><h2 id="of"><a href="#of" class="headerlink" title="of"></a>of</h2><p>将一个集合内的数据所有数据顺序的发送出去。</p><pre><code class="Swift">let ofStream = Observable.of(0, 1, 2)_ = ofStream.subscribe({ event inprint(event)/*next(0)next(1)next(2)completed*/})</code></pre><h2 id="from"><a href="#from" class="headerlink" title="from"></a>from</h2><p>将一个集合对象（比如数组、Range等）转换成流对象，通过订阅可以获得这个集合对象的所有内容。</p><pre><code class="Swift">let streamFromArray = Observable.from([0, 1, 2])_ = streamFromArray.subscribe({ (event) inprint(event)/*next(0)next(1)next(2)completed*/})</code></pre><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>create 函数是通过利用闭包来生成流对象的函数</p><pre><code class="Swift">let myJust = { (singleElement: Int) -&gt; Observable &lt;Int&gt; inreturn Observable.create({ (observer) -&gt; Disposable inobserver.onNext(singleElement)observer.onCompleted()return Disposables.create()})}let singleElementStream = myJust(32)_ = singleElementStream.subscribe { (event) inprint(event)/*next(32)completed*/}</code></pre><h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>通过error函数将会生成一个终止的流，这个流中只会产生一次error事件并结束掉。</p><pre><code class="Swift">let error = NSError(domain: &quot;com.RxSwiftDemo.kesen&quot;, code: -1, userInfo: nil)let errorStream: Observable&lt;Int&gt; = Observable.error(error)_ = errorStream.subscribe { (event) inprint(event)error(Error Domain=com.RxSwiftDemo.kesen Code=-1 &quot;(null)&quot;)}</code></pre><h2 id="deffered"><a href="#deffered" class="headerlink" title="deffered"></a>deffered</h2><p>deffered函数生成的流对象，只有在添加了订阅者才会被创建。</p><pre><code class="Swift">let defferedStream = Observable.deferred { () -&gt; Observable&lt;Int&gt; inreturn Observable.create({ (observer) -&gt; Disposable inobserver.onNext(0)observer.onNext(1)observer.onCompleted()return Disposables.create()})}_ = defferedStream.subscribe({ (event) inprint(event)/*next(0)next(1)completed*/})</code></pre><h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>Subject其实就是Observer，拥有Observer的所有功能，也可以认为是热的Observer。</p><h2 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h2><p>它仅仅会发送observer订阅之后的事件，也就是说如果sequence上有.Next 的到来，但是这个时候某个observer还没有subscribe它，这个observer就收不到这条信息，它只会收到它订阅之后发生的事件。</p><h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>它和PublishSubject不同之处在于它不会漏消息。即使observer在subscribe的时候已经有事件发生过了，它也会收到之前的事件序列。</p><h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>当有observer在订阅一个BehaviorSubject的时候，它首先将会收到Observable上最近发送一个信号（或者是默认值），接着才会收到Observable上会发送的序列。</p><h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>Variable是BehaviorSubject的封装，它和BehaviorSubject不同之处在于，不能向Variable发送.Complete和.Error，它会在生命周期结束被释放的时候自动发送.Complete。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Rx &amp; RAC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TextInput</title>
      <link href="/2018/05/21/TextInput/"/>
      <url>/2018/05/21/TextInput/</url>
      
        <content type="html"><![CDATA[<h1 id="通用属性-Android-amp-iOS"><a href="#通用属性-Android-amp-iOS" class="headerlink" title="通用属性(Android &amp; iOS)"></a>通用属性(Android &amp; iOS)</h1><ul><li>(1)支持View的相关属性</li><li><p>(2)<code>autoCapitalize</code>:控制输入的字符进行切换成大写(参数:’none’,’sentences’,’words’,’characters’)<br><code>none</code>: 不自动切换任何字符大写<br><code>sentences</code>: 默认每个句子的首字母大写<br><code>words</code>:每个单词的首字母变成大写<br><code>characters</code>:每个字母全部变成大写</p></li><li><p>(3)<code>autoCorrect(bool)</code>:设置瓶邪自动修正功能,默认开启(true)</p></li><li><p>(4)<code>autoFocus(bool)</code>:设置是否默认获取到焦点,默认为关闭(false).需要comonentDidMount方法调用之后才会获取焦点(componentDidMount是React组件被渲染之后React主动回调的方法)</p></li><li><p>(5)<code>defaultValue(string)</code>:给文本框输入一个默认初始值.</p></li><li><p>(6)<code>editable(bool)</code>:设置文本框是否可以编辑,默认为true,可以进行编辑</p></li><li><p>(7)<code>keyboardType</code>:<br>键盘类型(可选参数:”default”, ‘email-address’, ‘numeric’, ‘phone-pad’, “ascii-capable”, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’) 该用来选择默认弹出键盘的类型例如我们甚至numeric就是弹出数字键盘。鉴于平台的原因如下的值是所有平台都可以进行通用的</p></li><li><p>(8)<code>maxLength(number)</code>:可以限制文本输入框最大的输入字符长度</p></li><li><p>(9)<code>multiline (bool)</code> : 设置可以输入多行文字，默认为false(表示无论文本输入多少，都是单行显示)</p></li><li>(10)<code>onBlur (function)</code>: 监听方法，文本框失去焦点回调方法</li><li>(11)<code>onChange (function)</code>: 监听方法,文本框内容发生改变回调方法</li><li>(12)<code>onChangeText (function)</code>:监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容</li><li>(13)<code>onEndEditing (function)</code>:监听方法，当文本结束文本输入回调方法</li><li>(14)<code>onFocus (function)</code> :监听方法 文本框获取到焦点回调方法</li><li>(15)<code>onLayout (function)</code>:监听方法 组价布局发生变化的时候调用，调用方法参数为 {x,y,width,height}</li><li>(16)<code>onSubmitEditing (function)</code>:监听方法，当编辑提交的时候回调方法。不过如果multiline={true}的时候，该属性就不生效</li><li>(17)<code>placeholder (string</code>) :当文本输入框还没有任何输入的时候，默认显示信息，当有输入的时候该值会被清除</li><li>(18)<code>placeholderText Color (string)</code>: 设置默认信息颜色(placeholer)</li><li>(19)<code>secureTextEntry (bool)</code>: 设置是否为密码安全输入框 ，默认为false</li><li>(20)<code>style</code> 风格属性 可以参考Text组件风格</li><li>(21)<code>value ( string )</code>:输入框中的内容值</li><li>(22)<code>returnKeyType</code>:决定“确定”按钮显示的内容。<br>done<br>go<br>next<br>search<br>send</li></ul><h1 id="Android-平台属性"><a href="#Android-平台属性" class="headerlink" title="Android 平台属性"></a>Android 平台属性</h1><ul><li>(22)<code>numberOfLines (number)</code>:设置文本输入框行数，该需要首先设置multiline为true,设置TextInput为多行文本。</li><li>(23)<code>textAlign</code> 设置文本横向布局方式 可选参数(‘start’, ‘center’, ‘end’)</li><li>(24)<code>textAlignVertical</code>: 设置文本垂直方向布局方式 可选参数(‘top’, ‘center’, ‘bottom’)</li><li>(25)<code>underlineColorAndroid</code>: 设置文本输入框下划线的颜色</li></ul><h1 id="长按出现菜单键为英文，如何改为中文"><a href="#长按出现菜单键为英文，如何改为中文" class="headerlink" title="长按出现菜单键为英文，如何改为中文"></a>长按出现菜单键为英文，如何改为中文</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829210921.png" alt=""><br>在Xcode中，TARGETS—你的项目名—info，选择Localization native development region，选择China，这样文字都会变成中文啦，包括时间选择器等也会变成中文。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829210959.png" alt=""></p><h1 id="键盘处理"><a href="#键盘处理" class="headerlink" title="键盘处理"></a>键盘处理</h1><p><a href="https://facebook.github.io/react-native/docs/inputaccessoryview#docsNav" target="_blank" rel="noopener">参考</a><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211043.png" alt=""></p><pre><code class="javascript">    const inputAccessoryViewID = &quot;inputAccessoryViewID&quot;;    _renderLeaveWordInput() {         return &lt;View style={{height: 60}}&gt;                &lt;TextInput style={{                    fontSize: 13,                    textAlignVertical: 'top',                    autoCapitalize: 'none',                    autoCorrect: false                 }}                   multiline={true}                   maxLength={50}                   onChangeText={this._onInputCommentsChange}                   value={this.state.comments}                   inputAccessoryViewID={inputAccessoryViewID}                   ref={&#39;LeaveWordTextInput&#39;}                   placeholder={&#39;请输入留言&#39;}/&gt;                &lt;InputAccessoryView nativeID={inputAccessoryViewID}&gt;                    &lt;View style={{flexDirection:'row-reverse'}}&gt;                        &lt;Button onPress={() =&gt; {this.refs.LeaveWordTextInput.blur();}}                                title=&quot;完成&quot;                                color=&quot;red&quot;                        /&gt;                    &lt;/View&gt;                &lt;/InputAccessoryView&gt;            &lt;/View&gt;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
          <category> React-Native </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React-Native Tips</title>
      <link href="/2018/05/21/React-Native%20Tips/"/>
      <url>/2018/05/21/React-Native%20Tips/</url>
      
        <content type="html"><![CDATA[<h1 id="快速进入断点"><a href="#快速进入断点" class="headerlink" title="快速进入断点"></a>快速进入断点</h1><ol><li>模拟器开启远程调试</li><li>在浏览器上<code>cmd+option+I</code>打开调试页面</li><li>代码输入<code>dubugger</code>进入断点<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211638.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211651.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
          <category> React-Native </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React-Native数据传递</title>
      <link href="/2018/05/21/React-Native%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
      <url>/2018/05/21/React-Native%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h1 id="通过react-navigation传递数据"><a href="#通过react-navigation传递数据" class="headerlink" title="通过react-navigation传递数据"></a>通过react-navigation传递数据</h1><h2 id="顺传"><a href="#顺传" class="headerlink" title="顺传"></a>顺传</h2><p>传递数据</p><pre><code>_onItemPress = (item) =&gt; {    NavigationService.navigate(&quot;VehicleMonitorCarInfoPage&quot;, {        data: item    });};</code></pre><p>获取数据</p><pre><code>componentDidMount() {    // 或者使用 this.props.navigation.getParam(&#39;data&#39;)    let data = this.props.navigation.state.params.data;}</code></pre><h2 id="逆传"><a href="#逆传" class="headerlink" title="逆传"></a>逆传</h2><p>传递数据</p><pre><code>_callback = (message) =&gt; {    console.log(message);}_onItemPress = (item) =&gt; {    NavigationService.navigate(&quot;VehicleMonitorCarInfoPage&quot;, {        callback: this._callback    });};</code></pre><p>子组件获取回调并执行</p><pre><code>render() {    return (        &lt;View style={styles.container}&gt;            &lt;Button                title={&#39;点击测试&#39;}                onPress={() =&gt; this.props.navigation.state.params.callback(&#39;hello world&#39;) }&gt;            &lt;/Button&gt;        &lt;/View&gt;    );}</code></pre><h1 id="通过组件传递数据"><a href="#通过组件传递数据" class="headerlink" title="通过组件传递数据"></a>通过组件传递数据</h1><h2 id="顺传-1"><a href="#顺传-1" class="headerlink" title="顺传"></a>顺传</h2><p>传递数据</p><pre><code>_renderItem = ({item, index}) =&gt; {    return (&lt;View&gt;        &lt;MsgCard msg={item} index={index} allMsgPageType={this.state.msgType} navigation={this.props.navigation}/&gt;    &lt;/View&gt;)};</code></pre><p>子组件获取数据</p><pre><code>export default class MsgCard extends Component&lt;Props&gt; {    constructor(props) {        super(props);        this.state = {            msg: this.props.msg,            index: this.props.index,            allMsgPageType: this.props.allMsgPageType,        }    }    //父组件更新数据，子组件不刷新时使用    componentWillReceiveProps(nextProps) {        this.setState({            msg: nextProps.msg,            index: nextProps.index,            allMsgPageType: nextProps.allMsgPageType,        });    }}</code></pre><h2 id="逆传-1"><a href="#逆传-1" class="headerlink" title="逆传"></a>逆传</h2><p>组件A<br>传递callback</p><pre><code>_callback = (message) =&gt; {    console.log(message);}render() {    return (    &lt;View&gt;        &lt;MyListItem callback={this._callback}&gt;&lt;/MyListItem&gt;    &lt;/View&gt;)};</code></pre><p>组件B<br>子组件获取传递过来的callback并执行</p><pre><code>class MyListItem extends React.PureComponent {    _onPress = () =&gt; {        this.props.callback(&#39;hello world&#39;)    };    render() {        return (            &lt;View style={styles.flatListItem} &gt;                &lt;Button                    title={&quot;点击测试&quot;}                    onPress={this._onPress}                &gt;                &lt;/Button&gt;            &lt;/View&gt;        );    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
          <category> React-Native </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS11新特性</title>
      <link href="/2017/12/22/iOS11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2017/12/22/iOS11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="iOS11-大标题"><a href="#iOS11-大标题" class="headerlink" title="iOS11 大标题"></a>iOS11 大标题</h1><pre><code>// 导航控制器的`prefersLargeTitles`为大标题的总开关navigationController?.navigationBar.prefersLargeTitles = true// 各个控制器可以自己通过 largeTitleDisplayMode，如果导航控制器的 `prefersLargeTitles` 为 NO，largeTitleDisplayMode 将没有效果navigationItem.largeTitleDisplayMode = .never</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-d28e28449f722b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="iOS11-导航栏搜索框"><a href="#iOS11-导航栏搜索框" class="headerlink" title="iOS11 导航栏搜索框"></a>iOS11 导航栏搜索框</h1><pre><code>let searchResultsVC = SearchResultTabelViewVC(nibName: nil, bundle: nil)lazy var searchController: UISearchController = {let vc = UISearchController(searchResultsController: searchResultsVC)vc.searchResultsUpdater = self.searchResultsVCvc.hidesNavigationBarDuringPresentation = truevc.dimsBackgroundDuringPresentation = truevc.searchBar.placeholder = &quot;搜索设备&quot;vc.searchBar.enablesReturnKeyAutomatically = falsevc.searchBar.sizeToFit()return vc}()navigationItem.searchController = searchControllernavigationItem.hidesSearchBarWhenScrolling = false</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-d3ea03b58766402f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-de6a6e4434ad40f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="iOS11-Safe-Area-Insets"><a href="#iOS11-Safe-Area-Insets" class="headerlink" title="iOS11 Safe Area Insets"></a>iOS11 Safe Area Insets</h1><pre><code>additionalSafeAreaInsets = UIEdgeInsets(top: 100, left: 0, bottom: 100, right: 100)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-390517a880546e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="UITableView-separatorInsetReference"><a href="#UITableView-separatorInsetReference" class="headerlink" title="UITableView separatorInsetReference"></a>UITableView separatorInsetReference</h1><p><img src="https://upload-images.jianshu.io/upload_images/1120923-67de438546b61af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1120923-1b6960bbfe07be8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>tableView.estimatedRowHeight = 0tableView.estimatedSectionHeaderHeight = 0tableView.estimatedSectionFooterHeight = 0tableView.separatorInsetReference = .fromAutomaticInsetstableView.separatorInset.left = 60</code></pre><h1 id="UITableViewCell-左划、右划"><a href="#UITableViewCell-左划、右划" class="headerlink" title="UITableViewCell 左划、右划"></a>UITableViewCell 左划、右划</h1><pre><code>// iOS11 UITableViewCell 左划override func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {let action = UIContextualAction(style: .normal, title: &quot;收藏&quot;) { (action, view, completionHandler) in// 执行收藏操作// ...completionHandler(true)}action.image =  imageLiteral(resourceName: &quot;favorite&quot;)action.backgroundColor = UIColor.redlet configuration = UISwipeActionsConfiguration(actions: [action])return configuration}// iOS11 UITableViewCell 右划override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {let action = UIContextualAction(style: .destructive, title: &quot;删除&quot;) { (action, view, completionHandler) in// remove item// ...completionHandler(true)}let configuration = UISwipeActionsConfiguration(actions: [action])return configuration}</code></pre><h1 id="代码见"><a href="#代码见" class="headerlink" title="代码见"></a>代码见</h1><p><a href="https://github.com/action456789/iOS11Demo" target="_blank" rel="noopener">https://github.com/action456789/iOS11Demo</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS SDK 开发</title>
      <link href="/2017/12/09/iOS-SDK-%E5%BC%80%E5%8F%91/"/>
      <url>/2017/12/09/iOS-SDK-%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Framework与-a基础"><a href="#一、Framework与-a基础" class="headerlink" title="一、Framework与.a基础"></a>一、Framework与.a基础</h1><p>此处等下一期</p><p><br></p><hr><h1 id="二、工程嵌套联调静态库"><a href="#二、工程嵌套联调静态库" class="headerlink" title="二、工程嵌套联调静态库"></a>二、工程嵌套联调静态库</h1><h2 id="1、新建一个主工程"><a href="#1、新建一个主工程" class="headerlink" title="1、新建一个主工程"></a>1、新建一个主工程</h2><p><br></p><h2 id="2、新建一个Library工程"><a href="#2、新建一个Library工程" class="headerlink" title="2、新建一个Library工程"></a>2、新建一个Library工程</h2><p><br></p><h2 id="3、将静态库工程拖到主工程文件夹下"><a href="#3、将静态库工程拖到主工程文件夹下" class="headerlink" title="3、将静态库工程拖到主工程文件夹下"></a>3、将静态库工程拖到主工程文件夹下</h2><blockquote><p>如果你要拖到其他目录，就要改Library Search Paths<br><img src="https://upload-images.jianshu.io/upload_images/1120923-cce04359a1bbfaad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><br></p></blockquote><h2 id="4、将Library工程下-a文件拖入主工程的Link-Binary-With-Libraries"><a href="#4、将Library工程下-a文件拖入主工程的Link-Binary-With-Libraries" class="headerlink" title="4、将Library工程下.a文件拖入主工程的Link Binary With Libraries"></a>4、将Library工程下.a文件拖入主工程的Link Binary With Libraries</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-a5abaa5e64aee935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果有必要（运行时崩溃），将静态库需要加入 Embedded Binaries 中<br><img src="https://upload-images.jianshu.io/upload_images/1120923-a187820d28065970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="5-主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"><a href="#5-主工程添加对子工程的依赖，避免每次修改都要手动编译子工程" class="headerlink" title="5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"></a>5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程</h2><p>如下图给主工程添加对子工程的依赖，这样每次编译主工程的时候也会编译子工程。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-014ee57b806790ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><br></p><hr><h1 id="三、在静态库中使用图片以及-xib-等资源文件"><a href="#三、在静态库中使用图片以及-xib-等资源文件" class="headerlink" title="三、在静态库中使用图片以及 xib 等资源文件"></a>三、在静态库中使用图片以及 xib 等资源文件</h1><h2 id="1、添加-Bundle-Target"><a href="#1、添加-Bundle-Target" class="headerlink" title="1、添加 Bundle Target"></a>1、添加 Bundle Target</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-0daa863f0f458a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>因为iOS框架中没有bundle，要选中OS X框架找到bundle，如下图<br><img src="https://upload-images.jianshu.io/upload_images/1120923-271a68244a055813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h2 id="2、将资源文件加入-bundle-中"><a href="#2、将资源文件加入-bundle-中" class="headerlink" title="2、将资源文件加入 bundle 中"></a>2、将资源文件加入 bundle 中</h2><p>将工程中的资源文件都加入到刚刚建的bundle中，如xib、图片。点+号或直接拖都行。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-54e9d8ebb8086020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="3、iOS-Deployment-Target改为你支持的最低版本"><a href="#3、iOS-Deployment-Target改为你支持的最低版本" class="headerlink" title="3、iOS Deployment Target改为你支持的最低版本"></a>3、iOS Deployment Target改为你支持的最低版本</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-acc55ab1a1c172ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="4、设置base-SDK-为latest-iOS"><a href="#4、设置base-SDK-为latest-iOS" class="headerlink" title="4、设置base SDK 为latest iOS"></a>4、设置base SDK 为latest iOS</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-935ccc7c15d9dd90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="5、编译-Bundle"><a href="#5、编译-Bundle" class="headerlink" title="5、编译 Bundle"></a>5、编译 Bundle</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-89b0b426acb67a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"><a href="#6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程" class="headerlink" title="6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"></a>6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5e09392ed9b3954c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="7、加载-Bundle-里的资源文件"><a href="#7、加载-Bundle-里的资源文件" class="headerlink" title="7、加载 Bundle 里的资源文件"></a>7、加载 Bundle 里的资源文件</h2><h3 id="7-1、加载图片"><a href="#7-1、加载图片" class="headerlink" title="7.1、加载图片"></a>7.1、加载图片</h3><p>使用运行时替换 <code>[UIImage imageNamed:]</code>方法，减少修改代码的工作量。<br>相关代码在以下几个类中<br><img src="https://upload-images.jianshu.io/upload_images/1120923-d22158e1d55e1cab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>// 在AppDelegate中执行以下代码即可swizzle 所有 [UIImage imageNamed:]#import &quot;UIImage+Swizzle.h&quot;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    [UIImage kk_autoLoadImageInBundle];    return YES;}</code></pre><ul><li>UIImage+Swizzle.m<br><code>`</code><br>//<br>// 修改所有的 [UIImage imageNamed:]的实现，改为先从同一项目中的 .bundle 文件中加载，没有再使用系统默认实现加载</li></ul><ul><li>(void)kk_autoLoadImageInBundle {<br>  SEL original = @selector(imageNamed:);<br>  SEL new = @selector(hook_kk_imageWithName:);<br>  [self kk_swizzleClassMethod:original with:new];<br>}</li></ul><p>// 1. 从 .bundle 中加载图片<br>// 2. 按照默认的方法加载图片</p><ul><li><p>(instancetype)hook_kk_imageWithName:(NSString <em>)imageName {<br>  UIImage </em>image = [NSBundle kk_imageInBundle:kk_BundleName imageName:imageName];<br>  if (!image) {</p><pre><code>  image = [self hook_kk_imageWithName:imageName];</code></pre><p>  }</p><p>  return image;<br>}<br><code>`</code></p></li></ul><ul><li>NSObject+Swizzle.m<br><code>`</code><br>#import “NSObject+Swizzle.h”<br>#import &lt;objc/objc.h&gt;<br>#import &lt;objc/runtime.h&gt;</li></ul><p>@implementation NSObject (Swizzle)</p><ul><li><p>(BOOL)kk_swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel {<br>  Class class = object_getClass(self);<br>  Method originalMethod = class_getInstanceMethod(class, originalSel);<br>  Method newMethod = class_getInstanceMethod(class, newSel);</p><p>  if (!originalMethod || !newMethod) return NO;<br>  method_exchangeImplementations(originalMethod, newMethod);</p><p>  return YES;<br>}</p></li><li><p>(BOOL)kk_swizzleClassMethod:(SEL)originalSel with:(SEL)newSel {<br>  Class class = object_getClass(self);<br>  Method originalMethod = class_getClassMethod(class, originalSel);<br>  Method newMethod = class_getClassMethod(class, newSel);</p><p>  if (!originalMethod || !newMethod) return NO;<br>  method_exchangeImplementations(originalMethod, newMethod);</p><p>  return YES;<br>}</p></li></ul><p>@end</p><pre><code>### 7.2、加载 `xib`#### 7.2.1 加载xib对应的`UIViewController`需要重写xib对应控制器的 init 方法，否则可能出现找不到xib文件导致crash参考[bundle打包xib文件](http://www.jianshu.com/p/a8c9e52c80de)</code></pre><ul><li><p>(instancetype)init {</p><p>  NSBundle *bundle = [NSBundle kk_bundleWithName:kBundleTargetName];</p><p>  self = [super initWithNibName:@”CalculatePriceViewController” bundle:bundle];</p><p>  return self;</p></li></ul><p>}</p><pre><code>代码参见：[github]([https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)](https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h))#### 7.2.1 加载xib对应的`UIVIew`需要重写xib对应View的 init 方法，，否则可能出现找不到xib文件导致crash</code></pre><p>@implementation OfflineView</p><p>//重写要加载的view的init方法</p><ul><li>(instancetype)init {<br>  if (self = [super init]) {<pre><code>  NSBundle *bundle = [NSBundle kk_bundleWithName:kk_BundleName];  self = [[bundle loadNibNamed:@&quot;OfflineView&quot; owner:self options:nil] lastObject];</code></pre>  }<br>  return self;<br>}</li></ul><p>@end</p><pre><code>### 7.3、加载 `Localizable.strings`#### 第一步：在Bundle中新建国际化文件![image.png](https://upload-images.jianshu.io/upload_images/1120923-6f11bf3b8f5d2236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)#### 第二步：添加语言，并将之前的国际化文件中的代码复制过来![image.png](https://upload-images.jianshu.io/upload_images/1120923-37cc110dd92a5079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)#### 第三步：使用 NSBundle+Resource 如下方法</code></pre><ul><li>(NSString <em>)mj_localizedStringForKey:(NSString </em>)key;</li><li>(NSString <em>)mj_localizedStringForKey:(NSString </em>)key value:(NSString *)value;<pre><code>然后使用如下宏定义</code></pre>// 加载 Bundle 中的国际化语句<br>#undef NSLocalizedString<br>#define NSLocalizedString(key, comment) \<br>[NSBundle mj_localizedStringForKey:(key)]<br><code>`</code><br>然后就可以自动的加载Bundle中的字符串了</li></ul><p><br></p><hr><h1 id="四、将整个App打包为Framework"><a href="#四、将整个App打包为Framework" class="headerlink" title="四、将整个App打包为Framework"></a>四、将整个App打包为Framework</h1><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ol><li>整个项目都要解除 AppDelegate 的依赖，AppDelegate不能打入Framework中</li><li>图片和xib文件需要按照 三 中的处理</li><li>可以使用 runtime 动态加载图片和xib文件，减少工作量</li><li>注意点：bundle中的国际化文件需要重新新建，添加语言，然后将之前App中的内容复制过来，直接拖进去是无效的</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1120923-57f527356830710e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="实际操作中存在的问题"><a href="#实际操作中存在的问题" class="headerlink" title="实际操作中存在的问题"></a>实际操作中存在的问题</h2><ol><li>图片同时存在@2x和@3x后缀导致加载的图片为nil的问题<br>解决办法为只要@2x的图片</li></ol><p><br></p><hr><h1 id="五、使用-appledoc-生成文档"><a href="#五、使用-appledoc-生成文档" class="headerlink" title="五、使用 appledoc 生成文档"></a>五、使用 <code>appledoc</code> 生成文档</h1><p><a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">官网</a></p><ul><li>安装<br><code>brew install appledoc</code></li><li>查看版本<br><code>appledoc --version</code></li><li>查看帮助<br><code>appledoc --help</code></li><li>生成文档<pre><code>appledoc --output ./doc --project-name &quot;D103Framework&quot;  --project-company &quot;RICISUNG&quot; --company-id &quot;RICISUNG&quot; .  </code></pre>”.“ 和前面的符号一定要加 空格 否则就会报错。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-dbc07ae1c94010da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h1 id="iOS-工程套子工程，主工程和framework工程或-a-library静态库工程联调-http-www-cnblogs-com-zhanglinfeng-p-5494762-html"><a href="#iOS-工程套子工程，主工程和framework工程或-a-library静态库工程联调-http-www-cnblogs-com-zhanglinfeng-p-5494762-html" class="headerlink" title="iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调](http://www.cnblogs.com/zhanglinfeng/p/5494762.html))"></a><a href="[http://www.cnblogs.com/zhanglinfeng/p/5494762.html"><a href="http://www.cnblogs.com/zhanglinfeng/p/5494762.html" target="_blank" rel="noopener">iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调</a></a>](<a href="http://www.cnblogs.com/zhanglinfeng/p/5494762.html)" target="_blank" rel="noopener">http://www.cnblogs.com/zhanglinfeng/p/5494762.html)</a>)</h1><h1 id="iOS-framework静态库中使用xib和图片资源详解"><a href="#iOS-framework静态库中使用xib和图片资源详解" class="headerlink" title="iOS framework静态库中使用xib和图片资源详解"></a><a href="http://www.cnblogs.com/zhanglinfeng/p/5510717.html" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/zhanglinfeng/p/5510717.html" target="_blank" rel="noopener">iOS framework静态库中使用xib和图片资源详解</a></a></h1>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令大全</title>
      <link href="/2017/09/09/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2017/09/09/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC] </p><p>#基本概念</p><ul><li><code>master</code>指针：指向最新的提交</li></ul><hr><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://sfault-image.b0.upaiyun.com/37/92/37923f2478edc5709b36562b26c9e008" target="_blank" rel="noopener">http://sfault-image.b0.upaiyun.com/37/92/37923f2478edc5709b36562b26c9e008</a></p><hr><p>#全局配置<br><code>$ git config --global user.name &quot;kk&quot;</code><br><code>$ git config --global user.email &quot;superkesen@gmail.com&quot;</code></p><ul><li><p>编辑模式查看全局设置：<br><code>git config --global -e</code></p></li><li><p>列表形式查看全局设置：<br><code>git config --global -l</code></p></li></ul><hr><h1 id="使用GitHub时，在本地创建SSH-Key"><a href="#使用GitHub时，在本地创建SSH-Key" class="headerlink" title="使用GitHub时，在本地创建SSH Key"></a>使用GitHub时，在本地创建SSH Key</h1><p><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><ul><li><p>如果一切顺利的话，可以在用户主目录里（~/.ssh）找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p></li><li><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p></li></ul><hr><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul><li>克隆远程仓库到本地<br><code>git clone git@github.com:michaelliao/gitskills.git</code></li><li><p>克隆远程仓库某个分支到本地<br><code>git clone -b &lt;branch&gt; &lt;remote_repo&gt;</code><br>例如： <code>git clone -b 指定的分支名字</code></p></li><li><p>给本地仓库指定远程仓库</p></li></ul><ol><li><p>关联GitHub仓库：<br><code>git remote add origin git@github.com:michaelliao/learngit.git</code></p></li><li><p>显示远程仓库：<br><code>git remote show origin</code><br>第一次推送使用：<br><code>git push -u origin 分支名称</code><br>之后推送使用：<br><code>git push origin maste</code></p></li><li><p>查看远程仓库地址<br><code>git remote -v</code></p></li><li><p>取消关联远程仓库<br><code>git remote rm origin</code></p></li></ol><hr><h1 id="初始化git仓库"><a href="#初始化git仓库" class="headerlink" title="初始化git仓库"></a>初始化git仓库</h1><p><code>git init</code><br><code>git add .</code><br><code>git commit -m “xxxx&quot;</code></p><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>删除所有文件<br><code>git rm * -r</code><br>删除文件夹<br><code>git rm filename -r</code><br>忽略无需版本控制的文档<br><code>echo “*.txt” &gt; .gitignore</code></p><hr><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>查看commit日志<br><code>git reflog</code><br>或<br><code>git log</code></p><hr><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul><li>查看当前所在分支<br><code>git branch -a</code></li><li>切换到某个分支<br><code>git checkout 分支名字</code></li></ul><hr><ul><li>创建本地分支并切换到创建的分支：<br><code>git checkout -b your_branch</code></li><li>提交该分支到远程仓库<br><code>git push origin dev</code></li></ul><hr><ul><li>追踪远程分支<br><code>git branch --track release_2.3.0 origin/HEAD:refs/for/release_2.3.0</code></li><li>将本地分支push到远程分支，（远程会自动创建your_branch分支），并关联本地分支与远程分支<br><code>git push -u origin your_branch</code></li><li>删除远程分支<br><code>git push origin --delete &lt;branchName&gt;</code></li><li>删除本地分支<br><code>git branch -d your_branch</code></li></ul><hr><h1 id="本地提交回滚"><a href="#本地提交回滚" class="headerlink" title="本地提交回滚"></a>本地提交回滚</h1><ol><li>先重置本地在上次提交之后的修改（如果需要的话）<br><code>git checkout *.m</code></li><li>重置为远程仓库的最新版本<br>soft表示本地的修改还在本地文件中，不加的话那么本地的修改也没了<br><code>git reset HEAD^ --soft</code></li></ol><hr><h1 id="拉取远程代码时冲突"><a href="#拉取远程代码时冲突" class="headerlink" title="拉取远程代码时冲突"></a>拉取远程代码时冲突</h1><ol><li>保存本地修改到暂存区<br><code>git stash</code></li><li>拉取远程代码<br><code>git pull</code></li><li>将暂存区内容恢复到本地，有冲突时先解决冲突<br><code>git stash pop</code></li></ol><hr><h1 id="git-stash-的使用"><a href="#git-stash-的使用" class="headerlink" title="git stash 的使用"></a>git stash 的使用</h1><ul><li>列出所有暂时保存的工作<br><code>git stash list</code></li><li>恢复某个暂时保存的工作</li></ul><p><code>git stash apply stash@{1}</code></p><ul><li><p>保存stash时设置stash名称<br><code>git stash save &quot;my_stash&quot;</code></p></li><li><p>丢弃最近一次stash的文件<br><code>git stash drop</code></p></li></ul><h1 id="合并某次提交-merge-a-specific-commit-in-Git"><a href="#合并某次提交-merge-a-specific-commit-in-Git" class="headerlink" title="合并某次提交 merge a specific commit in Git"></a>合并某次提交 merge a specific commit in Git</h1><p><code>git cherry-pick d42c389f</code></p><hr><h1 id="git-merge-后-push-到-Gerrit-失败，提示-no-new-changes"><a href="#git-merge-后-push-到-Gerrit-失败，提示-no-new-changes" class="headerlink" title="git merge 后 push 到 Gerrit 失败，提示 no new changes"></a>git merge 后 push 到 Gerrit 失败，提示 no new changes</h1><ul><li>在 <code>git merge</code> 的时候，加上 <code>--no-ff</code> 参数，是为了让它生成一个新的 commit，这样就可以提交了~（不过生成的 gerrit change 是看不到改动信息的）</li></ul><h1 id="tag-操作"><a href="#tag-操作" class="headerlink" title="tag 操作"></a>tag 操作</h1><ul><li>查看tag<br><code>git tag</code></li><li>创建 本地 tag<br><code>git tag 1.0.0</code><br>或者<br><code>git tag -m &quot;first release&quot; 0.1.0</code></li><li>推送 本地 tag 到远程服务器<br><code>git push origin 1.0.0</code></li><li>或者推送所有tags到远程服务器<br><code>git push --tags</code> </li><li>删除本地 tag<br><code>git tag -d 1.0.0</code></li><li>删除远程 tag</li></ul><ol><li>先删除本地 tag<br><code>git tag -d 1.0.0</code></li><li>然后push<br><code>git push origin --delete tag 1.0.0</code><h1 id="fatal-remote-origin-already-exists-错误解决"><a href="#fatal-remote-origin-already-exists-错误解决" class="headerlink" title="fatal: remote origin already exists.错误解决"></a><code>fatal: remote origin already exists.</code>错误解决</h1></li><li>先删除远程 Git 仓库</li></ol><p><code>git remote rm origin</code><br>2 再添加远程 Git 仓库</p><p><code>git remote add origin git@github.com:FBing/Java-code-generator</code></p><h1 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h1><ul><li>创建<code>.gitignore文件</code><br><code>touch .gitignore</code><br>忽略规则示例<pre><code># 这是注释行，将被忽略*.a       # 忽略所有以.a为扩展名的文件    !lib.a    # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略/TODO     # 只忽略此目录下的TODO文件，子目录中的TODO文件不忽略build/    # 忽略所有build目录下的文件，但如果是名为build的文件则不忽略doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略</code></pre>例如忽略下图的GPUImage.framework框架<pre><code>SystemVedio/GPUImage/GPUImage.framework</code></pre><img src="https://upload-images.jianshu.io/upload_images/1120923-8af29923ea45d7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6218590.png"></li></ul><p>只追踪某几个文件</p><pre><code>#忽略所有文件，注意放在开头/*#除src文件夹外!/src#除bin文件夹外!/bin #总的效果就是git只跟踪src和bin两个文件夹</code></pre><h1 id="merge-与-rebase-的区别"><a href="#merge-与-rebase-的区别" class="headerlink" title="merge 与 rebase 的区别"></a>merge 与 rebase 的区别</h1><blockquote><p>作者：王靖轩<br>链接：<a href="https://www.zhihu.com/question/36509119/answer/131513261" target="_blank" rel="noopener">https://www.zhihu.com/question/36509119/answer/131513261</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>搞清楚这个问题首先要搞清楚merge和rebase背后的含义。</p><h2 id="merge：会产生一次合并提交"><a href="#merge：会产生一次合并提交" class="headerlink" title="merge：会产生一次合并提交"></a>merge：会产生一次合并提交</h2><p>先看merge，官方文档给的说明是：<br>git-merge - Join two or more development histories together</p><p>顾名思义，当你想要两个分支交汇的时候应该使用merge。<br>根据官方文档给的例子，是master merge topic，如图：<br>A—B—C topic<br>/         \<br>D—E—F—G—H master<br>然而在实践中，在H这个commit上的merge经常会出现merge conflict。为了避免解决冲突的时候引入一些不必要的问题，工程中一般都会规定no conflict merge。比如你在github上发pull request，如果有conflict就会禁止merge。</p><p>所以才会有题主问的问题：在当前的topic分支，想要引入master分支的F、G commit上的内容以避免merge conflict，方便最终合并到master。</p><p>这种情况下用merge当然是一个选项。用merge代表了topic分支与master分支交汇，并解决了所有合并冲突。然而merge的缺点是引入了一次不必要的history join。如图：<br>A–B–C-X topic<br>/       / \<br>D—E—F—G—H master<br>其实仔细想一下就会发现，在引入master分支的F、G commit这个问题上，我们并没有要求两个分支必须进行交汇(join)，我们只是想避免最终的merge conflict而已。</p><h2 id="rebase：将其他分支的内容整合到当前分支，改变当前分支branch-out的位置"><a href="#rebase：将其他分支的内容整合到当前分支，改变当前分支branch-out的位置" class="headerlink" title="rebase：将其他分支的内容整合到当前分支，改变当前分支branch out的位置"></a>rebase：将其他分支的内容整合到当前分支，改变当前分支branch out的位置</h2><p>rebase是另一个选项。rebase的含义是改变当前分支branch out的位置。这个时候进行rebase其实意味着，将topic分支branch out的位置从E改为G，如图：<br>A—B—C topic<br>/<br>D—E—F—G master<br>在这个过程中会解决引入F、G导致的冲突，同时没有多余的history join。但是rebase的缺点是，改变了当前分支branch out的节点。如果这个信息对你很重要的话，那么rebase应该不是你想要的。rebase过程中也会有多次解决同一个地方的冲突的问题，不过可以用squash之类的选项解决。个人并不认为这个是rebase的主要问题。</p><p>综上，其实选用merge还是rebase取决于你到底是以什么意图来避免merge conflict。实践上个人还是偏爱rebase。一个是因为branch out节点不能改变的情况实在太少。另外就是频繁从master merge导致的冗余的history join会提高所有人的认知成本。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装MQTT服务器</title>
      <link href="/2017/03/03/Mac%E5%AE%89%E8%A3%85MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/03/03/Mac%E5%AE%89%E8%A3%85MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="emqttd-windows版安装"><a href="#emqttd-windows版安装" class="headerlink" title="emqttd windows版安装"></a>emqttd windows版安装</h1><p>具体以官方文档为主</p><ol><li>下载<a href="http://emqtt.io/docs/v2/install.html#installing-on-windows" target="_blank" rel="noopener">http://emqtt.io/docs/v2/install.html#installing-on-windows</a></li><li>进入下载后的bin目录下<br><code>cd C:\Users\kk\Desktop\emqttd\bin\</code><br>然后执行<br><code>emqttd console</code></li><li>进入Web管理控制台(Dashboard)<br>控制台地址: <a href="http://127.0.0.1:18083" target="_blank" rel="noopener">http://127.0.0.1:18083</a><br>默认用户: admin，密码：public</li></ol><a id="more"></a><h1 id="或者使用-mosquitto"><a href="#或者使用-mosquitto" class="headerlink" title="或者使用 mosquitto"></a>或者使用 mosquitto</h1><ol><li>安装<br><code>brew install mosquitto</code></li><li>配置服务器<br>进入目录<code>/usr/local/Cellar/mosquitto</code> 进入响应版本下目录，我这里是<code>1.4.11_2</code><br>找到<code>/etc/mosquitto/mosquitto.conf</code>文件，修改<code>mosquitto.conf</code>可以对服务器进行配置</li><li>启动服务器<br>进入sbin目录：<br><code>/usr/local/Cellar/mosquitto/1.4.11_2/sbin</code><br>然后执行：<br><code>./mosquitto -c /usr/local/Cellar/mosquitto/1.4.11_2/etc/mosquitto/mosquitto.conf -d</code></li></ol><p>参考：<a href="http://blog.csdn.net/pz0605/article/details/51970568" target="_blank" rel="noopener">http://blog.csdn.net/pz0605/article/details/51970568</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autolayout高级</title>
      <link href="/2016/11/09/Autolayout%E9%AB%98%E7%BA%A7/"/>
      <url>/2016/11/09/Autolayout%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="intrinsicContentSize"><a href="#intrinsicContentSize" class="headerlink" title="intrinsicContentSize"></a>intrinsicContentSize</h1><p><code>Intrinsic Content Size</code>：固有大小。意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。</p><p>比如：大家都知道在使用 AutoLayout 的时候，<code>UILabel</code> 就不用指定尺寸大小，只需指定位置即可，就是因为，只要确定了文字内容，字体等信息，它自己就能计算出大小来。</p><blockquote><p><code>UILabel</code>，<code>UIImageView</code>，<code>UIButton</code> 等组件及某些包含它们的系统组件都有 Intrinsic Content Size 属性。</p></blockquote><h1 id="Content-Hugging-约束（不想变大约束）"><a href="#Content-Hugging-约束（不想变大约束）" class="headerlink" title="Content Hugging 约束（不想变大约束）"></a><code>Content Hugging</code> 约束（不想变大约束）</h1><p>如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要拉伸的时候拉伸。</p><h1 id="Content-Compression-Resistance-约束（不想变小约束）"><a href="#Content-Compression-Resistance-约束（不想变小约束）" class="headerlink" title="Content Compression Resistance 约束（不想变小约束）"></a><code>Content Compression Resistance</code> 约束（不想变小约束）</h1><p>如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要压缩的时候压缩。</p><p>例如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-143170678a0a5d2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Top-Layout-Guide"><a href="#Top-Layout-Guide" class="headerlink" title="Top Layout Guide"></a><code>Top Layout Guide</code></h1><p><code>topLayoutGuide</code>属性表示不希望被透明的状态栏或导航栏遮挡的内容范围的最高位置。这个属性的值是它的length属性的值（topLayoutGuide.length）</p><p>这个值可能由当前的ViewController或这个ViewController所属的NavigationController或TabBarController决定，有如下情况：</p><ol><li>一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。</li><li>包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义：</li></ol><blockquote><ol><li>如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。</li><li>如果状态栏可见，topLayoutGuide表示状态栏的底部。</li><li>如果都不可见，表示ViewController的上边缘。</li></ol></blockquote><p>总之是屏幕上方任何遮挡内容的栏的最底部。</p><h1 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h1><p>*作用：取代<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>**</p><p><code>safeArea</code>是描述你的视图部分不被任何内容遮挡的方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-4bfd008744e885e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="改变布局的方法"><a href="#改变布局的方法" class="headerlink" title="改变布局的方法"></a>改变布局的方法</h1><h2 id="一、-setNeedsLayout与layoutIfNeeded"><a href="#一、-setNeedsLayout与layoutIfNeeded" class="headerlink" title="一、 setNeedsLayout与layoutIfNeeded"></a>一、 <code>setNeedsLayout</code>与<code>layoutIfNeeded</code></h2><p>更新Autolayout后，如何要立即刷新布局，还要依次调用以下两个方法</p><pre><code>// 立即刷新布局（自己和subview的）self.view.setNeedsLayout()self.view.layoutIfNeeded()</code></pre><p><code>setNeedsLayout</code>给当前 UIView 立一个 flag，以表示后续应该调用 <code>layoutSubviews</code>方法，以调整当前视图及其子视图的布局。</p><p><code>layoutIfNeeded</code>如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）</p><h2 id="二、-layoutSubviews"><a href="#二、-layoutSubviews" class="headerlink" title="二、 layoutSubviews"></a>二、 <code>layoutSubviews</code></h2><h3 id="触发时机——Frame改变就会触发，具体如下"><a href="#触发时机——Frame改变就会触发，具体如下" class="headerlink" title="触发时机——Frame改变就会触发，具体如下"></a>触发时机——Frame改变就会触发，具体如下</h3><ol><li><p>初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发</p></li><li><p>addSubview会触发layoutSubviews</p></li><li><p>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化</p></li><li><p>滚动一个UIScrollView会触发layoutSubviews</p></li><li><p>旋转Screen会触发父UIView上的layoutSubviews事件</p></li><li><p>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p></li></ol><h3 id="何时重写-layoutSubviews-方法"><a href="#何时重写-layoutSubviews-方法" class="headerlink" title="何时重写 layoutSubviews 方法"></a>何时重写 <code>layoutSubviews</code> 方法</h3><pre><code>当我们在某个类的内部调整子视图位置时，需要调用；如果你想要在外部设置subviews的位置，就不要重写。</code></pre><h2 id="三、sizeToFit"><a href="#三、sizeToFit" class="headerlink" title="三、sizeToFit"></a>三、<code>sizeToFit</code></h2><p>调用sizeToFit的时候，系统会根据内容的帮我布局一个它认为最合适的大小。</p><p>我们一般在不方便手动布局的时候才调用sizeToFit方法。比如</p><ol><li><p>navigationBar中对navigationItem的设置，（添加两个视图以上的控件到Item）</p></li><li><p>toolBar中的对UIBarButtonItem的设置（一般我们还要添加弹簧控件）</p></li></ol><p>上述两种场合就可以用sizeToFit这个方法，来让系统给我们做自动布局。（注意：如果就添加一个控件的话，我们直接设置fram也是可以的）</p><ol start="3"><li><p>在tabBar中我们不能手动的添加的子控件，因为tabBar是根据控制器系统默认自动添加的tabBarItem。（猜想系统可能也会自动调用了这个方法）</p></li><li><p>UILabel中添加文字，然后让调整label的大小来适应文字，我们也调用sizeToFit的方法。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS调试内存泄露</title>
      <link href="/2016/10/18/iOS%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2016/10/18/iOS%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Xcode8使用Memory-Graph"><a href="#Xcode8使用Memory-Graph" class="headerlink" title="Xcode8使用Memory Graph"></a>Xcode8使用Memory Graph</h1><ul><li><p>第一步：真机下运行APP后，点击<br><img src="https://upload-images.jianshu.io/upload_images/1120923-296131fcf6ffee5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第二步：查看issue面板，注意选择右边Runtime<br><img src="https://upload-images.jianshu.io/upload_images/1120923-8ee8fe78474da0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第三步：查看可能出现的内存泄露<br>比如上图的 <code>1 instance of __NSMallocBlock_leaked</code>，点击后出现下图<br><img src="https://upload-images.jianshu.io/upload_images/1120923-7765184c6159e657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>原因在于如下代码</p><pre><code>group.didSelectedRowBlock = { [unowned self, group] row inguard let indexPaths = group.selectedIndexPaths else {return}if indexPaths.count &gt; 0 {self.shouldAdd = truelet row = (indexPaths.firstObject as! IndexPath).rowself.deviceAttri?.attrValue = String(row)} else {self.shouldAdd = false}}</code></pre><p>group的block中又使用了group，导致了循环引用，虽然使用了[unowned group]，事实证明并没有效果<br>最后的解决办法是修改didSelectedRowBlock的接口，直接将selectedIndexPaths参数传入block参数中:</p><pre><code>group.didSelectedRowBlock = { [unowned self] indexPaths inguard let indexPaths = indexPaths else {return}if indexPaths.count &gt; 0 {self.shouldAdd = trueself.deviceAttri?.attrValue = String(indexPaths.first!.row)} else {self.shouldAdd = false}}</code></pre></li><li>第四步：在 debug 页面查看内存泄露情况<br><img src="https://upload-images.jianshu.io/upload_images/1120923-5d076268da519675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>有叹号说明需要注意可能存在内存泄露，可以看到 CoreFoundation中也可能存在内存泄露情况</li></ul><h1 id="使用Instruments的Leaks工具"><a href="#使用Instruments的Leaks工具" class="headerlink" title="使用Instruments的Leaks工具"></a>使用Instruments的Leaks工具</h1><h2 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a><code>Time Profiler</code></h2><ul><li>查看多个线程里那些方法费时过多的方法</li><li>Call Tree上会默认按照费时的线程进行排序，单个线程中会也会按照对应的费时方法排序<br><img src="https://upload-images.jianshu.io/upload_images/1120923-b7b30c7aedac7d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h2 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a><code>Allocations</code></h2><ul><li>可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置</li><li>具体操作</li></ul><ol><li>在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，</li><li>切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，</li><li>这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。</li></ol><h2 id="Leak"><a href="#Leak" class="headerlink" title="Leak"></a>Leak</h2><p>可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的<code>Statistics&gt;Allocation Summary</code>能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。</p><h1 id="其他调试方法"><a href="#其他调试方法" class="headerlink" title="其他调试方法"></a>其他调试方法</h1><h2 id="勾选Address-Sanitizer可以在运行时看到坏内存访问情况"><a href="#勾选Address-Sanitizer可以在运行时看到坏内存访问情况" class="headerlink" title="勾选Address Sanitizer可以在运行时看到坏内存访问情况"></a>勾选<code>Address Sanitizer</code>可以在运行时看到坏内存访问情况</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-a6440da959e589ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用WireShark 调试真机网络</title>
      <link href="/2016/10/09/%E4%BD%BF%E7%94%A8WireShark-%E8%B0%83%E8%AF%95%E7%9C%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2016/10/09/%E4%BD%BF%E7%94%A8WireShark-%E8%B0%83%E8%AF%95%E7%9C%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="使用WireShark-调试真机网络"><a href="#使用WireShark-调试真机网络" class="headerlink" title="使用WireShark 调试真机网络"></a>使用WireShark 调试真机网络</h1><p>需求：调试UIWebView加载缓慢问题</p><ul><li><ol><li>获取iPhone的UDID<br><img src="https://upload-images.jianshu.io/upload_images/1120923-d7d6872480927c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol></li><li><p>2：根据获取的 UDID 创建一个虚拟的网卡<br><code>rvictl -s &lt;UDID&gt;</code><br><img src="https://upload-images.jianshu.io/upload_images/1120923-f7f78d28cb94eda6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>通过 <code>ifconfig</code> 可以看到多了一个 <code>rvi0</code>接口<br>通过 <code>rvictl -l</code> 命令可以列出所有挂接的虚拟接口</p><ul><li>3: 在 Wireshark 首页选择 rvi0，使用默认的 Capture Options 即可开始对 iPhone 进行抓包。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-602c6eb7b8e0f13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>其中 iPhone 手机连接 WiFi 动态获取的 IP 地址为 192.168.100.1。</p><blockquote><p>黑色的内容表示遇到错误，需要重点关注<br>关闭wifi，可以抓取移动网络数据包</p></blockquote><p>-4 ： 使用<code>rvictl  -x</code>命令删除虚拟接口, 使用 iPhone 的 UDID 作为参数。</p><h1 id="WireShark-抓包技巧"><a href="#WireShark-抓包技巧" class="headerlink" title="WireShark 抓包技巧"></a>WireShark 抓包技巧</h1><ul><li>第一步：找到请求网址的 IP 地址<br>方法一：用ping命令得到对应的IP地址（可能不对，此时要用方法二）<br><img src="https://upload-images.jianshu.io/upload_images/1120923-4ff29746a38a13a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>方法二：使用DNS包来确定IP地址</p><blockquote><p>注意手机上 DNS 解析的结果并不总是和电脑上的解析结果一致。这种情况下我们可以通过查看 DNS 数据包来确定<br>DNS 是基于 UDP 的协议，不会有 TCP 重传</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1120923-368232f0c1e87923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>第二步：过滤 IP 地址<br><img src="https://upload-images.jianshu.io/upload_images/1120923-78b3a639da943708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第三步：确定端口号<br><img src="https://upload-images.jianshu.io/upload_images/1120923-730d2741f957db51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>注意红框中的 <strong>SourcePort</strong>，这是客户端端口。我们知道 HTTP 支持并发请求，不同的并发请求肯定是占用不同的端口。所以在图中看到的上下两个数据包，并非一定是请求与响应的关系，他们可能属于两个不同的端口，彼此之间毫无关系，只是恰好在时间上最接近而已。</p><blockquote><p>如果只想显示某个端口的数据，可以使用:</p></blockquote><p><code>ip.addr == 220.194.203.68 and tcp.dstport == 52914</code></p><blockquote><p>如果只想看 HTTP 协议的 GET 请求与响应，可以使用 </p></blockquote><p><code></code>ip.addr == 220.194.203.68 and (http.request.method == “GET” || http.response.code == 200)<code></code>来过滤。</p><blockquote><p>如果想看丢包方面的数据，可以用 </p></blockquote><p><code>ip.addr == 220.194.203.68 and (tcp.analysis.fast_retransmission || tcp.analysis.retransmission)</code></p><p><code># 参考</code></p><p><a href="http://ios.jobbole.com/93159/" target="_blank" rel="noopener">http://ios.jobbole.com/93159/</a></p><p><a href="http://blog.csdn.net/phunxm/article/details/38590561" target="_blank" rel="noopener">http://blog.csdn.net/phunxm/article/details/38590561</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Objective-C 2.0》读书笔记</title>
      <link href="/2016/08/12/%E3%80%8AEffective-Objective-C-2-0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/08/12/%E3%80%8AEffective-Objective-C-2-0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="多用类型常量，少用-define"><a href="#多用类型常量，少用-define" class="headerlink" title="多用类型常量，少用 #define"></a>多用类型常量，少用 #define</h1><ol><li>对于局部常量(.m文件中)，</li></ol><ul><li>使用 static 声明表明变量只在本文件中可见，所以无需前缀</li><li>同时使用 static const 关键字与#define 效果相同，好处在于带有类型信息。<pre><code class="Objective-C">static const CGFloat kTopViewHeight = 40;</code></pre></li></ul><ol start="2"><li>对于全局常量</li></ol><ul><li>由于全局使用，使用类名做前缀</li><li>在 .h  文件中使用 extern 声明<pre><code class="Objective-C">extern NSString * const KKSlideTabBarBgColor;</code></pre></li><li>在 .m 文件中定义<pre><code class="Objective-C">NSString * const KKSlideTabBarBgColor = @&quot;name&quot;;</code></pre></li></ul><h1 id="NS-ENUM-与-NS-OPTIONS"><a href="#NS-ENUM-与-NS-OPTIONS" class="headerlink" title="NS_ENUM 与 NS_OPTIONS"></a>NS_ENUM 与 NS_OPTIONS</h1><ul><li>使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 可以指定底层数据类型，而且可以保证系统兼容</li><li>当多种状态可以互相组合时，使用 <code>NS_OPTIONS</code>，否则使用 <code>NS_ENUM</code></li><li>命名规则：前缀+状态</li></ul><pre><code class="Objective-C">typedef NS_ENUM(NSUInteger, GDFConnectionState) {GDFConnectionStateDisconnected,GDFConnectionStateConnecting,GDFConnectionStateConnected,};GDFConnectionStateDisconnected,GDFConnectionStateConnecting,GDFConnectionStateConnected,};typedef NS_OPTIONS(NSUInteger, GDFDirection) {GDFDirectionUp    = 1 &lt;&lt; 0,GDFDirectionDown  = 1 &lt;&lt; 1,GDFDirectionLeft  = 1 &lt;&lt; 2,GDFDirectionRight = 1 &lt;&lt; 3,};</code></pre><h1 id="消息转发-message-forwarding"><a href="#消息转发-message-forwarding" class="headerlink" title="消息转发 message forwarding"></a>消息转发 message forwarding</h1><p><img src="https://upload-images.jianshu.io/upload_images/1120923-6a0d3c614ab51b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e28856e7825cc2b7113288d11b2f1be6.png"></p><h1 id="动态方法解析-resolve-method"><a href="#动态方法解析-resolve-method" class="headerlink" title="动态方法解析 resolve method"></a>动态方法解析 resolve method</h1><ul><li>动态方法解析是消息转发的第一步，在这里处理，效率最高<br><code>@dynamic</code> 属性   使编译器不自动生成实例变量及存储方法<br>调用的方法：<br><code>`</code>Objective-C</li></ul><ul><li>(BOOL)resolveInstanceMethod:(SEL)selector<br><code>`</code></li></ul><p>代码参见：Runtime.md 动态方法解析 resolve method</p><h1 id="方法调配-method-swizzling"><a href="#方法调配-method-swizzling" class="headerlink" title="方法调配 method swizzling"></a>方法调配 method swizzling</h1><ol><li><p>作用1：在运行死交换两个方法的实现</p><pre><code class="Objective-C">// 根据方法名找到方法的实现class_getInstanceMethod(__unsafe_unretained Class cls, SEL name)// 交换两个方法的实现method_exchangeImplementations(Method m1, Method m2)</code></pre></li><li><p>作用2：为既有的方法实现添加新功能——调试黑盒方法，为完全不知道具体实现的方法添加日志功能<br><img src="https://upload-images.jianshu.io/upload_images/1120923-13947b19a51404ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fed427a97a343ee16f2c5edc37065689.png"></p></li></ol><pre><code class="Objective-C">@implementation NSString (EOC)+ (void)load {Method originalMethod = class_getInstanceMethod([NSString class],@selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class],@selector(eoc_myLowercaseString));method_exchangeImplementations(originalMethod, swappedMethod);}- (NSString *)eoc_myLowercaseString {NSString *lowercase = [self eoc_myLowercaseString];NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);return lowercase;}</code></pre><h1 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h1><pre><code class="Objective-C">// 对象结构体// isa 指针指向类对象struct objc_object {Class isa;};// 类结构体// 1. 这个结构存放类的元数据，实例中的方法，变量等信息就存储在类对象中// 2. isa 指针指向元类(metaclass)，元类描述类对象本身所具有的元数据，类方法就存储在元类中// 3. 每个类只有一个类对象，每个类对象只有一个元类typedef struct objc_class *Class;struct objc_class {Class isa;Class super_class;const char *name;long version;long info;long instance_size;struct objc_ivar_list *ivars;struct objc_method_list **methodLists;struct objc_cache *cache;struct objc_protocol_list *protocols;};</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-9a23d372be25f7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="f81c1ab1af0d8cee47e96db2568859d0.png"></p><h1 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h1><ol><li>苹果保留了两字符前缀，我们应该使用三字符前缀</li><li>C函数名应该加上前缀</li><li>头文件中的全局变量需要加上前缀</li><li>为私有方法名添加前缀（例如p_），用于区分哪些方法是私有的，哪些是公有的，私有方法可以随意改动，公有方法则要三思而后行。</li><li>为第三方类添加分类时，分类中的方法要增加前缀，可以避免覆盖原有方法。</li></ol><h1 id="使用段位缓存代理能否响应某个方法"><a href="#使用段位缓存代理能否响应某个方法" class="headerlink" title="使用段位缓存代理能否响应某个方法"></a>使用段位缓存代理能否响应某个方法</h1><ul><li>段位：结构体可以设置其成员所占的二进制位数<pre><code class="Objective-C">struct {unsigned int fieldA : 8; // fieldA 占 8 个二进制位，即 0 ~ 255unsigned int fieldB : 4;unsigned int fieldC : 2;unsigned int fieldD : 1;}_delegateFlag;</code></pre></li><li>实例：<br><code>`</code>Objective-C<br>@protocol KKSlideTabBarViewDelegate <nsobject><br>@optional;</nsobject></li><li>(void)slideTabBarView:(KKSlideTabBarView *)tabBar pageChangedFromIndex:(NSUInteger)from toIndex:(NSUInteger)to;</li><li>(void)slideTabBarView:(KKSlideTabBarView <em>)tabBar itemMoreClicked:(UIButton </em>)itemMore;<br>@end<br>@interface KKSlideTabBarView : UIView<br>@property (nonatomic,weak) id <kkslidetabbarviewdelegate> delegate;<br>@end<br><code></code>Objective-C<br>@implementation KKSlideTabBarView {<br>struct {<br>unsigned int didPageChangedHandle    : 1;<br>unsigned int didItemMoreClickdHandle : 1;<br>}_delegateFlags;<br>}</kkslidetabbarviewdelegate></li><li>(void)setDelegate:(id<kkslidetabbarviewdelegate>)delegate {<br>_delegate = delegate;<br>_delegateFlags.didPageChangedHandle = [self.delegate respondsToSelector:@selector(slideTabBarView:pageChangedFromIndex:toIndex:)];<br>_delegateFlags.didItemMoreClickdHandle = [self.delegate respondsToSelector:@selector(itemMoreClicked:)];</kkslidetabbarviewdelegate></li></ul><p>}</p><pre><code>```Objective-C- (void)itemMoreClicked:(UIButton *)sender{if (_delegateFlags.didItemMoreClickdHandle) {[self.delegate slideTabBarView:self itemMoreClicked:sender];}}}</code></pre><h1 id="NSOperation-与-GCD-优缺点"><a href="#NSOperation-与-GCD-优缺点" class="headerlink" title="NSOperation 与  GCD 优缺点"></a>NSOperation 与  GCD 优缺点</h1><ul><li>GCD 优点：纯 C api，更加轻量级。而operation 是对象，更加重量级</li><li>NSOperation 优点：</li></ul><ol><li>操作加入队列后可以取消（已经启动的任务无法取消）</li><li>可以自动操作之间的依赖关系</li><li>可以使用 KVO 监控 NSOperation 对象的属性，比如通过 isCancelled 判断任务是否取消， isFinished 属性判断任务是否完成</li><li>可以指定每个操作的优先级，而 GCD 只能指定队列的优先级</li><li>可以自定义 operation 对象</li></ol><h1 id="使用-NSCache-和-NSPurgeableData-缓存数据"><a href="#使用-NSCache-和-NSPurgeableData-缓存数据" class="headerlink" title="使用 NSCache 和 NSPurgeableData 缓存数据"></a>使用 NSCache 和 NSPurgeableData 缓存数据</h1><ul><li>只有费时操作才值得放入缓存，比如需要从网络获取的数据、从磁盘读取的数据<br><code>`</code>Objective-C<br>@interface KKSlideTabBarViewController ()<br>{<br>NSCache *_cache;<br>}<br>@end</li></ul><p>_cache = [NSCache new];<br>_cache.countLimit = 100;<br>_cache.totalCostLimit = 5 <em> 1024 </em> 1024;</p><p>NSPurgeableData *cacheData = [_cacheobjectForKey:@”url…”];<br>if (cacheData) {<br>// stop the data being purged<br>[cacheData beginContentAccess];</p><p>// 使用数据<br>// ……</p><p>// Mark that the data may be purged again<br>[cacheData endContentAccess];<br>} else {<br>NSData <em>data = [NSData dataWithContentsOfURL:@”xxx”];<br>NSPurgeableData </em>purgeableData = [NSPurgeableData dataWithData:data];<br>[_cache setObject:purgeableData<br>forKey:@”url…”<br>cost:data.length];</p><p>// With access already maked</p><p>// user data<br>// …..</p><p>// Mark that the data may be purged now<br>[purgeableData endContentAccess];<br>}</p><pre><code># 精简 + load 与 + initialize 方法它们都是在类载入系统时由运行时系统调用，不能手动调用。`+ load` 方法:在类加载时调用。系统会先调用父类的 load 再调用子类的 load，先调用类本身 load，再调用 categery load。在 load 方法中，运行时系统处于脆弱状态，不能确定其他类是否加载完毕。不能在 load 方法中使用其他类对象，因为无法知道这个类是否加载了。`+ initialize` 方法`+ initialize` 方法是惰性加载，使用到类时才会调用。`+ initialize` 方法调用时，系统处于正常状态，可以在 + initialize 方法中使用其他类对象。`+ initialize` 方法一定会在线程安全的环境中执行，那么执行 + initialize 方法时会阻塞其他线程如果子类没有实现 + initialize 方法，而父类实现了，那么会调用夫类的。所以应该这么实现：```Objective-C+ (void)initialize{if (self == [KKSlideTabBarView class]) {// 只有当 KKSlideTabBarView 类载入系统时才执行这里的代码// 不然的话 KKSlideTabBarView 的父类载入系统也会调用 initialize}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD用法全解</title>
      <link href="/2016/08/02/GCD%E7%94%A8%E6%B3%95%E5%85%A8%E8%A7%A3/"/>
      <url>/2016/08/02/GCD%E7%94%A8%E6%B3%95%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="dispatch-time与dispatch-walltime的区别"><a href="#dispatch-time与dispatch-walltime的区别" class="headerlink" title="dispatch_time与dispatch_walltime的区别"></a><code>dispatch_time</code>与<code>dispatch_walltime</code>的区别</h1><p>所有定时器dispatch source都是间隔定时器，一旦创建，会按你指定的间隔定期递送事件。<br>当计算机睡眠时，定时器dispatch source会被挂起，稍后系统唤醒时，定时器dispatch source也会自动唤醒。<br>定时器dispatch source会使用系统默认时钟来确定何时触发，但是默认时钟在计算机睡眠时不会继续。</p><p>如果你使用 dispatch_walltime 函数来设置定时器dispatch source，则定时器会根据挂钟时间来跟踪，<br>这种定时器比较适合触发间隔相对比较大的场合，可以防止定时器触发间隔出现太大的误差。</p><p>区别：</p><ol><li><p><code>dispatch_time_t</code>类型的时间我们可以通过<code>dispatch_time</code>来创建，也可以通过<code>dispatch_walltime</code>来创建。<br><code>dispatch_time</code>创建的时间多以第一个参数为参照物，之后过多久执行任务。<br><code>dispatch_walltime</code>多用于创建绝对时间，如某年某月某日某时某分执行某任务，比如闹钟的设置。</p></li><li><p><code>dispatch_time</code>在计算机睡眠时会停止<br><code>dispatch_walltime</code>不会</p></li></ol><p>例如以下情景</p><p>情景：希望一小时后执行任务，5分钟后计算机进入睡眠<br>操作：50分钟后唤醒计算机<br>实际：使用<code>dispatch_walltime</code>时: 5分钟后开始执行<br>使用<code>dispatch_time</code>: 55分钟后开始执行</p><h1 id="GCD-定时器的使用"><a href="#GCD-定时器的使用" class="headerlink" title="GCD 定时器的使用"></a>GCD 定时器的使用</h1><h2 id="dispatch-source-set-timer-最后一个参数-leeway-详解"><a href="#dispatch-source-set-timer-最后一个参数-leeway-详解" class="headerlink" title="dispatch_source_set_timer 最后一个参数 leeway 详解"></a><code>dispatch_source_set_timer</code> 最后一个参数 <code>leeway</code> 详解</h2><ul><li><code>leeway</code> 这个参数告诉系统我们需要计时器触发的精准程度。所有的计时器都不会保证100%精准，这个参数用来告诉系统你希望系统保证精准的努力程度。如果你希望一个计时器没五秒触发一次，并且越准越好，那么你传递0为参数。</li><li>如果是一个周期性任务，比如检查email，那么你会希望每十分钟检查一次，但是不用那么精准。所以你可以传入60，告诉系统60秒的误差是可接受的。  </li><li>这样有什么意义呢？——降低资源消耗。如果系统可以让cpu休息足够长的时间，并在每次醒来的时候执行一个任务集合，而不是不断的醒来睡去以执行任务，那么系统会更高效。如果传入一个比较大的leeway给你的计时器，意味着你允许系统拖延你的计时器来将计时器任务与其他任务联合起来一起执行。</li></ul><pre><code class="Objective-C">    dispatch_queue_t mainQueue = dispatch_get_main_queue();    NSTimeInterval interval = 1.0f;    NSTimeInterval delay = 1.0f;    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, mainQueue);    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, delay), interval * NSEC_PER_SEC, 1.0 * NSEC_PER_SEC);    dispatch_source_set_event_handler(timer, ^{        NSLog(@&quot;%s&quot;, __func__);    });    dispatch_resume(timer);    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{        dispatch_source_cancel(timer);    });</code></pre><h2 id="测试代码执行效率"><a href="#测试代码执行效率" class="headerlink" title="测试代码执行效率"></a>测试代码执行效率</h2><pre><code class="Objective-C">func testPerformance(closure: ()-&gt;()) {    let startTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0)    closure()    let endTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0)    print(endTime - startTime)} func testFunctionPerformance(selector: Selector) {    let startTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0)    self.performSelector(selector)    let endTime: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, 0)    print(endTime - startTime)}</code></pre><h1 id="GCD-加锁"><a href="#GCD-加锁" class="headerlink" title="GCD 加锁"></a>GCD 加锁</h1><h2 id="GCD-信号量的使用"><a href="#GCD-信号量的使用" class="headerlink" title="GCD 信号量的使用"></a>GCD 信号量的使用</h2><ol><li>设置信号量的个数为1时，可以当锁来使用</li><li>设置信号量的个数与CPU个数相近时（比如CPU个数 * 2），可以用来限制线程个数。</li></ol><pre><code class="Objective-C">var semaphore: dispatch_semaphore_t = dispatch_semaphore_create(1)//MARK: ------------------- 使用信号量进行加锁操作 --------------------func test_semaphore() {    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in  self.tast_first()    }    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in  self.tast_second()    }    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in  self.tast_third()    }} func tast_first() {    // p操作，进入临界区      dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER)    print(&quot;First tast starting&quot;)    sleep(1)    NSLog(&quot;%@&quot;, &quot;First task is done&quot;)    // v操作，离开临界区      dispatch_semaphore_signal(self.semaphore)} func tast_second() {    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER)    print(&quot;Second tast starting&quot;)    sleep(1)    NSLog(&quot;%@&quot;, &quot;Second task is done&quot;)    dispatch_semaphore_signal(self.semaphore)} func tast_third() {    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER)    print(&quot;Third tast starting&quot;)    sleep(1)    NSLog(&quot;%@&quot;, &quot;Thrid task is done&quot;)    dispatch_semaphore_signal(self.semaphore)}</code></pre><h1 id="使用信号量控制多线程中代码执行顺序"><a href="#使用信号量控制多线程中代码执行顺序" class="headerlink" title="使用信号量控制多线程中代码执行顺序"></a>使用信号量控制多线程中代码执行顺序</h1><pre><code class="Objective-C">- (void)test_dispatch_semaphore_t_0 {    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{        [self method1];        sleep(10);        dispatch_semaphore_signal(semaphore);    });    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);    [self method2];}</code></pre><h1 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h1><pre><code class="Objective-C">//MARK: ------------------- dispatch_after 的使用-------------------- func dispatchAfter() {    let delay: dispatch_time_t = dispatch_time(DISPATCH_TIME_NOW, Int64(5 * Double(NSEC_PER_SEC)))    dispatch_after(delay, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { () -&gt; Void in  print(&quot;viewDidLoad()&quot;)    }}# GCD 多任务异步执行与 `dispatch_notify` 的使用```Objective-C//MARK: ------------------- 多任务异步执行 与 dispatch_group_notify 的使用 -------------------- func dispatchGroup() {    let group: dispatch_group_t = dispatch_group_create()    let globalQueueDefault: dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)    // 串行队列按照先进先出的顺序执行（FIFO）          let userQueueSerie: dispatch_queue_t = dispatch_queue_create(&quot;com.dispatchGroup.demo&quot;, DISPATCH_QUEUE_SERIAL)    // 下载任务1         dispatch_group_async(group, userQueueSerie){        sleep(3)        NSLog(&quot;Task1 is done&quot;)    }    // 下载任务2         dispatch_group_async(group, userQueueSerie){        sleep(3)        NSLog(&quot;Task2 is done&quot;)    }    // 下载任务3         dispatch_group_async(group, globalQueueDefault){        sleep(3)        NSLog(&quot;Task3 is done&quot;)    }    // 监听任务组事件的执行完毕          dispatch_group_notify(group, dispatch_get_main_queue()){        NSLog(&quot;Group tasks are done&quot;)    }    // 设置等待时间(即设置超时)，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败          // 等待直到完成          let result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER)    if (result != 0) {        print(&quot;Now viewDidLoad is done&quot;)    }}# dispatch_group_apply```Objective-C//MARK: ------------------- 多任务异步执行/同步执行 与 dispatch_apply 的使用 -------------------- func dispatchApply() {    let iterations: Int = 20 // 迭代次数          let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)    // 同步执行          self.testPerformance { () -&gt; () in          dispatch_apply(iterations, globalQueue) { (index: Int) -&gt;             Void in  print(index, NSThread.currentThread())        }        NSLog(&quot;iterations is over&quot;)    }    print(&quot;------------------------------------&quot;)    // 异步执行          self.testPerformance { () -&gt; () in          dispatch_apply(iterations, globalQueue, { (index: Int) -&gt; Void in              dispatch_async(globalQueue, { () -&gt; Void in                  print(index, NSThread.currentThread())            })        })        NSLog(&quot;iterations is over&quot;)    }    print(&quot;------------------------------------&quot;)    self.testPerformance { () -&gt; () in          for i:Int in 1...iterations {            print(i, NSThread.currentThread())        }    }}</code></pre><h1 id="dispatch-group-enter-dispatch-group-leave"><a href="#dispatch-group-enter-dispatch-group-leave" class="headerlink" title="dispatch_group_enter / dispatch_group_leave"></a><code>dispatch_group_enter</code> / <code>dispatch_group_leave</code></h1><pre><code class="Objective-C">//MARK: ------------------- dispatch_group_enter / dispatch_group_leave -------------------// 将任务组中的任务未执行完毕的任务数目加减1，这种方式不使用 dispatch_group_async 来提交任务， // 注意：这两个函数要配合使用，有enter要有leave，这样才能保证功能完整实现。    // 串行执行三个任务  func dispatchGroup_EnterAndLeave_Seriel() {    let group = dispatch_group_create()    for index:UInt32 in 1...3{        dispatch_group_enter(group)//提交了一个任务，任务数目加1                manualDownLoad(index){            print(&quot;Task \(index) is done&quot;)            dispatch_group_leave(group)//完成一个任务，任务数目减1 }        }    }     func manualDownLoad(num: UInt32, block:()-&gt;()){        print(&quot;Downloading task &quot;, num)        sleep(num)        block()    }     // 并行执行三个任务      func dispatchGroup_EnterAndLeave_Concurrent() {        let group = dispatch_group_create()//创建group            let globalQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0)        for index:UInt32 in 1...3 {            dispatch_group_enter(group)//提交了一个任务，任务数目加1                    manualDownLoad(index, queue: globalQueueDefault){            NSLog(&quot;Task\(index) is done&quot;)            dispatch_group_leave(group)//完成一个任务，任务数目减1 }        }    }     func manualDownLoad(num: UInt32, queue:dispatch_queue_t, block:()-&gt;()){        dispatch_async(queue){            NSLog(&quot;Downloading task\(num)&quot;)            sleep(num)            block()        }    }</code></pre><h1 id="GCD-实战：资源竞争"><a href="#GCD-实战：资源竞争" class="headerlink" title="GCD 实战：资源竞争"></a>GCD 实战：资源竞争</h1><pre><code class="Objective-C">//MARK: ------------------- 多线程测试：资源竞争 -------------------- func test_mutiThread() {        let userSerialQueue = dispatch_queue_create(&quot;com.test.mutiThread.userSerialQueue&quot;, DISPATCH_QUEUE_SERIAL)        let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)        let group = dispatch_group_create()        // 当 &quot;Processing data&quot;（CUP处理速度） 速度远小于 &quot;Reading file&quot;（磁盘处理速度） 速度时，线程数占用过多          // 使用信号量来限制同时执行的任务的数量                 let cupCount = NSProcessInfo.processInfo().processorCount // CPU 数量        let jobSemaphore = dispatch_semaphore_create(cupCount * 2) // 限制线程个数        for i:Int in 1...50 {            dispatch_semaphore_wait(jobSemaphore, DISPATCH_TIME_FOREVER);            dispatch_group_async(group, userSerialQueue, { () -&gt; Void in  print(&quot;Reading file&quot;, i, NSThread.currentThread())                // sleep(2)                                dispatch_group_async(group, globalQueue, { () -&gt; Void in  print(&quot;  Processing data&quot;, i, NSThread.currentThread())                    sleep(1)                    dispatch_group_async(group, userSerialQueue, { () -&gt; Void in  print(&quot;    writing file&quot;, i, NSThread.currentThread())                        // sleep(2)                                                dispatch_semaphore_signal(jobSemaphore);                    })                })            })        }        dispatch_group_wait(group, DISPATCH_TIME_FOREVER)    }</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.jianshu.com/p/6670cdbb1ebb" target="_blank" rel="noopener">http://www.jianshu.com/p/6670cdbb1ebb</a><br><a href="http://www.dreamingwish.com/article/gcd-practice-io-race.html" target="_blank" rel="noopener">http://www.dreamingwish.com/article/gcd-practice-io-race.html</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods 管理私有库</title>
      <link href="/2016/06/09/CocoaPods-%E7%AE%A1%E7%90%86%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/2016/06/09/CocoaPods-%E7%AE%A1%E7%90%86%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、创建私有-Cocoapod-Spec-Repo-仓库"><a href="#一、创建私有-Cocoapod-Spec-Repo-仓库" class="headerlink" title="一、创建私有 Cocoapod Spec Repo 仓库"></a>一、创建私有 <code>Cocoapod Spec Repo</code> 仓库</h1><p><code>Spec Repo</code> 是所有 pod 的索引，自己创建的私有 pod 库都将放在这里</p><ol><li>创建一个空的私有 <code>Cocoapod Spec Repo</code> 的远程 git 仓库</li><li>执行命令<br><code>pod repo add KSSpecPods https://coding.net/u/action456789/p/KSSpecPods.git</code></li><li>查看是否创建成功<br>进入到<code>~/.cocoapods/repos</code>目录下，如果看到 <code>KSSpecPods</code> ，说明创建成功</li></ol><h1 id="二、创建需要放入-Cocoapod-Spec-Repo-仓库进行管理的私有库"><a href="#二、创建需要放入-Cocoapod-Spec-Repo-仓库进行管理的私有库" class="headerlink" title="二、创建需要放入 Cocoapod Spec Repo 仓库进行管理的私有库"></a>二、创建需要放入 Cocoapod Spec Repo 仓库进行管理的私有库</h1><h2 id="创建全新的私有库时"><a href="#创建全新的私有库时" class="headerlink" title="创建全新的私有库时"></a>创建全新的私有库时</h2><ol><li><p>创建私有库的远程 git 仓库</p></li><li><p>创建本地私有库<br><code>pod lib create podTestLibrary</code></p></li><li><p>关联本地私有库与远程仓库，并打上版本号，然后推送到远程 git 仓库<br><code>git tag -m &quot;first release&quot; 0.1.0</code><br><code>git push --tags     #推送tag到远端仓库</code></p></li><li><p>编辑<code>podspec</code>文件<br>例如：<br><code>`</code><br>Pod::Spec.new do |s|<br>s.name             = ‘TAFNetwork’<br>s.version          = ‘0.1.0’<br>s.summary          = ‘Just Testing.’</p></li></ol><p>s.description      = &lt;&lt;-DESC<br>Testing Private Podspec.</p><ul><li>Markdown format.</li><li>Don’t worry about the indent, we strip it!<br>DESC</li></ul><p>s.homepage         = ‘<a href="https://github.com/action456789/CocoapodsPrivateLibTest&#39;" target="_blank" rel="noopener">https://github.com/action456789/CocoapodsPrivateLibTest&#39;</a>                           #主页,这里要填写可以访问到的地址，不然验证不通过</p><h1 id="s-screenshots-‘www-example-com-screenshots-1-39-‘www-example-com-screenshots-2-39-截图"><a href="#s-screenshots-‘www-example-com-screenshots-1-39-‘www-example-com-screenshots-2-39-截图" class="headerlink" title="s.screenshots     = ‘www.example.com/screenshots_1&#39;, ‘www.example.com/screenshots_2&#39;      #截图"></a>s.screenshots     = ‘<a href="http://www.example.com/screenshots_1&#39;" target="_blank" rel="noopener">www.example.com/screenshots_1&#39;</a>, ‘<a href="http://www.example.com/screenshots_2&#39;" target="_blank" rel="noopener">www.example.com/screenshots_2&#39;</a>      #截图</h1><p>s.license          = ‘MIT’                                                                  #开源协议<br>s.author           = { ‘kesen’ =&gt; <a href="mailto:&#39;317331820@qq.com" target="_blank" rel="noopener">&#39;317331820@qq.com</a>‘ }</p><p>s.source           = { :git =&gt; ‘<a href="https://github.com/action456789/CocoapodsPrivateLibTest.git&#39;" target="_blank" rel="noopener">https://github.com/action456789/CocoapodsPrivateLibTest.git&#39;</a>, :tag =&gt; s.version}   #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</p><h1 id="s-social-media-url-‘https-twitter-com-lt-TWITTER-USERNAME-gt-’-多媒体介绍地址"><a href="#s-social-media-url-‘https-twitter-com-lt-TWITTER-USERNAME-gt-’-多媒体介绍地址" class="headerlink" title="s.social_media_url = ‘https://twitter.com/&lt;TWITTER_USERNAME&gt;’                             #多媒体介绍地址"></a>s.social_media_url = ‘<a href="https://twitter.com/" target="_blank" rel="noopener">https://twitter.com/</a>&lt;TWITTER_USERNAME&gt;’                             #多媒体介绍地址</h1><p>s.platform     = :ios, ‘7.0’                  #支持的平台及版本<br>s.requires_arc = true                         #是否使用ARC，如果指定具体文件，则具体的问题使用ARC</p><p>s.source_files = ‘TAFNetwork/Classes/<strong>/*’    #代码源文件地址，</strong>/*表示Classes目录及其子目录下所有文件，</p><h1 id="s-resource-bundles-资源文件地址"><a href="#s-resource-bundles-资源文件地址" class="headerlink" title="s.resource_bundles = {                                      #资源文件地址"></a>s.resource_bundles = {                                      #资源文件地址</h1><h1 id="‘TAFNetwork’-gt-‘TAFNetwork-Assets-png’"><a href="#‘TAFNetwork’-gt-‘TAFNetwork-Assets-png’" class="headerlink" title="‘TAFNetwork’ =&gt; [‘TAFNetwork/Assets/*.png’]"></a>‘TAFNetwork’ =&gt; [‘TAFNetwork/Assets/*.png’]</h1><h1 id=""><a href="#" class="headerlink" title="}"></a>}</h1><p>s.public_header_files = ‘TAFNetwork/Classes/<strong>/*.h’          #NAME_OF_POD/Classes/</strong>/*’，公开头文件地址<br>s.frameworks = ‘UIKit’                                       #所需的framework，多个用逗号隔开</p><h1 id="s-dependency-‘CocoaAsyncSocket’-‘-gt-7-5-0’"><a href="#s-dependency-‘CocoaAsyncSocket’-‘-gt-7-5-0’" class="headerlink" title="s.dependency ‘CocoaAsyncSocket’, ‘~&gt; 7.5.0’"></a>s.dependency ‘CocoaAsyncSocket’, ‘~&gt; 7.5.0’</h1><h1 id="s-dependency-‘FMDB’-‘-gt-2-5’"><a href="#s-dependency-‘FMDB’-‘-gt-2-5’" class="headerlink" title="s.dependency ‘FMDB’, ‘~&gt; 2.5’"></a>s.dependency ‘FMDB’, ‘~&gt; 2.5’</h1><h1 id="s-dependency-‘Reachability’-‘-gt-3-2’"><a href="#s-dependency-‘Reachability’-‘-gt-3-2’" class="headerlink" title="s.dependency ‘Reachability’, ‘~&gt; 3.2’"></a>s.dependency ‘Reachability’, ‘~&gt; 3.2’</h1><h1 id="s-dependency-‘SAMKeychain’-‘-gt-1-5-2’"><a href="#s-dependency-‘SAMKeychain’-‘-gt-1-5-2’" class="headerlink" title="s.dependency ‘SAMKeychain’, ‘~&gt; 1.5.2’"></a>s.dependency ‘SAMKeychain’, ‘~&gt; 1.5.2’</h1><p>end</p><pre><code>5. 验证`podspec`执行 `pod lib lint`## 私有库项目已经存在时1. 创建 `podspec` 文件`pod spec create PodTestLibrary git@coding.net:wtlucky/podTestLibrary.git`2. 验证`podspec`执行 `pod lib lint`# 三、本地测试podspec文件1）新建一个项目，在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。 在Podfile中我们可以这样编辑，有两种方式</code></pre><p>pod ‘podTestLibrary’, :podspec =&gt; ‘/Users/kesen/Desktop/Repository/KSSpecPods/podTestLibrary/podTestLibrary.podspec’  # 指定podspec文件</p><h1 id="pod-‘podTestLibrary’-path-gt-‘-Users-kesen-Desktop-Repository-KSSpecPods’-指定路径"><a href="#pod-‘podTestLibrary’-path-gt-‘-Users-kesen-Desktop-Repository-KSSpecPods’-指定路径" class="headerlink" title="pod ‘podTestLibrary’, :path =&gt; ‘/Users/kesen/Desktop/Repository/KSSpecPods’      # 指定路径"></a>pod ‘podTestLibrary’, :path =&gt; ‘/Users/kesen/Desktop/Repository/KSSpecPods’      # 指定路径</h1><pre><code>2）安装依赖`pod install`# 四、提交私有库到私有 `Cocoapod Spec Repo` 仓库1. 进入私有库目录，执行`pod repo push KSSpecPods podTestLibrary.podspec`2. 进入`/Users/kesen/.cocoapods/KSSpecPods`查看是否提交成功# 五、私有制作好的私有库1）在 podfile 文件中加入代码</code></pre><p>pod ‘PodTestLibrary’, ‘~&gt; 0.1.0’<br><code>`</code><br>2）执行 <code>pod update</code><br>然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了</p><h1 id="六、更新私有库"><a href="#六、更新私有库" class="headerlink" title="六、更新私有库"></a>六、更新私有库</h1><p>参考<br><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="noopener">http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> cocoapods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何更新React Native</title>
      <link href="/2016/04/12/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0React-Native/"/>
      <url>/2016/04/12/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0React-Native/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最新的React Native已经更新到了0.33.0，如何更新自己已经搭建好的React Native开发环境呢，我按照以下步骤完成了更新，现记录下来，供有需要的人参考。</p></blockquote><h2 id="1-查看-react-native-的最新版本。"><a href="#1-查看-react-native-的最新版本。" class="headerlink" title="1.查看 react native 的最新版本。"></a>1.查看 react native 的最新版本。</h2><p>进入项目根目录，命令行执行<br><code>npm info react-native</code></p><p>查看当前版本<code>react-native --version</code></p><h2 id="2-在项目目录下修改package-json文件，将下列代码中的-react-native-改为最新版本"><a href="#2-在项目目录下修改package-json文件，将下列代码中的-react-native-改为最新版本" class="headerlink" title="2.在项目目录下修改package.json文件，将下列代码中的 react-native 改为最新版本"></a>2.在项目目录下修改<code>package.json</code>文件，将下列代码中的 react-native 改为最新版本</h2><pre><code>  &quot;dependencies&quot;: {      &quot;react&quot;: &quot;^0.14.8&quot;,      &quot;react-native&quot;: &quot;^0.33.0&quot;}</code></pre><h2 id="3-命令行执行"><a href="#3-命令行执行" class="headerlink" title="3. 命令行执行"></a>3. 命令行执行</h2><p><code>npm install --save react-native@0.33.0</code><br>如果升级后出现类似于<br><a href="mailto:`react-native@0.33.0" target="_blank" rel="noopener">`react-native@0.33.0</a> requires a peer of react@~15.3.1 but none was installed.`</p><p>执行<br><code>npm install --save react@~15.3.1</code></p><h2 id="4-运行程序"><a href="#4-运行程序" class="headerlink" title="4. 运行程序"></a>4. 运行程序</h2><p>如果更新后执行react-native run-android不能正确运行，而是出现类似：<br><code>Could not find com.facebook.react:react-native:0.23.0.</code><br>错误，或者在Android Studio中直接运行app时报错：<br><code>Android Studio failed to resolve com.facebook.react:react-native:0.23.0</code><br>那么可以按照下列命令修复，首先在命令行中执行：<br><code>npm i</code><br>执行完毕且不报错后，执行下面的命令，<strong>注意，在执行命令之后，某些文件可能会产生冲突，请确保你的本地文件记录可以恢复</strong>（在Android Studio中可以查看历史记录来恢复文件）<br><code>react-native upgrade</code><br>执行上面的命令可能会提示你是否覆盖文件。在解决冲突之后重新运行App即可。</p><h2 id="如果还有问题，可以更新一下npm和Node-js再试"><a href="#如果还有问题，可以更新一下npm和Node-js再试" class="headerlink" title="如果还有问题，可以更新一下npm和Node.js再试"></a>如果还有问题，可以更新一下npm和Node.js再试</h2><ul><li>如何更新npm<br><code>npm install -g npm</code></li><li>如何更新Node.js<br><code>npm update node.js</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
          <category> React-Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消除编译器警告</title>
      <link href="/2016/01/09/%E6%B6%88%E9%99%A4%E7%BC%96%E8%AF%91%E5%99%A8%E8%AD%A6%E5%91%8A/"/>
      <url>/2016/01/09/%E6%B6%88%E9%99%A4%E7%BC%96%E8%AF%91%E5%99%A8%E8%AD%A6%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="关闭-deprecated-declarations-警告"><a href="#关闭-deprecated-declarations-警告" class="headerlink" title="关闭 deprecated-declarations 警告."></a>关闭 <code>deprecated-declarations</code> 警告.</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程:"></a>基本流程:</h2><ol><li>push 当前警告入栈</li><li>忽略我们要消除的警告</li><li>执行会产生警告的代码</li><li>pop 警告出栈——恢复之前的状态<br><code>`</code>Objective-C<br>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored “-Wdeprecated-declarations”<br>/<em><br>要屏蔽掉deprecated警告的代码</em>/<br>#pragma clang diagnostic pop</li></ol><pre><code># 关闭 XCode8 `Convenience initializer missing a self call to....` 警告 ```Objective-C#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-designated-initializers&quot;/*要屏蔽掉deprecated警告的代码*/#pragma clang diagnostic pop</code></pre><h1 id="undeclared-selector警告"><a href="#undeclared-selector警告" class="headerlink" title="undeclared selector警告"></a><code>undeclared selector</code>警告</h1><pre><code class="Objective-C">#pragma clang diagnostic push#pragma clang diagnostic ignored&quot;-Wundeclared-selector&quot;//......#pragma clang diagnostic pop</code></pre><h1 id="Category-is-implementing-a-method-which-will-also-be-implemented-by-its-primary-class"><a href="#Category-is-implementing-a-method-which-will-also-be-implemented-by-its-primary-class" class="headerlink" title="Category is implementing a method which will also be implemented by its primary class"></a><code>Category is implementing a method which will also be implemented by its primary class</code></h1><p>当category重写类已有的方法时会出现此警告。</p><pre><code class="Objective-C">#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-protocol-method-implementation”//.....#pragma clang diagnostic pop</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS编译ffmpeg</title>
      <link href="/2015/11/06/iOS%E7%BC%96%E8%AF%91ffmpeg/"/>
      <url>/2015/11/06/iOS%E7%BC%96%E8%AF%91ffmpeg/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="iOS编译ffmpeg"><a href="#iOS编译ffmpeg" class="headerlink" title="iOS编译ffmpeg"></a>iOS编译ffmpeg</h1><p>参考<a href="http://www.jianshu.com/p/08107176d5bb" target="_blank" rel="noopener">http://www.jianshu.com/p/08107176d5bb</a></p><h2 id="1）-下载”一键编译”脚本"><a href="#1）-下载”一键编译”脚本" class="headerlink" title="1） 下载”一键编译”脚本"></a>1） 下载”一键编译”脚本</h2><p><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script" target="_blank" rel="noopener">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></p><h2 id="2）编译能在iOS下使用的FFMPEG-library库"><a href="#2）编译能在iOS下使用的FFMPEG-library库" class="headerlink" title="2）编译能在iOS下使用的FFMPEG library库"></a>2）编译能在iOS下使用的FFMPEG library库</h2><p>进入脚本目录，执行<br><code>./build-ffmpeg.sh</code></p><h2 id="3）在xcode中引入FFMPEG-library库"><a href="#3）在xcode中引入FFMPEG-library库" class="headerlink" title="3）在xcode中引入FFMPEG library库"></a>3）在xcode中引入FFMPEG library库</h2><p>新建工程，把上面编译好的FFmpeg-iOS拖到xcode工程中</p><p>编译后的文件夹中<br><code>ffmpeg-2.5.3</code> 是源码<br><code>FFmpeg-iOS</code> 是编译出来的库，里面有我们需要的.a静态库，一共有7个</p><p>执行<code>lipo -info libavcodec.a</code>，查看.a包支持的架构，这几个包都支持了<code>armv7 armv7s i386 x86_64 arm64</code>这几个架构，这个脚本果真是业界良心啊～～～</p><h2 id="4）加入依赖库"><a href="#4）加入依赖库" class="headerlink" title="4）加入依赖库"></a>4）加入依赖库</h2><p><code>libz.tbd</code> <code>libbz2.tbd</code> <code>libiconv.tbd</code>等<br><img src="https://upload-images.jianshu.io/upload_images/1120923-bccdc2e6176cb125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="78559964.png"></p><h2 id="5）为TARGETS-添加-search-paths"><a href="#5）为TARGETS-添加-search-paths" class="headerlink" title="5）为TARGETS 添加 search paths"></a>5）为TARGETS 添加 search paths</h2><p>项目根目录用 <code>$(SRCROOT)</code> 表示</p><ul><li>添加 Header Search Paths<br><code>$(inherited)</code><br><code>$(SRCROOT)/FfmpegDemo/FFmpeg-iOS/lib</code><br><img src="https://upload-images.jianshu.io/upload_images/1120923-8ee9a3eeed2d3909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="72612549.png"></li></ul><ul><li>添加 Library Search Paths （系统可能已经添加）<br><code>$(inherited)</code><br>`$(SRCROOT)/FfmpegDemo/FFmpeg-iOS/include<br><img src="https://upload-images.jianshu.io/upload_images/1120923-5217e7cf6a5fd309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="72413903.png"></li></ul><blockquote><p>如果编译不过（如缺少文件）一般都是search paths路径没写对</p></blockquote><h2 id="5）修改某个-m文件为-mm"><a href="#5）修改某个-m文件为-mm" class="headerlink" title="5）修改某个.m文件为.mm"></a>5）修改某个.m文件为.mm</h2><p>注意，不能是引入FFmpeg库的文件，否则编译不过</p><h2 id="6）引入头文件"><a href="#6）引入头文件" class="headerlink" title="6）引入头文件"></a>6）引入头文件</h2><pre><code>#include &quot;avformat.h&quot;</code></pre><p>如果编译成功，说明 search patchs 设置成功</p><h2 id="7）添加代码"><a href="#7）添加代码" class="headerlink" title="7）添加代码"></a>7）添加代码</h2><pre><code>#include &quot;avutil.h&quot;av_register_all();// 获取 ffmpeg 版本号const char *version = av_version_info();NSLog(@&quot;version: %s&quot;, version);</code></pre><p>执行成功说明集成成功</p><h1 id="各个CPU构架支持的设备"><a href="#各个CPU构架支持的设备" class="headerlink" title="各个CPU构架支持的设备"></a>各个CPU构架支持的设备</h1><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5a4d76d47a24e554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="68265767.png"></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KVO深入解析</title>
      <link href="/2015/10/24/KVO%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
      <url>/2015/10/24/KVO%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="iOS-中监听某个值的改变有哪些方法？"><a href="#iOS-中监听某个值的改变有哪些方法？" class="headerlink" title="iOS 中监听某个值的改变有哪些方法？"></a>iOS 中监听某个值的改变有哪些方法？</h1><p>在一个复杂的，有状态的系统中，当一个对象的状态发生改变，如何通知系统，并对状态改变做出相应的行为是必需考虑的一个问题，在iOS中为这类问题提供了4种解决方法： </p><ol><li>NSNotifiactaion 和 NSNotificationCenter：通知中心 </li><li>Delegates：代理， </li><li><p>Callback：回调， </p></li><li><p>KVO（Key-Value Observing）：键值观察 </p></li></ol><p>Key-Value Observing (简写为KVO)：当指定的对象的属性被修改了，允许对象接受到通知的机制。每次指定的被观察对象的属性被修改的时候，KVO都会自动的去通知相应的观察者。</p><h1 id="KVO-是什么？"><a href="#KVO-是什么？" class="headerlink" title="KVO 是什么？"></a>KVO 是什么？</h1><blockquote><blockquote><p>Objective-C 中的键(key)-值(value)观察(KVO)并不是什么新鲜事物，它来源于设计模式中的观察者模式，其基本思想就是：<br>一个目标对象管理所有依赖于它的观察者对象，并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。</p></blockquote></blockquote><h1 id="KVO-的用法"><a href="#KVO-的用法" class="headerlink" title="KVO 的用法"></a>KVO 的用法</h1><ol><li>如果要监听“对象A”属性值的改变，先要为＂对象A＂的属性注册观察者（假设观察者为“对象B”）。<br><code>`</code>Objective-C</li></ol><ul><li>(void)addObserver:(NSObject <em> _Nonnull)anObserver<br>forKeyPath:(NSString </em> _Nonnull)keyPath<br>options:(NSKeyValueObservingOptions)options<br>context:(void * _Nullable)context<br><code>`</code><br><code>anObserver</code> : 观察者，注册 KVO 通知的对象. 其必须实现方法 observeValueForKeyPath:ofObject:change:context:.<br><code>keyPath</code> : 被观察的属性，其不能为nil.<br><code>options</code> : 表示要监听那些通知，一般为写 0<br><code>context</code> : 一些其他的需要传递给观察者的上下文信息，通常设置为 nil</li></ul><p><code>options</code> 解释如下：<br><code>NSKeyValueObservingOptionNew</code> : change 字典中包含 key 改变后的新值<br><code>NSKeyValueObservingOptionOld</code> : change 字典中包含 key 改变前的旧值<br><code>NSKeyValueObservingOptionInitial</code> : 在添加观察者的时候立即发送一个通知给观察者,并且是在注册观察者方法返回之前<br><code>NSKeyValueObservingOptionPrior</code> : 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，这与-willChangeValueForKey:被触发的时间是相对应的。这样，在每次修改属性时，实际上是会发送两条通知。<br>２.　观察者“对象B”实现　<code>observeValueForKeyPath:ofObject:change:context:</code>.　方法<br>３.   “对象A”移除监听者　<code>- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath</code>;<br>另外注意：<code>keyPath</code> 即被观察的属性只能是 <code>NSString</code> 类型</p><ul><li>注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行</li></ul><h1 id="KVO-的实现原理"><a href="#KVO-的实现原理" class="headerlink" title="KVO 的实现原理"></a>KVO 的实现原理</h1><p>键值编码和键值观察是根据 isa-swizzling 技术来实现的，主要依据runtime的强大动态能力。<br>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法实现真正的通知机制。<br>同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。</p><ol><li>重写新类的 class 方法<br>重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。<br><code>`</code>Objective-C<br>//打印如下内容：<br>NSLog(@”self-&gt;isa:%@”,self-&gt;isa);<br>NSLog(@”self class:%@”,[self class]);</li></ol><p>//在建立KVO监听前，打印结果为：<br>self-&gt;isa:Person<br>self class:Person</p><p>//在建立KVO监听之后，打印结果为：<br>self-&gt;isa:NSKVONotifying_Person</p><p>self class:Person</p><pre><code>2. 重写新类的 set 方法新类会重写对应的set方法，是为了在set方法中增加另外两个方法的调用：```Objective-C- (void)willChangeValueForKey:(NSString *)key</code></pre><pre><code class="Objective-C">- (void)didChangeValueForKey:(NSString *)key</code></pre><p>其中，<code>didChangeValueForKey</code>:方法负责调用：</p><pre><code class="Objective-C">- (void)observeValueForKeyPath:(NSString *)keyPathofObject:(id)objectchange:(NSDictionary *)changecontext:(void *)context</code></pre><p>如果没有 setter 方法，那么 -setValue:forKey 方法会直接调用：</p><pre><code class="Objective-C">- (void)willChangeValueForKey:(NSString *)key</code></pre><pre><code class="Objective-C">- (void)didChangeValueForKey:(NSString *)key</code></pre><p>如果在没有使用键值编码且没有使用适当命名的访问起方法的时候，我们只需要显示调用上述两个方法，同样可以使用KVO！</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><pre><code class="Objective-C">////  ViewController.m//  KVO test////  Created by KeSen on 15/9/1.//  Copyright (c) 2015年 KeSen. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;KSBaby.h&quot;@interface ViewController (){KSBaby *_baby;}@end@implementation ViewController- (void)viewDidLoad {[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO];_baby = baby;// 一般如下使用// [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil];// 在 self 中监听 _baby 的 cry 属性变化[_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld| NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionPrior context:@&quot;ssss&quot;];}- (void)dealloc {[_baby removeObserver:self forKeyPath:@&quot;cry&quot;];}- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {NSLog(@&quot;keyPath: %@\n change: %@\n context: %@\n&quot;, keyPath, change, context);}- (IBAction)click:(UIButton *)sender {_baby.cry = @&quot;crying&quot;;}@end</code></pre><pre><code class="Objective-C">////  ViewController.m//  KVO test////  Created by KeSen on 15/9/1.//  Copyright (c) 2015年 KeSen. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;KSBaby.h&quot;@interface ViewController (){KSBaby *_baby;}@end@implementation ViewController- (void)viewDidLoad {[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO];_baby = baby;// 一般如下使用// [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil];// 在 self 中监听 _baby 的 cry 属性变化[_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld| NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionPrior context:@&quot;ssss&quot;];}- (void)dealloc {[_baby removeObserver:self forKeyPath:@&quot;cry&quot;];}- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {NSLog(@&quot;keyPath: %@\n change: %@\n context: %@\n&quot;, keyPath, change, context);}- (IBAction)click:(UIButton *)sender {_baby.cry = @&quot;crying&quot;;}@end</code></pre><p>那么：程序启动时输出：<br><img src="https://upload-images.jianshu.io/upload_images/1120923-cce04359a1bbfaad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><br></p><p>点击按钮后输出：<br><img src="https://upload-images.jianshu.io/upload_images/1120923-5ded44b80985ff8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6aeaf4e75e531bd372f4a322860cbf07.png"></p><h1 id="KVO与多线程"><a href="#KVO与多线程" class="headerlink" title="KVO与多线程"></a>KVO与多线程</h1><p>注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行</p><pre><code class="Objective-C">////  ViewController.m//  KVO test////  Created by KeSen on 15/9/1.//  Copyright (c) 2015年 KeSen. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;KSBaby.h&quot;#import &quot;FBKVOController.h&quot;@interface ViewController (){KSBaby *_baby;FBKVOController *_observer;}@end@implementation ViewController- (void)viewDidLoad {[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.KSBaby *baby = [[KSBaby alloc] initWithHungry:@&quot;cryed&quot; thirst:NO];_baby = baby;// NSKeyValueObservingOptionNew : change 字典中包含 key 改变后的新值// NSKeyValueObservingOptionOld : change 字典中包含 key 改变前的旧值// NSKeyValueObservingOptionInitial : 在添加观察者的时候立即发送一个通知给观察者,并且是在注册观察者方法返回之前// NSKeyValueObservingOptionPrior : 如果指定，则在每次修改属性时，会在修改通知被发送之前预先发送一条通知给观察者，这与-willChangeValueForKey:被触发的时间是相对应的。这样，在每次修改属性时，实际上是会发送两条通知。// 1. 一般用法如下[_baby addObserver:self forKeyPath:@&quot;cry&quot; options: 0 context: nil];//    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{//        [_baby addObserver:self forKeyPath:@&quot;cry&quot; options: NSKeyValueObservingOptionNew context:@&quot;ssss&quot;];////    });// 2. 第三方库 FBKVOController 的用法_observer = [[FBKVOController alloc] initWithObserver:self];[_observer observe:_baby keyPath:@&quot;cry&quot; options:NSKeyValueObservingOptionNew block:^(id observer, id object, NSDictionary *change) {NSLog(@&quot;%@, %@&quot;, @&quot;FBKVOController&quot;, change[NSKeyValueChangeNewKey]);}];}- (void)dealloc {[_baby removeObserver:self forKeyPath:@&quot;cry&quot;];}- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {NSLog(@&quot;%@&quot;, [NSThread currentThread]);NSLog(@&quot;keyPath: %@\n change: %@\n context: %@\n&quot;, keyPath, change, context);}- (IBAction)click:(UIButton *)sender {//    _baby.cry = @&quot;crying&quot;;// 1. 注意点：在哪个线程触发监听（修改了值），监听方法就会在哪个线程中执行dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{_baby.cry = @&quot;cry again&quot;;});}@end</code></pre><p>KVO 监听 NSMutableArray 的内容变化</p><ol><li>将数组封装到一个对象中</li><li>给这个对象添加 KVO 监听</li><li>使用  [self.arrayObject mutableArrayValueForKey:@”array”] 获取数组对象，对数组对象今天添加删除操作，只有这样触发的数组才会触发 kvo<br><img src="https://upload-images.jianshu.io/upload_images/1120923-22f9b36418f98970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06f37246739a3b062139a12c5070e044.png"></li></ol><p>参考：<a href="http://www.cppblog.com/kesalin/archive/2012/11/17/kvo.html" target="_blank" rel="noopener">http://www.cppblog.com/kesalin/archive/2012/11/17/kvo.html</a><br><a href="http://ningandjiao.iteye.com/blog/2009729" target="_blank" rel="noopener">http://ningandjiao.iteye.com/blog/2009729</a><br><a href="http://www.bkjia.com/IOSjc/993206.html" target="_blank" rel="noopener">http://www.bkjia.com/IOSjc/993206.html</a><br><a href="http://blog.csdn.net/wzzvictory/article/details/9674431" target="_blank" rel="noopener">http://blog.csdn.net/wzzvictory/article/details/9674431</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo GitHub博客搭建</title>
      <link href="/2015/09/09/Hexo-GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2015/09/09/Hexo-GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>1、安装<code>Node.js</code><br><a href="https://blog.csdn.net/u011619283/article/details/52368759" target="_blank" rel="noopener">https://blog.csdn.net/u011619283/article/details/52368759</a></p></li><li><p>2、安装hexo<br><code>npm install -g hexo-cli</code></p></li></ul><h1 id="本地站点搭建"><a href="#本地站点搭建" class="headerlink" title="本地站点搭建"></a>本地站点搭建</h1><ul><li><p>1、初始化 Hexo<br>进入自己创建的目录下<br><code>hexo init</code></p></li><li><p>2、生成静态页面<br><code>hexo generate</code></p></li><li><p>自动监视文件变化<br><code>hexo generate --watch</code></p></li><li><p>3、启动服务<br><code>hexo server</code></p></li><li><p>4、查看效果<br>打开浏览器，输入 <code>http://localhost:4000/</code></p></li></ul><h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h1><ul><li><p>1、创建仓库<br>仓库名称固定格式如下：<br><code>yourGitbubUsername.github.io</code><br>注意yourGitbubUsername必须与你的github用户名相同，否则无法部署</p></li><li><p>2、安装github部署器<br><code>npm install hexo-deployer-git –save</code></p></li><li><p>3、修改本地配置文件<code>_config.yml</code></p><pre><code>deploy:type: gitrepo: https://github.com/action456789/action456789.github.io.gitbranch: master</code></pre></li><li><p>4、部署<br><code>hexo generate</code><br><code>hexo deploy</code></p></li></ul><p>或者<br><code>hexo g -d</code></p><ul><li>5、测试<br>部署成功以后，在浏览器中输入 <a href="http://action456789.github.io" target="_blank" rel="noopener">http://action456789.github.io</a> 即可在线浏览自己的博客啦</li></ul><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p><a href="https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html（亲测可行）" target="_blank" rel="noopener">https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html（亲测可行）</a></p><blockquote><p>一定要创建CNAME文件，并且由于这种方式只支持单域名访问，CNAME文件中只有第一个域名会生效。</p></blockquote><h1 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h1><ul><li><p>直接去查找最流行的主题，github上有安装说明，这个是最靠谱的安装方法。</p></li><li><p>安装完成之后：<br>输入<code>hexo s --debug</code>进行测试</p><pre><code>hexo clean hexo generate hexo server (若是想本地预览和执行该命令预览) hexo deploy</code></pre></li></ul><h2 id="NexT主题官方文档"><a href="#NexT主题官方文档" class="headerlink" title="NexT主题官方文档"></a>NexT主题官方文档</h2><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p><h1 id="添加tag"><a href="#添加tag" class="headerlink" title="添加tag"></a>添加<code>tag</code></h1><p><code>hexo new page &quot;tags&quot;</code></p><h1 id="博客的创建、修改与删除"><a href="#博客的创建、修改与删除" class="headerlink" title="博客的创建、修改与删除"></a>博客的创建、修改与删除</h1><ul><li><p>1、创建新博客<br><code>hexo new &quot;test_blog&quot;</code></p></li><li><p>删除博客<br>删除博客文件后重新发布更新即可<br>可能需要等几分钟才有效果</p></li><li><p>2、发布更新</p><pre><code>hexo cleanhexo generatehexo deploy</code></pre></li><li><p>3、一些快捷键</p><pre><code>hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的时间</title>
      <link href="/2015/08/13/iOS%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4/"/>
      <url>/2015/08/13/iOS%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="设备开机后的时间"><a href="#设备开机后的时间" class="headerlink" title="设备开机后的时间"></a>设备开机后的时间</h1><ul><li><code>CACurrentMediaTime()</code></li></ul><p>设备从开机时起到现在的时间，设备重启会重置，单位为秒</p><ul><li><code>[[NSProcessInfo processInfo] systemUptime]</code> </li></ul><p>与<code>CACurrentMediaTime()</code>等价</p><h1 id="相对某个参考系的时间"><a href="#相对某个参考系的时间" class="headerlink" title="相对某个参考系的时间"></a>相对某个参考系的时间</h1><ul><li><code>Date().timeIntervalSince1970</code> </li></ul><p>1970年1月1日凌晨为参考系，到现在的时间，一般用于表示时间戳</p><p><br></p><ul><li><code>Date().timeIntervalSinceReferenceDate</code></li></ul><p>世界时间（UTC）2001年1月1日凌晨到现在经过的时间，单位为秒</p><p><br></p><ul><li><code>CFAbsoluteTimeGetCurrent()</code></li></ul><p>与<code>Date().timeIntervalSinceReferenceDate</code>等价</p><p><br></p><blockquote><p>当用户手动改变了设备上的系统时间后，基于系统时钟的上述方法返回的结果也会一同改变</p></blockquote><pre><code class="Swift">print(CACurrentMediaTime()) // 设备刚重启print(Date().timeIntervalSince1970)print(Date().timeIntervalSinceReferenceDate)print(CFAbsoluteTimeGetCurrent())</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-1bb36e607297d7c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="必要时，从服务器上获取时间"><a href="#必要时，从服务器上获取时间" class="headerlink" title="必要时，从服务器上获取时间"></a>必要时，从服务器上获取时间</h1><p>如果App本身对获取的时间精度要求很高，还是直接通过网络从服务器获取时间戳会比较保险。</p><p>当网络可用时，直接从服务器获取；</p><p>网络不可用时，且设备没有被重启过，可以根据上一次获取服务器时间戳的时刻到此时的时间差来推算出正确的时间</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑客与画家》摘录</title>
      <link href="/2015/05/09/%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E6%91%98%E5%BD%95/"/>
      <url>/2015/05/09/%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>“表面上这是一个机器的时代，但是实际上机器的设计者决定了我们的时代。程序员的审美决定了你看到的软件界面，程序员的爱好决定了你有什么样的软件可以使用。” ——《黑客与画家》</p></li><li><p>黑客如何才能做自己喜欢的事情？我认为这个问题的解决方法是一个几乎所有创作者都知道的方法：找一份养家糊口的“白天工作”（day job）。这个词是从音乐家身上来的，他们晚上表演音乐，所以白天可以找一份其他工作。更一般地说，“白天工作”的意思是，你有一份为了赚钱的工作，还有一份为了爱好的工作。<br>　　几乎所有的创作者在职业生涯的早期都有一份“白天工作”。画家和作家尤其显著。如果幸运的话，你能找到一份与你的“真正工作”非常相关的“白天工作”。音乐家似乎常常是在唱片行工作。同样地，钻研某种编程语言或操作系统的黑客，很可能会得到一份使用这些工具的“白天工作”。——《黑客与画家》</p></li><li><p>所有学员刚刚来到YC的时候，每人都会拿到一件白色T恤衫，上面写着“Make something people want”，等到他们的项目得到风险投资以后，又会收到一件黑色T恤衫，上面写着“I made something people want” ——《黑客与画家》</p></li><li><p>2014-12-17<br>塞缪尔·约翰逊^说过，人们对一个作家的评价，需要100年才能达成一致^^。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。</p></li><li><p>2014-12-22<br>坚持一丝不苟，就能取得优秀的成果。因为那些看不见的细节累加起来，就变得可见了。</p></li><li><p>2014-12-23<br>要是能坐上时间机器回到过去，不管哪一个年代，有一件事都是不会改变的，那就是“祸从口出”。你一定要小心自己说的话。自以为无害的言论会给你惹来大麻烦。</p></li><li><p>2014-12-23<br>历史的常态似乎就是，任何一个年代的人们，都会对一些荒谬的东西深信不疑。他们的信念还很坚定，只要有人稍微表示一点怀疑，就会惹来大麻烦。</p></li><li><p>2014-12-23<br>如果别人告诉你应该相信什么，你就真的相信了，那么你就会和别人一样犯下同样的错误。如果你是南北战争前的南方庄园主，你会与北方开战；如果你是20世纪30年代的德国人，你会相信希特勒。</p></li><li><p>2015-01-04<br>这时你要明白，自由思考比畅所欲言更重要。如果你感到一定要跟那些人辩个明自，绝不咽下这口气，一定要把话说清楚，结果很可能是从此你再也无法自由理性地思考了。我认为这样傲不可取，更好的方法是在思想和言论之间划一条明确的界线。在心里无所不想，但是不一定要说出来。我就鼓励自己在心里默默思考那些最无法无天的想法。你的思想是一个地下组织，绝不要把那里发生的事情一股脑说给外人听。“格斗俱乐部”的第一条规则，就是不要提到格斗俱乐部^。</p></li><li><p>2015-01-04<br>守口如瓶，笑脸相迎</p></li><li><p>2015-01-08<br>没有盗版是一种“优势”，但也是一个问题。一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。</p></li><li><p>2015-01-10<br>要致富，你需要两样东西：可测量性和可放大性。你的职位产生的业绩，应该是可测量的，否则你做得再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。</p></li><li><p>2015-01-10<br>乔布斯曾经说过，创业的成败取决于最早加入公司的那十个人。我基本同意这个观点，虽然我觉得真正决定成败的其实只是前五人。小团队的优势不在于它本身的小，而在于你可以选择成员。我们不需要小村庄的那种“小”，而需要全明星第一阵容的那种“小”。</p></li><li><p>2015-01-10<br>团队越大，每个人的贡献就越接近于整体的平均值。所以，在不考虑其他因素的情况下，一个非常能干的人待在大公司里可能对他本人是一件很糟的事情，因为他的表现被其他不能干的人拖累了</p></li><li><p>2015-01-11<br>「总的来说，这也是很好的处事原则。如果你有两个选择，就选较难的那个。如果你要选择是坐在家里看电视，还是外出跑步，那就出去跑步吧。这个方法有效的原因可能是遇到两个一难一易的选择时，往往出于懒惰的缘故，你会选择较易的那个选项。在意识深处，你其实知道不懒惰的做法会带来更好的结果，这个方法只是迫使你接受这一点。」</p></li><li><p>2015-01-12<br>将公司管理视同软件优化还能帮助你避免VC担心的另一个陷阱——开发某种产品的时间过长。现在，黑客都已经熟知这一点，并总结出一个术语“过早优化”（premature optimization）。尽快拿出1.0版，然后根据用户的反映而不是自己的猜测进行软件优化。</p></li><li><p>2015-01-12<br>你必须时刻牢记的最基本的原则就是，创造人们需要的东西，也就是创造财富。如果你想通过创造财富使得自己致富，那么你必须知道人们需要什么。</p></li><li><p>2015-01-12<br>冷战、第二次世界大战、近代的大多数战争都说明了这个道理。要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。</p></li><li><p>2015-01-12<br>财富与金钱是两个概念。金钱只是用来交易财富的一种手段，财富才是有价值的东西，我们购买的商品和服务都属于财富。</p></li><li><p>2015-01-12<br>我们大多数人都在为其他人创造财富，然后用创造出来的财富交换金钱，再用金钱交换我们需要的另一种财富</p></li><li><p>2015-01-12<br>现代社会的收入差距扩大是一种健康的信号。技术使得生产率的差异加速扩大，如果这种扩大没有反映在收入上面，只有三种可能的解释：（a）技术革新停顿了；（b）那些创造大部分财富的人停止工作了；（c）创造财富的人没有获得报酬。</p></li><li><p>2015-01-13<br>美感是第一道关卡，丑陋的数学在世界上无法生存。</p></li><li><p>2015-01-13<br>喜欢一件东西，却不知道为什么自己喜欢它，原因可能是这件东西是美的，但也可能因为他们的母亲也拥有同样的东西，或者杂志上某个明星使用它，或者仅仅因为它的价格很昂贵。人类的思想就是没有经过整理的无数杂念的混合。<br>注: 因为它的价格很昂贵。人类的思想就是没有经过整理的无数杂念的混合。</p></li><li><p>2015-01-13<br>好设计是简单的设计。</p></li><li><p>2015-01-13<br>好设计是解决主要问题的设计</p></li><li><p>2015-01-13<br>并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前沖刺的痛苦，而不是脚被钉子扎破的痛苦。</p></li><li><p>2015-01-14<br>有一句俗话说，如果你自己做不到，那就去当老师。这在语言设计领域不成立，我认识的一些最出色的黑客就在当教授。但是，当老师的人确实有很多事情不能做。研究性职位给黑客带来了一些限制。在任何学术领域，都有一些题目是可以做的，另一些题目是不可以做的。不幸的是，这两类题目的区别通常取决于它们写成论文后看上去是不是很高深，而不是取决于它们对软件业的发展是否重要。最极端的例子可能就是文学，文学研究者的任何成果几乎对文学创作者都毫无影响。</p></li><li><p>2015-01-14<br>认为所有语言都一样的看法的缺点是自欺欺人，但是优点是可以使许多事情变得很简单。我想这就是为什么它被广泛接受的主要原因。它是一个令人舒服的想法。</p></li><li><p>2015-01-14<br>大家都觉得Java—定有过人之处，因为它是一种很酷的新兴编程语言。但是真的如此吗？如果你站在远处观察编程语言的世界，似乎Java就是最新的东西。（如果你站得足够远，那么你看到的所有东西就是Sun公司出钱制作的大型霓虹广告牌。）但是，如果你靠近观察这个世界，就会发现不同的人对“酷”的理解是不一样的。在黑客圏子里，Perl被公认比Java酷得多。黑客社区网站Slashdot就是用Perl开发的。我估计你不可能看到黑客愿意使用Java的JSP技术开发网站。可是，还有一种更新的语言叫做Python，它的使用者往往看不起Perl。另一些人则认为Ruby语言是取代Python的最佳选择。<br>　　当你按照Java、Perl，Python，Ruby这样的顺序观察这些语言，你会发现一个有趣的结果。至少，如果你是一个Lisp黑客，你就看得出来，排在越后面的语言越像Lisp。Python语言模仿Lisp，甚至把许多Lisp黑客认为属于设计错误的功能也一起模仿了。至于Ruby语言，如果回到1975年，你声称它是一种有着自己句法的Lisp方言，没有人会提出反对意见。编程语言现在的发展不过刚刚赶上1958年Lisp语言的水平。　　</p></li><li>2015-01-15<br>　　如果你创业的话，千万不要为了取悦风险投资商或潜在并购方而设计你的产品。让用户感到满意才是你的设计方向。只要赢得用户，其他事情就会接踵而来。　　</li><li>2015-01-15<br>　　在大型组织内部，有一个专门的术语描述这种跟随大多数人的选择的做法，叫做“业界最佳实践”。这个词出现的原因其实就是为了让你的经理可以推卸责任。既然我选择的是“业界最佳实践”，如果不成功，项目失败了，那么你也无法指责我，因为做出选择的人不是我，而是整个“业界”。　　</li><li>2015-01-15<br>　　第一，不同语言的编程能力不一样。第二，大多数经理故意忽视第一点　　</li><li>2015-01-15<br>　　Fortran和Cobol是早期IBM大型机的脚本语言。C是Unix的脚本语言，后来的Perl和Python也是如此。Tel是Tk的脚本语言，Visual Basic是Windows的脚本语言，（某种形式的）Lisp是Emacs的脚本语言，PHP是网络服务器的脚本语言，Java和JavaScript是浏览器的脚本语言。　　</li><li>2015-01-15<br>　　有一个笑话说，黑客动手写程序之前，至少会在心里盘算一下哪种语言的打字工作量最小，然后就选择使用该语言。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocoapods 安装与使用</title>
      <link href="/2014/09/03/cocoapods-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2014/09/03/cocoapods-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><h2 id="更新本地索引库"><a href="#更新本地索引库" class="headerlink" title="更新本地索引库"></a>更新本地索引库</h2><p>需要经常手动进行更新，尤其在苹果有大的版本发布之后，各个第三方库会在随后更新<br><code>pod repo update</code></p><h2 id="更新cocoapod版本"><a href="#更新cocoapod版本" class="headerlink" title="更新cocoapod版本"></a>更新cocoapod版本</h2><p><code>gem install cocoapods --pre</code></p><h2 id="单独更新某个库"><a href="#单独更新某个库" class="headerlink" title="单独更新某个库"></a>单独更新某个库</h2><p><code>pod update MJRefresh</code></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><hr><h2 id="1-安装-rvm"><a href="#1-安装-rvm" class="headerlink" title="1.安装 rvm"></a>1.安装 rvm</h2><p>参考：<a href="http://ruby-china.org/wiki/rvm-guide，测试可行" target="_blank" rel="noopener">http://ruby-china.org/wiki/rvm-guide，测试可行</a></p><h2 id="2-安装ruby"><a href="#2-安装ruby" class="headerlink" title="2.安装ruby"></a>2.安装ruby</h2><p>同样参考上面的网站</p><h2 id="3-开始安装cocoapods"><a href="#3-开始安装cocoapods" class="headerlink" title="3.开始安装cocoapods"></a>3.开始安装cocoapods</h2><p>升级ruby的gem<br><code>sudo gem update --system</code><br>安装cocoapods<br><code>sudo gem install cocoapods</code><br>还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。</p><blockquote><p>请参见cocoapods官网 <a href="https://cocoapods.org" target="_blank" rel="noopener">https://cocoapods.org</a></p></blockquote><h2 id="4-更新ruby的源"><a href="#4-更新ruby的源" class="headerlink" title="4.更新ruby的源"></a>4.更新ruby的源</h2><blockquote><p>最新的国内安装源可以在这里看到 <a href="https://gems.ruby-china.org" target="_blank" rel="noopener">https://gems.ruby-china.org</a></p></blockquote><pre><code>gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l</code></pre><blockquote><p>参考唐巧博客：<a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="noopener">http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/</a></p></blockquote><h2 id="二、重装"><a href="#二、重装" class="headerlink" title="二、重装"></a>二、重装</h2><hr><p>更新了 <code>Xcode 7</code> 和 <code>OSX 0.11.1</code> 后，<code>install pod</code> 不好使了。试了下重新安装 <code>cocoapods</code>。遇到了一些问题</p><h3 id="1-执行-sudo-gem-install-cocoapods-出现了如下错误："><a href="#1-执行-sudo-gem-install-cocoapods-出现了如下错误：" class="headerlink" title="1. 执行 sudo gem install cocoapods 出现了如下错误："></a>1. 执行 <code>sudo gem install cocoapods</code> 出现了如下错误：</h3><blockquote><p>ERROR:  Could not find a valid gem ‘cocospods’ (&gt;= 0), here is why:<br>Unable to download data from <a href="http://ruby.taobao.org/" target="_blank" rel="noopener">http://ruby.taobao.org/</a> - bad response Not Found 404 (<a href="http://ruby.taobao.org/latest_specs.4.8.gz" target="_blank" rel="noopener">http://ruby.taobao.org/latest_specs.4.8.gz</a>)</p></blockquote><h3 id="解决办法：将http-替换成-https，具体如下"><a href="#解决办法：将http-替换成-https，具体如下" class="headerlink" title="解决办法：将http 替换成 https，具体如下"></a>解决办法：将http 替换成 https，具体如下</h3><ol><li>gem sources –remove <a href="http://ruby.taobao.org/" target="_blank" rel="noopener">http://ruby.taobao.org/</a></li><li>gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="noopener">https://ruby.taobao.org/</a></li><li>查看源对不对<br>gem sources -l</li><li>再安装就好了<br>sudo gem install cocoapods</li></ol><h3 id="2-然后可以执行-sudo-gem-install-cocoapods-了。但是执行到一半又出现了如下错误"><a href="#2-然后可以执行-sudo-gem-install-cocoapods-了。但是执行到一半又出现了如下错误" class="headerlink" title="2. 然后可以执行 sudo gem install cocoapods 了。但是执行到一半又出现了如下错误"></a>2. 然后可以执行 <code>sudo gem install cocoapods</code> 了。但是执行到一半又出现了如下错误</h3><blockquote><p>While executing gem … (Errno::EPERM)<br>Operation not permitted - /usr/bin/xcodeproj</p></blockquote><h3 id="解决办法：自定义GEM-HOME"><a href="#解决办法：自定义GEM-HOME" class="headerlink" title="解决办法：自定义GEM_HOME"></a>解决办法：自定义GEM_HOME</h3><p>命令行操作：</p><pre><code>$ mkdir -p $HOME/Software/ruby$ export GEM_HOME=$HOME/Software/ruby$ gem install cocoapods　　[...]　　1 gem installed　　$ export PATH=$PATH:$HOME/Sofware/ruby/bin　　$ pod --version　　0.39.0　　</code></pre><p>　　<br>　　然后就顺利安装成功了<br>　　<br>　　## 三、使用 cocoapods<br>　　<br>　　<del>~### 更换clone github镜像，加快 pod 代码下载速度</del>~<br>　　<br>　　<code>$ cd ~/.cocoapods/repos 　　$ pod repo remove master　　$ git clone https://git.coding.net/hging/Specs.git master</code><br>　　<br>　　<del>~然后需要在 podfile文件中加入如下代码</del>~<br>　　<code>// 如果不加这一句话，它默认还是从github镜像源地址去下载的　　source &#39;https://git.coding.net/hging/Specs.git&#39;</code><br>　　<br>　　<br><br>　　<br>　　<font color="#0099ff" face="黑体">目前没有发现比较好的镜像，上面的镜像pod里库的版本已经很低，不建议使用了，所以暂时无法解决慢的问题。</font><br>　　—-<br>　　<br>　　### 常用命令<br>　　<code>pod search pop</code><br>　　<code>pod init</code><br>　　<code>pod install</code><br>　　<code>pod install --verbose --no-repo-update</code><br>　　<code>pod update</code><br>　　<code>pod update --verbose --no-repo-update</code><br>　　<br>　　### 注意点<br>　　* 如果 import 的时候没有提示 <code>POP.h</code> 的文件，可以在 <code>target-Build Settings</code> 下修改 <code>User Header Search Paths</code> 项，新增 <code>${SRCROOT}</code> 并选择 <code>rcursive</code>，如下图。<br>　　<br>　　<br>　　## 四、参考：<br>　　<a href="http://www.bubuko.com/infodetail-1136466.html" target="_blank" rel="noopener">安装Cocoapods， 更新gem出现的问题</a><br>　　<a href="http://blog.csdn.net/w_x_p/article/details/49151477" target="_blank" rel="noopener">Mac OS X 跟新到10.11后cocoapods安装出现的问题（- bad response Not Found 404 (http://ruby.taobao.org/latest_spe</a><br>　　<a href="http://ryantang.me/blog/2014/01/05/cocoapods/" target="_blank" rel="noopener">使用CocoaPods管理依赖库</a><br>　　<a href="https://www.cnblogs.com/dengchaojie/p/8232555.html" target="_blank" rel="noopener">解决CocoaPods慢的小技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> cocoapods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2013读书摘录</title>
      <link href="/2013/12/30/%E8%AF%BB%E9%97%B2%E4%B9%A6%20%E6%91%98%E5%BD%95%E4%B8%80/"/>
      <url>/2013/12/30/%E8%AF%BB%E9%97%B2%E4%B9%A6%20%E6%91%98%E5%BD%95%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="《月亮和六便士》"><a href="#《月亮和六便士》" class="headerlink" title="《月亮和六便士》"></a>《月亮和六便士》</h1><ul><li>人们在仰望月亮时常常忘了脚下的六便士——月亮与六便士</li><li><img src="https://upload-images.jianshu.io/upload_images/1120923-2c4720d657226555.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8e8166c087f4c7b10d227d7570eedef0.png"></li></ul><h1 id="《且听风吟》"><a href="#《且听风吟》" class="headerlink" title="《且听风吟》"></a>《且听风吟》</h1><ul><li><p>于是我一只手拿尺，开始惶惶不安地张望周围的世界。那年大概是肯尼迪总统惨死的那年，距今已有15年之久。这15年里我的确扔掉了很多很多东西。就像发动机出了故障的飞机为减轻重量而甩掉货物、甩掉座椅、最后连可怜的男乘务员也甩掉一样。十五年里我舍弃了一切，身上几乎一无所有。至于这样做是否正确，我无从断定。心情变得痛快这点倒是确确实实的。然而每当我想起临终时身上将剩何物，我便觉得格外恐惧。一旦付诸火炬，想必连一截残骨也断难剩下。死去的祖母常说，“心情抑郁的人只能做抑郁的梦，要是更加抑郁，连梦都不做的。”——《且听风吟》</p></li><li><p>“不存在十全十美的文章，如同不存在彻头彻尾的绝望。”或者说 “不存在十全十美的人物，如同不存在彻头彻尾的绝望。——《且听风吟》</p></li></ul><h1 id="《了不起的盖茨比》"><a href="#《了不起的盖茨比》" class="headerlink" title="《了不起的盖茨比》"></a>《了不起的盖茨比》</h1><ul><li><p>“每当你要批评别人，要记住，世上不是每个人都有你这么好的条件。”</p></li><li><p>“在大都市迷人的黄昏时刻，我有时感到一种难以排遣的寂寞，同时也觉得别人有同感——那些在橱窗面前踯躅的穷困的青年小职员，等到了时候独个儿上小饭馆去吃一顿晚饭——黄昏中的青年小职员，虚度着夜晚和生活中最令人陶醉的时光。” </p></li><li><p>“盖茨比深切地体会到财富怎样禁甸和保存青春与神秘，体会到一套套衣装怎样使人保持清析，体会到黛西像白银一样皎皎发光，安然高踞于穷苦人激烈的生存斗争之上。”</p></li><li><p>“不是因为时间令我遗忘当时的心情，而是在时间中希望又失望又希望，循环往复，终于证明快乐的确不用发觉，是正觉，“原来”两个字，提醒了我，所谓感觉，是随心境而生灭，并无绝对的真相或事实的概念.</p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-3f7f980047226f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c5fb575293c19238d890b0c3f569ea7d.png"></p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-3f7f980047226f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c5fb575293c19238d890b0c3f569ea7d.png"></p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-061acbfd64e7bb89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="- "></p></li></ul><h1 id="《原来你并非不快乐》"><a href="#《原来你并非不快乐》" class="headerlink" title="《原来你并非不快乐》"></a>《原来你并非不快乐》</h1><ul><li><p>“钱可以帮你，贪心的话，钱便可以主宰你。够好心钱更可以救助天地，但愿别为钱而忧，亦别独独为钱而喜，足够，便足以忘记。</p></li><li><p>“假如买不起一个高清电视弥补失恋之苦，不如买本《庄子》看一下更能放下前度的阴影，假如去不其欧洲奖励自己半年无休的辛劳，去一次郊区观鸟，更会发现钱除了买到享受，最重要是买到将来选择的自由”</p></li><li><p>旅游，不是太早，就是太迟。</p></li><li><p>不是因为时间令我遗忘当时的心情，而是在时间中希望又失望又希望，循环往复，终于证明快乐的确不用发觉，是正觉，“原来”两个字，提醒了我，所谓感觉，是随心境而生灭，并无绝对的真相或事实的概念</p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-946deaec2ec6a4fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a753e4b21ed84b75da113e2235986b1b.png"></p></li></ul><h1 id="《登天的感觉，我在哈佛大学做心理咨询》"><a href="#《登天的感觉，我在哈佛大学做心理咨询》" class="headerlink" title="《登天的感觉，我在哈佛大学做心理咨询》"></a>《登天的感觉，我在哈佛大学做心理咨询》</h1><ul><li><img src="https://upload-images.jianshu.io/upload_images/1120923-778c2757812283ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="778fda349df5e4a2b31f19d8a287cb7f.png"></li></ul><h1 id="《鲁迅经典全集》"><a href="#《鲁迅经典全集》" class="headerlink" title="《鲁迅经典全集》"></a>《鲁迅经典全集》</h1><ul><li><p>其实人禽之辨，本不必这样严。在动物界，虽然并不如古人所幻想的那样舒适自由，可是噜苏做作的事总比人间少。它们适性任情，对就对，错就错，不说一句分辩话。虫蛆也许是不干净的，但它们并没有自命清高；鸷禽猛兽以较弱的动物为饵，不妨说是凶残的罢，但它们从来就没有竖过 “ 公理 ”“ 正义 ” 的旗子，使牺牲者直到被吃的时候为止，还是一味佩服赞叹它们。人呢，能直立了，自然是一大进步；能说话了，自然又是一大进步；能写字作文了，自然又是一大进步。然而也就堕落，因为那时也开始了说空话。说空话尚无不可，甚至于连自己也不知道说着违心之论，则对于只能嗥叫的动物，实在免不得 “ 颜厚有忸怩 ”。假使真有一位一视同仁的造物主，高高在上，那么，对于人类的这些小聪明，也许倒以为多事，正如我们在万生园里，看见猴子翻筋斗，母象请安，虽然往往破颜一笑，但同时也觉得不舒服，甚至于感到悲哀，以为这些多余的聪明，倒不如没有的好罢。然而，既经为人，便也只好“ 党同伐异 ” ，学着人们的说话，随俗来谈一谈，辩一辩了。《朝花夕拾》</p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-ceb85b5bfdb8cd46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4c96d3f5830beaed37473d162910fa95.png"></p></li></ul><h1 id="《独自上场》"><a href="#《独自上场》" class="headerlink" title="《独自上场》"></a>《独自上场》</h1><ul><li><p>你不可能从现在这个点上看到将来；只有回头看时，才会发现它们之间的关系。所以你必须相信，那些点点滴滴，会在你未来的生命里，以某种方式串联起来。”——李娜《独自上场》</p></li><li><p>愤怒比悲伤更有力，愤怒不会让一个人垮掉。——李娜《独自上场》</p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-0a06bd817940075c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="817e3b298d4339d845309c889cc5edb1.png"></p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-b2e1ce30c6328e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9c305f985d283d54d6c10b543843c820.png"></p></li></ul><h1 id="杨绛《我两的故事》"><a href="#杨绛《我两的故事》" class="headerlink" title="杨绛《我两的故事》"></a>杨绛《我两的故事》</h1><ul><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-62d408e807407b7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="24059d08bdb154129e416ef2a7bc1f70.png"></p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-28d8684745f066ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b39c594256e4be67ff53d7d4e1ccd699.png"></p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-b8d7ad3a545bf79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e711ffc9bb4aaf9a42931cf6fe3d4b1f.png"></p></li><li><p>见她之前，从未想结婚；娶她之后，从未后悔娶她。</p></li></ul><h1 id="《文化苦旅》"><a href="#《文化苦旅》" class="headerlink" title="《文化苦旅》"></a>《文化苦旅》</h1><ul><li><img src="https://upload-images.jianshu.io/upload_images/1120923-b471d9fb26be798b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10c4a2219cddd9eb8a79c98462b0d328.png"></li></ul><h1 id="《沉默的大多数》"><a href="#《沉默的大多数》" class="headerlink" title="《沉默的大多数》"></a>《沉默的大多数》</h1><ul><li><p>此人之肉，彼人之毒；一件对此人有利的事，难免会伤害另一个人。真正的君子知道，自己的见解受所处环境左右，未必是公平的；——《沉默的大多数》</p></li><li><p>话语有一个神圣的使命，就是想要证明说话者本身与众不同，是芸芸众生中的娇娇者。假设这些都是实情，我们不妨把这些保藏在内心处不说，“闷兹蜜”。——《沉默的大多数》原来王小波先生也是”闷骚”型。其实这个世界不缺沉默。</p></li></ul><h1 id="《突然就走到西藏》"><a href="#《突然就走到西藏》" class="headerlink" title="《突然就走到西藏》"></a>《突然就走到西藏》</h1><ul><li><p>亲友或爱人之间争吵，有时候争得面红耳赤不如一个拥抱来得温暖直接。——《突然就走到了西藏 纯文字》</p></li><li><p>感谢那个残酷对你的人——《突然就走到了西藏 纯文字》，否则你会沉浸于梦境中，梦总有会醒的时候。</p></li><li><p>自卑常常以骄傲的面目出现。人的自傲与自卑是一对孪生兄弟，有时候过于自傲反倒说明你是自卑的。——《突然就走到了西藏 纯文字》</p></li></ul><h1 id="《生命不能承受之轻》"><a href="#《生命不能承受之轻》" class="headerlink" title="《生命不能承受之轻》"></a>《生命不能承受之轻》</h1><ul><li><p>人的生命只有一次，我们既不能把它与我们以前的生活相此较，也无法使其完美之后再来度过。——《生命中不能承受之轻》</p></li><li><p>也许最沉重的负担同时也是一种生活最为充实的象征，负担越沉，我们的生活也就越贴近大地，越趋近真切和实在。——《生命中不能承受之轻》</p></li></ul><h1 id="《张爱玲文集》"><a href="#《张爱玲文集》" class="headerlink" title="《张爱玲文集》"></a>《张爱玲文集》</h1><ul><li><p>如果你不调戏女人，她说你不是一个男人，如果你调戏她，她说你不是一个上等人。——《张爱玲文集(全5卷)》</p></li><li><p>用别人的钱，即使是父母的遗产，也不如用自己赚来的钱来得自由自在，良心上痛快。可是用丈夫的钱，如果爱他的话，那却是一种快乐，愿意想自己是吃他的饭，穿他的衣服。那是女人的传统的权利，即使女人现在有了职业，还是舍不得放弃的。——《张爱玲文集(全5卷)》</p></li></ul><h1 id="王朔《过把瘾就死》"><a href="#王朔《过把瘾就死》" class="headerlink" title="王朔《过把瘾就死》"></a>王朔《过把瘾就死》</h1><ul><li>“就像童话中两个贪心人挖地下的财宝，结果挖出一个人的骸骨，虽然迅速埋上了，甚至在上面种了树，栽了花，但都清楚地知道底下埋的是什么。看见树，看见花，想的却是地下的那具骸骨。” ——王朔《过把瘾就死》</li></ul><h1 id="路遥《人生》"><a href="#路遥《人生》" class="headerlink" title="路遥《人生》"></a>路遥《人生》</h1><ul><li><p>我们当今的现实生活中有马占胜和高明楼这样的人。他们为了个人的利益。有时毫不顾忌地给这些徘徊在生活十字路口的人当头一棒，使他们对生活更加悲观；有时，还是出于个人目的，他们又一下子把这些人推到生活的顺风船上。——《人生》看到这里，生活不过如此了</p></li><li><p>劳动啊，它是艰苦的，但也有它本身的欢乐！《人生》</p></li><li><p>生活的变化真如同春夏秋冬，一寒一暑，差别甚远！三年前，这样的夜晚，他此刻或者在明亮温馨的教室里读书；或者在电影院散场的人群里，和同学们说说笑笑走向学校.　　现在，他却拉着茅粪桶，东避西躲，鬼鬼祟祟，像一个夜游鬼一样。——《人生》</p></li><li><p>现在他一屁股坐下来，浑身骨头似乎全掉了，两只手像抓着两把葛针，疼得万箭钻心！　　不过，他也感到了一种无法言语的愉快。他让所有的庄稼人看见：他们衡量一个优秀庄稼人最重在的品质――吃苦精神，他高加林也具备。从性格上说，他的确是个强者；而这个优点在某些情况下又使他犯错误。——《人生》</p></li><li><p>爱情就像一条河，我们都是瞎子，谁不是摸着石头过河。</p></li></ul><h1 id="柴静《看见》"><a href="#柴静《看见》" class="headerlink" title="柴静《看见》"></a>柴静《看见》</h1><ul><li><p>“但痛苦也是一种清洗，是对牺牲的人的告慰。”——《看见》</p></li><li><p>当一个人关心别人的时候，才会忘记自己。——《看见》</p></li><li><p>我知道自己身上已经开始散发失败者的味儿，再这样下去谁都会闻出来了–在动物界，你知道，只要你散发出那样的气味，几乎就意味着没有指望了，很快，很快，就会被盯上，毫不留情地被扑倒在地，同伴会四奔逃散，甚至顾不上看你一眼。——《看见》</p></li><li><p>“人们声称的最美好的岁月其实都是最痛苦的，只是事后回忆起来的时候才那么幸福。”——《看见》</p></li></ul><h1 id="《牧羊少年的奇幻之旅》"><a href="#《牧羊少年的奇幻之旅》" class="headerlink" title="《牧羊少年的奇幻之旅》"></a>《牧羊少年的奇幻之旅》</h1><ul><li><p>“我就像大多数人一样－－只肯相信自己要相信的，不肯去看清事情究竟真正是怎么一回事。”——《牧羊少年奇幻之旅》</p></li><li><p>幸福的秘密就是去欣赏世界上所有的奇妙景观，但不要忘了汤匙里的油。’——《牧羊少年奇幻之旅》</p></li></ul><h1 id="《雪国》"><a href="#《雪国》" class="headerlink" title="《雪国》"></a>《雪国》</h1><ul><li><p>“山头上罩满了月色，这是原野尽头惟一的景色，月色虽以淡淡消去，但余韵无穷，不禁使人产生冬夜寥峭的感觉。”“盈盈皓月，深深地射了进来，照亮得连驹子的耳朵的凹凸线条都清晰地浮现出来。”——《雪国》</p></li><li><p>诗句不都是句句真言吗？像一道彩虹悬挂在虚空，瞬间出现五彩缤纷像。当白日空中辉照时，虚无又明亮起来了。然而虚空本来无光，也是无色可装点的。我也在这如虚空般的心上，着上种种情趣盎然的色彩，但没有留下一丝踪迹——《雪国》现实的事物遮住了眼睛，充斥了双耳，而诗歌呢，就如虚空中的彩虹一样。</p></li><li><p>以前觉得“感冒一直纠缠不休，鼻子堵塞”。当一到雪国这清冷的环境中，“这时一下子通了气，穿到头顶心。”——《雪国》</p></li><li><p>弗洛伊德说：“女人越是轻浮放荡，就越使男人爱得发狂。同这种女人相爱，往往使他们魂销骨酥，不能自拔。……但一旦爱上之后，又要求她们对自己忠实。”《雪国》序</p></li></ul><h1 id="《目送》"><a href="#《目送》" class="headerlink" title="《目送》"></a>《目送》</h1><ul><li><p>我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站立在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追。——《目送》</p></li><li><p>只有一个人能听的音乐，是一扇紧闭的门。——《目送》</p></li><li><p>一件事情的毕业，永远是另一件事情的开启。——《目送》</p></li></ul><h1 id="《乡关何处》"><a href="#《乡关何处》" class="headerlink" title="《乡关何处》"></a>《乡关何处》</h1><ul><li><p>我们不是我们污脏的外表，我们的心中一直盛开着一朵圣洁的向日葵。——《乡关何处》</p></li><li><p>命运未卜，何敢触碰爱情这种高贵的话题。即便心中藏有一个重洋，流出来也只是两颗泪珠。——《乡关何处》</p></li><li><p>最美的生活是善良、平等和文明，最好的工作是为未来做几件切实有益的事情，最甜的笑由于淡淡的幽默。人们不以权势扰乱平静无辜的心灵的时代，才是人性真正解放的时代。——《乡关何处》</p></li><li><p>一个人滥情是罪过，但一个人独身也同样难容于大众。一个人因为穷或残障而不能成婚，已多蒙歧视，如果他健康且尚可谋生而不婚，则难逃物议。——《乡关何处》</p></li><li><p>雪夜访戴，兴至而往，兴尽而归，何必见戴。——《乡关何处》</p></li><li><p>当“访旧半为鬼”时，当“故人日以稀”时，当在暮烟的幻象中遥见你曾朝夕与共甚或唇齿相依的大队面容时，你何曾有一丝幸存者的窃喜。就像此夜，当我枯坐于天涯客馆，燃一炬烟，吞吐几十年的往事时，我恍若一个同谋共犯——他们去了，我却苟活于斯——我怎堪独自直面这残酷的余生。——《乡关何处》</p></li><li><p>死亡，在许多时候，真是一件近乎日常的琐事。你买菜的路上，邂逅车轮下的一摊血；你拎着一堆肉食回来，看见邻居的一张讣告——在你行经的地方，人们竞相奔赴道路的尽头。你才发现，生命竟然确实薄如蝉翼。——《乡关何处》</p></li><li><p>可是好人却无好命，这几乎已经是这个世界的潜规则。这些好人来到这个世界，就是来承担磨难的；他们像一粒糖抛进大海，永远无法改变那深重的苦涩，也许只有经过的鱼才会知道那一丝稀有的甜蜜。——《乡关何处》</p></li><li><p>即使在此过程中已经深知这一结局的无法回避，但一个活生生的人真正在你手里呼出最后一口气时，你依然难以接受——你在那一刻无法不痛感人的弱小和不堪一击。我们有谁能与死神相争呢？——《乡关何处》</p></li></ul><h1 id="巴金《家》"><a href="#巴金《家》" class="headerlink" title="巴金《家》"></a>巴金《家》</h1><ul><li><p>顺受的，毫不抱怨，毫不诉苦的。像大海一样，它接受了一切，吞下了一切，可是它连一点吼声也没有。——《家》鸣凤的对待不公的表情</p></li><li><p>有人说过，路本没有，因为走的人多了，便成了一条路。又有人说路是有的，正因为有了路才有许多人走。谁是谁非，我不想判断。我还年轻，我还要活下去，我还要征服生活。我知道生活的激流是不会停止的，且看它把我载到什么地方去！——《家》</p></li><li><p>黑暗到了尽头，黎明就出现了。——《家》</p></li><li><p>几年前我流着眼泪读完托尔斯泰的小说《复活》，曾经在扉页上写了一句话：“生活本身就是一个悲剧。”　　事实并不是这样。生活并不是悲剧。它是一场“搏斗”。我们生活来做什么？或者说我们为什么要有这生命？罗曼罗兰的回答是“为的是来征服它”。《家》巴金</p></li></ul><h1 id="《傲慢与偏见》"><a href="#《傲慢与偏见》" class="headerlink" title="《傲慢与偏见》"></a>《傲慢与偏见》</h1><ul><li><p>大凡一个人爱上一个人，都是因为先有了感激之心，器重之意。《傲慢与偏见》</p></li><li><p>虚荣与骄傲是截然不同的两件事，尽管字面上常常当作同义词用，一个人可以骄傲而不虚荣。骄傲多半不外乎我们对我们自己的估价，虚荣却牵涉到我们希望别人对我们的看法。——《傲慢与偏见》</p></li></ul><h1 id="《潜规则》"><a href="#《潜规则》" class="headerlink" title="《潜规则》"></a>《潜规则》</h1><ul><li><p>合法伤害权是很值钱的。有了这种权力，没有钱可以有钱，没有敛钱的规矩可以创造出规矩。用古汉语一个简洁贴切的词来表达，这叫势所必至。势之所至，潜规则生焉。即使这规则不合法，也可以转弯抹角将它装扮起来–广大群众爱护人民警察，凑点钱表达他们的感激之情，这难道有什么不对吗？——《潜规则》</p></li><li><p>合法地祸害别人的能力，乃是官吏们的看家本领。这是一门真正的艺术，种种资源和财富正要据此分肥并重新调整。——《潜规则》</p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/1120923-7eb5255c46eeae00.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="685926ffc7f7a3e369358a5bb2e33fdc.jpg"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>让StringGrid控件显示下拉菜单</title>
      <link href="/2013/12/17/%E8%AE%A9StringGrid%E6%8E%A7%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95/"/>
      <url>/2013/12/17/%E8%AE%A9StringGrid%E6%8E%A7%E4%BB%B6%E6%98%BE%E7%A4%BA%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><p><img src="https://img-blog.csdn.net/20131217181100796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWN0aW9uNDU2Nzg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><pre><code class="C">void __fastcall TForm1::FormCreate(TObject *Sender)  {      StringGrid1-&gt;ColCount = 4;      StringGrid1-&gt;RowCount = 6;      StringGrid1-&gt;DefaultRowHeight = ComboBox1-&gt;Height;      StringGrid1-&gt;RowHeights[0] = 18;      StringGrid1-&gt;ColWidths[2] = 80;      StringGrid1-&gt;Cells[0][0] = &quot;FirstName&quot;;      StringGrid1-&gt;Cells[1][0] = &quot;LastName&quot;;      StringGrid1-&gt;Cells[2][0] = &quot;SBVLEdit LV1&quot;;      StringGrid1-&gt;Cells[3][0] = &quot;Action&quot;;      ComboBox1-&gt;Text = &quot;&quot;;      ComboBox1-&gt;Items-&gt;Add(&quot;Teen&quot;);      ComboBox1-&gt;Items-&gt;Add(&quot;Adult&quot;);      ComboBox1-&gt;Items-&gt;Add(&quot;Senior&quot;);      ComboBox1-&gt;Visible = False;  }  void __fastcall TForm1::ComboBox1Change(TObject *Sender)  {      StringGrid1-&gt;Cells[StringGrid1-&gt;Col][StringGrid1-&gt;Row] = ComboBox1-&gt;Items-&gt;Strings[ComboBox1-&gt;ItemIndex];  }  void __fastcall TForm1::StringGrid1DblClick(TObject *Sender) //双击事件  {      TRect r;      if(StringGrid1-&gt;Col == 2)      {          int ACol = StringGrid1-&gt;Col;          int ARow = StringGrid1-&gt;Row;          r = StringGrid1-&gt;CellRect(ACol,ARow);          ComboBox1-&gt;Top = StringGrid1-&gt;Top + r.Top + StringGrid1-&gt;GridLineWidth + 1;          ComboBox1-&gt;Left = StringGrid1-&gt;Left + r.Left + StringGrid1-&gt;GridLineWidth +1;          ComboBox1-&gt;Width = r.Right - r.Left;          ComboBox1-&gt;ItemIndex = ComboBox1-&gt;Items-&gt;IndexOf(StringGrid1-&gt;Cells[ACol][ARow]);          ComboBox1-&gt;Visible = true;      } else {         ComboBox1-&gt;Visible = false;    }  }  </code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://ymg97526.blog.163.com/blog/static/17365816020135264552765/" target="_blank" rel="noopener">http://ymg97526.blog.163.com/blog/static/17365816020135264552765/</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boardland C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C语言深度剖析》读书笔记</title>
      <link href="/2013/07/15/%E3%80%8AC%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2013/07/15/%E3%80%8AC%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="register"><a href="#register" class="headerlink" title="register"></a><code>register</code></h1><p>register 变量必须是一个单个的值,并且其长度应小 于或等于整型的长度。 而且 register 变量可能不存放在内存中,所以不能用取址运算符“&amp;” 来获取 register 变量的地址。</p><h1 id="float-变量与“零值”进行比较"><a href="#float-变量与“零值”进行比较" class="headerlink" title="float 变量与“零值”进行比较"></a><code>float</code> 变量与“零值”进行比较</h1><pre><code class="C/C++">//EPSINON 为定义好的 精度。if((fTestVal &gt;= -EPSINON) &amp;&amp; (fTestVal &lt;= EPSINON)); </code></pre><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h1><p>volatile 关键字告诉编译器 i 是随时可能发生变化的,每次使用它的时候必须从内存中取出 i 的值,因而编译器生成的汇编代码会重新从 i 的地址处读取数据放在 k 中。</p><p>这样看来,如果 i 是一个寄存器变量或者表示一个端口数据或者是多个线程的共享数 据,就容易出错,所以说 volatile 可以保证对特殊地址的稳定访问。</p><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a><code>extern</code></h1><p>extern 可以置于变量或者函数前,以 标示变量或者函数的定义在别的文件中,下面的代码用到的这些变量或函数是外来的,不 是本文件定义的,提示编译器遇到此变量和函数时在其他模块中寻找其定义</p><h1 id="空结构体占用空间大小"><a href="#空结构体占用空间大小" class="headerlink" title="空结构体占用空间大小"></a>空结构体占用空间大小</h1><pre><code class="C/C++">struct student {}stu;</code></pre><h1 id="sizeof-stu-的值是多少呢"><a href="#sizeof-stu-的值是多少呢" class="headerlink" title="sizeof(stu)的值是多少呢?"></a><code>sizeof(stu)</code>的值是多少呢?</h1><p>Visual C++ 6.0上为 1<br>编译器认为你构造一个结构体数据类型是用来打包一些数据成员的,而最小的数据成员需要 1 个 byte,编译器为每个结构体类型数据至少预留 1 个 byte 的空间。所以,空结构体的大小就定位 1 个 byte。</p><h1 id="struct-与-class-的区别"><a href="#struct-与-class-的区别" class="headerlink" title="struct 与 class 的区别"></a>struct 与 class 的区别</h1><p>struct 的成 员默认情况下属性是 public 的,而 class 成员却是 private 的。</p><h1 id="union-关键字"><a href="#union-关键字" class="headerlink" title="union 关键字"></a>union 关键字</h1><p>union 维护足够的空间来置放多个数据成员中的“一种”,而不是为每一个数据成员配置 空间,在 union 中所有的数据成员共用一个空间,同一时间只能储存其中一个数据成员,所 有的数据成员具有相同的起始地址。</p><pre><code class="C/C++">union StateMachine {char character;int number;char *str;double exp;};</code></pre><p>一个 union 只配置一个足够大的空间以来容纳最大长度的数据成员,以上例而言,最大 长度是 double 型态,所以 StateMachine 的空间大小就是 double 数据类型的大小。<br>另外，注意大小端模式对 union 类型数据存储的空间有影响</p><h1 id="typedef-关键字"><a href="#typedef-关键字" class="headerlink" title="typedef 关键字"></a><code>typedef</code> 关键字</h1><pre><code class="C/C++">typedef struct student {//code}Stu_st,*Stu_pst;A),struct student stu1;和 Stu_st stu1;没有区别。B),struct student *stu2;和 Stu_pst stu2;和 Stu_st *stu2;没有区别。 这个地方很多初学者迷惑,B)的两个定义为什么相等呢?其实很好constconst  int *p;      //p指向的对象不可变（*p不可变）int const *p;     //p指向的对象不可变（*p不可变）int *const p;     //p不可变，p指向的对象可变const int *const p; //前一个 const 修饰*p,后一个 const 修饰 p,指针 p 和 p 指向的对象 都不可变void Fun(const int i);     //不希望这个参数值被函数体内意外改变。const int Fun (void);     //返回值不可被改变。</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><pre><code class="C/C++">SQR(8)</code></pre><p>输出的是:<br>The square of 8 is 64.</p><p>#预算符</p><p>##运算符可以用于宏函数的替换部分。这个运算符把两个语言符号组 合成单个语言符号。</p><pre><code class="C/C++">#define XNAME(n) x ## n</code></pre><p>如果这样使用宏:</p><pre><code class="C/C++">XNAME(8)</code></pre><p>则会被展开成这样:<br>x8</p><h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><p>A)</p><pre><code class="C/C++">int* p1[10];     // 指针数组，数组的每个值都是指针</code></pre><p>“[]”的优先级比“<em>”要高。p1 先与“[]”结合,构成一个数组的定义,数组名为 p1,int </em> 修饰的是数组的内容,即数组的每个元素。那现在我们清楚,这是一个数组,其包含 10 个 指向 int 类型数据的指针,即指针数组。<br>B)</p><pre><code class="C/C++">int  (*p2)[10];     //数组指针，可以理解为 int (*)[10] p2，实际上就是二维数组p[][10];</code></pre><p>“()”的优先级比 “[]”高,“*”号和 p2 构成一个指针的定义，指针变量名为 p2,int 修饰的是数组的内容, 即数组的每个元素。数组在这里并没有名字,是个匿名数组。那现在我们清楚 p2 是一个指 针,它指向一个包含 10 个 int 类型数据的数组,即数组指针。</p><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>A)</p><pre><code class="C/C++">char * fun3(char * p1,char * p2);     //fun3是函数名,p1,p2是参数,其类型为char*型,函数的返回值为char * 类型。</code></pre><p>B)</p><pre><code class="C/C++">char * *fun2(char * p1,char * p2);     //与 C)表达式相比,唯一不同的就是函数的返回值类型为 char**</code></pre><p>C)</p><pre><code class="C/C++">char * (*fun1)(char * p1,char * p2);     //fun1 不是什么函数名,而是一个 指针变量,它指向一个函数。这个函数有两个指针类型的参数,函数的返回值也是一个指 针。我们把这个表达式改写一下:char * (*)(char * p1,char * p2) fun1; 这样子是不 是好看一些呢?只可惜编译器不这么想。</code></pre><h1 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h1><pre><code class="C/C++">char * (*pf)(char * p)     //函数指针char * (*pf[3])(char * p);     //这是定义一个函数指针数组。它是一个数组,数组名为 pf,数组内存储了 3 个指向函数的 指针。pf是数组名</code></pre><h1 id="函数指针数组的指针"><a href="#函数指针数组的指针" class="headerlink" title="函数指针数组的指针"></a>函数指针数组的指针</h1><pre><code class="C/C++">char * (*(*pf)[3])(char * p);     //pf是指针，这个指针指向一个包含了 3 个元素的数组;这个数字里 面存的是指向函数的指针;这些指针指向一些返回值类型为指向字符的指针、参数为一个 指向字符的指针的函数。</code></pre><h1 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190820184018.png" alt=""></p><ul><li>参考答案：<br>a) int a;<br>b) int <em>a;<br>c) int **a;<br>d) int a[10];<br>e) int </em> a[10];<br>f) int (<em>a)[10];<br>g) int (</em>func)(int a);<br>h) int (*func[10])(int a);</li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iOS SDK 开发</title>
      <link href="/2018/05/09/iOS-SDK-%E5%BC%80%E5%8F%91/"/>
      <url>/2018/05/09/iOS-SDK-%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="一、Framework与-a基础"><a href="#一、Framework与-a基础" class="headerlink" title="一、Framework与.a基础"></a>一、Framework与.a基础</h1><p>此处等下一期</p><p><br></p><hr><h1 id="二、工程嵌套联调静态库"><a href="#二、工程嵌套联调静态库" class="headerlink" title="二、工程嵌套联调静态库"></a>二、工程嵌套联调静态库</h1><h2 id="1、新建一个主工程"><a href="#1、新建一个主工程" class="headerlink" title="1、新建一个主工程"></a>1、新建一个主工程</h2><p><br></p><h2 id="2、新建一个Library工程"><a href="#2、新建一个Library工程" class="headerlink" title="2、新建一个Library工程"></a>2、新建一个Library工程</h2><p><br></p><h2 id="3、将静态库工程拖到主工程文件夹下"><a href="#3、将静态库工程拖到主工程文件夹下" class="headerlink" title="3、将静态库工程拖到主工程文件夹下"></a>3、将静态库工程拖到主工程文件夹下</h2><blockquote><p>如果你要拖到其他目录，就要改Library Search Paths<br><img src="https://upload-images.jianshu.io/upload_images/1120923-cce04359a1bbfaad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><br></p></blockquote><h2 id="4、将Library工程下-a文件拖入主工程的Link-Binary-With-Libraries"><a href="#4、将Library工程下-a文件拖入主工程的Link-Binary-With-Libraries" class="headerlink" title="4、将Library工程下.a文件拖入主工程的Link Binary With Libraries"></a>4、将Library工程下.a文件拖入主工程的Link Binary With Libraries</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-a5abaa5e64aee935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果有必要（运行时崩溃），将静态库需要加入 Embedded Binaries 中<br><img src="https://upload-images.jianshu.io/upload_images/1120923-a187820d28065970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="5-主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"><a href="#5-主工程添加对子工程的依赖，避免每次修改都要手动编译子工程" class="headerlink" title="5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"></a>5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程</h2><p>如下图给主工程添加对子工程的依赖，这样每次编译主工程的时候也会编译子工程。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-014ee57b806790ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><br></p><hr><h1 id="三、在静态库中使用图片以及-xib-等资源文件"><a href="#三、在静态库中使用图片以及-xib-等资源文件" class="headerlink" title="三、在静态库中使用图片以及 xib 等资源文件"></a>三、在静态库中使用图片以及 xib 等资源文件</h1><h2 id="1、添加-Bundle-Target"><a href="#1、添加-Bundle-Target" class="headerlink" title="1、添加 Bundle Target"></a>1、添加 Bundle Target</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-0daa863f0f458a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>因为iOS框架中没有bundle，要选中OS X框架找到bundle，如下图<br><img src="https://upload-images.jianshu.io/upload_images/1120923-271a68244a055813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h2 id="2、将资源文件加入-bundle-中"><a href="#2、将资源文件加入-bundle-中" class="headerlink" title="2、将资源文件加入 bundle 中"></a>2、将资源文件加入 bundle 中</h2><p>将工程中的资源文件都加入到刚刚建的bundle中，如xib、图片。点+号或直接拖都行。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-54e9d8ebb8086020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="3、iOS-Deployment-Target改为你支持的最低版本"><a href="#3、iOS-Deployment-Target改为你支持的最低版本" class="headerlink" title="3、iOS Deployment Target改为你支持的最低版本"></a>3、iOS Deployment Target改为你支持的最低版本</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-acc55ab1a1c172ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="4、设置base-SDK-为latest-iOS"><a href="#4、设置base-SDK-为latest-iOS" class="headerlink" title="4、设置base SDK 为latest iOS"></a>4、设置base SDK 为latest iOS</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-935ccc7c15d9dd90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="5、编译-Bundle"><a href="#5、编译-Bundle" class="headerlink" title="5、编译 Bundle"></a>5、编译 Bundle</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-89b0b426acb67a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"><a href="#6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程" class="headerlink" title="6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"></a>6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5e09392ed9b3954c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="7、加载-Bundle-里的资源文件"><a href="#7、加载-Bundle-里的资源文件" class="headerlink" title="7、加载 Bundle 里的资源文件"></a>7、加载 Bundle 里的资源文件</h2><h3 id="7-1、加载图片"><a href="#7-1、加载图片" class="headerlink" title="7.1、加载图片"></a>7.1、加载图片</h3><p>使用运行时替换 <code>[UIImage imageNamed:]</code>方法，减少修改代码的工作量。<br>相关代码在以下几个类中<br><img src="https://upload-images.jianshu.io/upload_images/1120923-d22158e1d55e1cab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在AppDelegate中执行以下代码即可swizzle 所有 [UIImage imageNamed:]</span><br><span class="line"></span><br><span class="line">#import &quot;UIImage+Swizzle.h&quot;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    [UIImage kk_autoLoadImageInBundle];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>UIImage+Swizzle.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  </span><br><span class="line">// 修改所有的 [UIImage imageNamed:]的实现，改为先从同一项目中的 .bundle 文件中加载，没有再使用系统默认实现加载</span><br><span class="line">+ (void)kk_autoLoadImageInBundle &#123;</span><br><span class="line">    SEL original = @selector(imageNamed:);</span><br><span class="line">    SEL new = @selector(hook_kk_imageWithName:);</span><br><span class="line">    [self kk_swizzleClassMethod:original with:new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1. 从 .bundle 中加载图片</span><br><span class="line">// 2. 按照默认的方法加载图片</span><br><span class="line">+ (instancetype)hook_kk_imageWithName:(NSString *)imageName &#123;</span><br><span class="line">    UIImage *image = [NSBundle kk_imageInBundle:kk_BundleName imageName:imageName];</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        image = [self hook_kk_imageWithName:imageName];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>NSObject+Swizzle.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSObject+Swizzle.h&quot;</span><br><span class="line">#import &lt;objc/objc.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)kk_swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel &#123;</span><br><span class="line">    Class class = object_getClass(self);</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, originalSel);</span><br><span class="line">    Method newMethod = class_getInstanceMethod(class, newSel);</span><br><span class="line"></span><br><span class="line">    if (!originalMethod || !newMethod) return NO;</span><br><span class="line">    method_exchangeImplementations(originalMethod, newMethod);</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)kk_swizzleClassMethod:(SEL)originalSel with:(SEL)newSel &#123;</span><br><span class="line">    Class class = object_getClass(self);</span><br><span class="line">    Method originalMethod = class_getClassMethod(class, originalSel);</span><br><span class="line">    Method newMethod = class_getClassMethod(class, newSel);</span><br><span class="line">    </span><br><span class="line">    if (!originalMethod || !newMethod) return NO;</span><br><span class="line">    method_exchangeImplementations(originalMethod, newMethod);</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-2、加载-xib"><a href="#7-2、加载-xib" class="headerlink" title="7.2、加载 xib"></a>7.2、加载 <code>xib</code></h3><h4 id="7-2-1-加载xib对应的UIViewController"><a href="#7-2-1-加载xib对应的UIViewController" class="headerlink" title="7.2.1 加载xib对应的UIViewController"></a>7.2.1 加载xib对应的<code>UIViewController</code></h4><p>需要重写xib对应控制器的 init 方法，否则可能出现找不到xib文件导致crash<br>参考<a href="http://www.jianshu.com/p/a8c9e52c80de" target="_blank" rel="noopener">bundle打包xib文件</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line"></span><br><span class="line">    NSBundle *bundle = [NSBundle kk_bundleWithName:kBundleTargetName];</span><br><span class="line"></span><br><span class="line">    self = [super initWithNibName:@&quot;CalculatePriceViewController&quot; bundle:bundle];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码参见：<a href="[https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h">github</a>](<a href="https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)" target="_blank" rel="noopener">https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)</a>)</p><h4 id="7-2-1-加载xib对应的UIVIew"><a href="#7-2-1-加载xib对应的UIVIew" class="headerlink" title="7.2.1 加载xib对应的UIVIew"></a>7.2.1 加载xib对应的<code>UIVIew</code></h4><p>需要重写xib对应View的 init 方法，，否则可能出现找不到xib文件导致crash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation OfflineView</span><br><span class="line"></span><br><span class="line">//重写要加载的view的init方法</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        NSBundle *bundle = [NSBundle kk_bundleWithName:kk_BundleName];</span><br><span class="line">        self = [[bundle loadNibNamed:@&quot;OfflineView&quot; owner:self options:nil] lastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h3 id="7-3、加载-Localizable-strings"><a href="#7-3、加载-Localizable-strings" class="headerlink" title="7.3、加载 Localizable.strings"></a>7.3、加载 <code>Localizable.strings</code></h3><h4 id="第一步：在Bundle中新建国际化文件"><a href="#第一步：在Bundle中新建国际化文件" class="headerlink" title="第一步：在Bundle中新建国际化文件"></a>第一步：在Bundle中新建国际化文件</h4><p><img src="https://upload-images.jianshu.io/upload_images/1120923-6f11bf3b8f5d2236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="第二步：添加语言，并将之前的国际化文件中的代码复制过来"><a href="#第二步：添加语言，并将之前的国际化文件中的代码复制过来" class="headerlink" title="第二步：添加语言，并将之前的国际化文件中的代码复制过来"></a>第二步：添加语言，并将之前的国际化文件中的代码复制过来</h4><p><img src="https://upload-images.jianshu.io/upload_images/1120923-37cc110dd92a5079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>使用 NSBundle+Resource 如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)mj_localizedStringForKey:(NSString *)key;</span><br><span class="line">+ (NSString *)mj_localizedStringForKey:(NSString *)key value:(NSString *)value;</span><br></pre></td></tr></table></figure></p><p>然后使用如下宏定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 加载 Bundle 中的国际化语句</span><br><span class="line">#undef NSLocalizedString</span><br><span class="line">#define NSLocalizedString(key, comment) \</span><br><span class="line">[NSBundle mj_localizedStringForKey:(key)]</span><br></pre></td></tr></table></figure></p><p>然后就可以自动的加载Bundle中的字符串了</p><p><br></p><hr><h1 id="四、将整个App打包为Framework"><a href="#四、将整个App打包为Framework" class="headerlink" title="四、将整个App打包为Framework"></a>四、将整个App打包为Framework</h1><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ol><li>整个项目都要解除 AppDelegate 的依赖，AppDelegate不能打入Framework中</li><li>图片和xib文件需要按照 三 中的处理</li><li>可以使用 runtime 动态加载图片和xib文件，减少工作量</li><li>注意点：bundle中的国际化文件需要重新新建，添加语言，然后将之前App中的内容复制过来，直接拖进去是无效的</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1120923-57f527356830710e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="实际操作中存在的问题"><a href="#实际操作中存在的问题" class="headerlink" title="实际操作中存在的问题"></a>实际操作中存在的问题</h2><ol><li>图片同时存在@2x和@3x后缀导致加载的图片为nil的问题<br>解决办法为只要@2x的图片</li></ol><p><br></p><hr><h1 id="五、使用-appledoc-生成文档"><a href="#五、使用-appledoc-生成文档" class="headerlink" title="五、使用 appledoc 生成文档"></a>五、使用 <code>appledoc</code> 生成文档</h1><p><a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">官网</a></p><ul><li>安装<br><code>brew install appledoc</code></li><li>查看版本<br><code>appledoc --version</code></li><li>查看帮助<br><code>appledoc --help</code></li><li>生成文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appledoc --output ./doc --project-name &quot;D103Framework&quot;  --project-company &quot;RICISUNG&quot; --company-id &quot;RICISUNG&quot; .</span><br></pre></td></tr></table></figure></li></ul><p>”.“ 和前面的符号一定要加 空格 否则就会报错。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-dbc07ae1c94010da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h1 id="iOS-工程套子工程，主工程和framework工程或-a-library静态库工程联调-http-www-cnblogs-com-zhanglinfeng-p-5494762-html"><a href="#iOS-工程套子工程，主工程和framework工程或-a-library静态库工程联调-http-www-cnblogs-com-zhanglinfeng-p-5494762-html" class="headerlink" title="iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调](http://www.cnblogs.com/zhanglinfeng/p/5494762.html))"></a><a href="[http://www.cnblogs.com/zhanglinfeng/p/5494762.html"><a href="http://www.cnblogs.com/zhanglinfeng/p/5494762.html" target="_blank" rel="noopener">iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调</a></a>](<a href="http://www.cnblogs.com/zhanglinfeng/p/5494762.html)" target="_blank" rel="noopener">http://www.cnblogs.com/zhanglinfeng/p/5494762.html)</a>)</h1><h1 id="iOS-framework静态库中使用xib和图片资源详解"><a href="#iOS-framework静态库中使用xib和图片资源详解" class="headerlink" title="iOS framework静态库中使用xib和图片资源详解"></a><a href="http://www.cnblogs.com/zhanglinfeng/p/5510717.html" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/zhanglinfeng/p/5510717.html" target="_blank" rel="noopener">iOS framework静态库中使用xib和图片资源详解</a></a></h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>iOS11新特性</title>
      <link href="/2017/12/22/iOS11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2017/12/22/iOS11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>[TOC]</p><h1 id="iOS11-大标题"><a href="#iOS11-大标题" class="headerlink" title="iOS11 大标题"></a>iOS11 大标题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 导航控制器的`prefersLargeTitles`为大标题的总开关</span><br><span class="line">navigationController?.navigationBar.prefersLargeTitles = true</span><br><span class="line"></span><br><span class="line">// 各个控制器可以自己通过 largeTitleDisplayMode，如果导航控制器的 `prefersLargeTitles` 为 NO，largeTitleDisplayMode 将没有效果</span><br><span class="line">navigationItem.largeTitleDisplayMode = .never</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1120923-d28e28449f722b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="iOS11-导航栏搜索框"><a href="#iOS11-导航栏搜索框" class="headerlink" title="iOS11 导航栏搜索框"></a>iOS11 导航栏搜索框</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let searchResultsVC = SearchResultTabelViewVC(nibName: nil, bundle: nil)</span><br><span class="line">lazy var searchController: UISearchController = &#123;</span><br><span class="line">let vc = UISearchController(searchResultsController: searchResultsVC)</span><br><span class="line">vc.searchResultsUpdater = self.searchResultsVC</span><br><span class="line"></span><br><span class="line">vc.hidesNavigationBarDuringPresentation = true</span><br><span class="line">vc.dimsBackgroundDuringPresentation = true</span><br><span class="line"></span><br><span class="line">vc.searchBar.placeholder = &quot;搜索设备&quot;</span><br><span class="line">vc.searchBar.enablesReturnKeyAutomatically = false</span><br><span class="line">vc.searchBar.sizeToFit()</span><br><span class="line"></span><br><span class="line">return vc</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">navigationItem.searchController = searchController</span><br><span class="line">navigationItem.hidesSearchBarWhenScrolling = false</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1120923-d3ea03b58766402f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-de6a6e4434ad40f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="iOS11-Safe-Area-Insets"><a href="#iOS11-Safe-Area-Insets" class="headerlink" title="iOS11 Safe Area Insets"></a>iOS11 Safe Area Insets</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">additionalSafeAreaInsets = UIEdgeInsets(top: 100, left: 0, bottom: 100, right: 100)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1120923-390517a880546e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="UITableView-separatorInsetReference"><a href="#UITableView-separatorInsetReference" class="headerlink" title="UITableView separatorInsetReference"></a>UITableView separatorInsetReference</h1><p><img src="https://upload-images.jianshu.io/upload_images/1120923-67de438546b61af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1120923-1b6960bbfe07be8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tableView.estimatedRowHeight = 0</span><br><span class="line">tableView.estimatedSectionHeaderHeight = 0</span><br><span class="line">tableView.estimatedSectionFooterHeight = 0</span><br><span class="line"></span><br><span class="line">tableView.separatorInsetReference = .fromAutomaticInsets</span><br><span class="line">tableView.separatorInset.left = 60</span><br></pre></td></tr></table></figure></p><h1 id="UITableViewCell-左划、右划"><a href="#UITableViewCell-左划、右划" class="headerlink" title="UITableViewCell 左划、右划"></a>UITableViewCell 左划、右划</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// iOS11 UITableViewCell 左划</span><br><span class="line">override func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? &#123;</span><br><span class="line">let action = UIContextualAction(style: .normal, title: &quot;收藏&quot;) &#123; (action, view, completionHandler) in</span><br><span class="line">// 执行收藏操作</span><br><span class="line">// ...</span><br><span class="line">completionHandler(true)</span><br><span class="line">&#125;</span><br><span class="line">action.image =  imageLiteral(resourceName: &quot;favorite&quot;)</span><br><span class="line">action.backgroundColor = UIColor.red</span><br><span class="line"></span><br><span class="line">let configuration = UISwipeActionsConfiguration(actions: [action])</span><br><span class="line"></span><br><span class="line">return configuration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// iOS11 UITableViewCell 右划</span><br><span class="line">override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? &#123;</span><br><span class="line">let action = UIContextualAction(style: .destructive, title: &quot;删除&quot;) &#123; (action, view, completionHandler) in</span><br><span class="line">// remove item</span><br><span class="line">// ...</span><br><span class="line">completionHandler(true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let configuration = UISwipeActionsConfiguration(actions: [action])</span><br><span class="line"></span><br><span class="line">return configuration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码见"><a href="#代码见" class="headerlink" title="代码见"></a>代码见</h1><p><a href="https://github.com/action456789/iOS11Demo" target="_blank" rel="noopener">https://github.com/action456789/iOS11Demo</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Mac安装MQTT服务器</title>
      <link href="/2017/03/09/Mac%E5%AE%89%E8%A3%85MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/03/09/Mac%E5%AE%89%E8%A3%85MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="emqttd-windows版安装"><a href="#emqttd-windows版安装" class="headerlink" title="emqttd windows版安装"></a>emqttd windows版安装</h1><p>具体以官方文档为主</p><ol><li>下载<a href="http://emqtt.io/docs/v2/install.html#installing-on-windows" target="_blank" rel="noopener">http://emqtt.io/docs/v2/install.html#installing-on-windows</a></li><li>进入下载后的bin目录下<br><code>cd C:\Users\kk\Desktop\emqttd\bin\</code><br>然后执行<br><code>emqttd console</code></li><li>进入Web管理控制台(Dashboard)<br>控制台地址: <a href="http://127.0.0.1:18083" target="_blank" rel="noopener">http://127.0.0.1:18083</a><br>默认用户: admin，密码：public</li></ol><a id="more"></a><h1 id="或者使用-mosquitto"><a href="#或者使用-mosquitto" class="headerlink" title="或者使用 mosquitto"></a>或者使用 mosquitto</h1><ol><li>安装<br><code>brew install mosquitto</code></li><li>配置服务器<br>进入目录<code>/usr/local/Cellar/mosquitto</code> 进入响应版本下目录，我这里是<code>1.4.11_2</code><br>找到<code>/etc/mosquitto/mosquitto.conf</code>文件，修改<code>mosquitto.conf</code>可以对服务器进行配置</li><li>启动服务器<br>进入sbin目录：<br><code>/usr/local/Cellar/mosquitto/1.4.11_2/sbin</code><br>然后执行：<br><code>./mosquitto -c /usr/local/Cellar/mosquitto/1.4.11_2/etc/mosquitto/mosquitto.conf -d</code></li></ol><p>参考：<a href="http://blog.csdn.net/pz0605/article/details/51970568" target="_blank" rel="noopener">http://blog.csdn.net/pz0605/article/details/51970568</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Autolayout高级</title>
      <link href="/2016/11/09/Autolayout%E9%AB%98%E7%BA%A7/"/>
      <url>/2016/11/09/Autolayout%E9%AB%98%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>[TOC]</p><h1 id="intrinsicContentSize"><a href="#intrinsicContentSize" class="headerlink" title="intrinsicContentSize"></a>intrinsicContentSize</h1><p><code>Intrinsic Content Size</code>：固有大小。意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。</p><p>比如：大家都知道在使用 AutoLayout 的时候，<code>UILabel</code> 就不用指定尺寸大小，只需指定位置即可，就是因为，只要确定了文字内容，字体等信息，它自己就能计算出大小来。</p><blockquote><p><code>UILabel</code>，<code>UIImageView</code>，<code>UIButton</code> 等组件及某些包含它们的系统组件都有 Intrinsic Content Size 属性。</p></blockquote><h1 id="Content-Hugging-约束（不想变大约束）"><a href="#Content-Hugging-约束（不想变大约束）" class="headerlink" title="Content Hugging 约束（不想变大约束）"></a><code>Content Hugging</code> 约束（不想变大约束）</h1><p>如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要拉伸的时候拉伸。</p><h1 id="Content-Compression-Resistance-约束（不想变小约束）"><a href="#Content-Compression-Resistance-约束（不想变小约束）" class="headerlink" title="Content Compression Resistance 约束（不想变小约束）"></a><code>Content Compression Resistance</code> 约束（不想变小约束）</h1><p>如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要压缩的时候压缩。</p><p>例如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-143170678a0a5d2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Top-Layout-Guide"><a href="#Top-Layout-Guide" class="headerlink" title="Top Layout Guide"></a><code>Top Layout Guide</code></h1><p><code>topLayoutGuide</code>属性表示不希望被透明的状态栏或导航栏遮挡的内容范围的最高位置。这个属性的值是它的length属性的值（topLayoutGuide.length）</p><p>这个值可能由当前的ViewController或这个ViewController所属的NavigationController或TabBarController决定，有如下情况：</p><ol><li>一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。</li><li>包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义：</li></ol><blockquote><ol><li>如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。</li><li>如果状态栏可见，topLayoutGuide表示状态栏的底部。</li><li>如果都不可见，表示ViewController的上边缘。</li></ol></blockquote><p>总之是屏幕上方任何遮挡内容的栏的最底部。</p><h1 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h1><p>*作用：取代<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>**</p><p><code>safeArea</code>是描述你的视图部分不被任何内容遮挡的方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-4bfd008744e885e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="改变布局的方法"><a href="#改变布局的方法" class="headerlink" title="改变布局的方法"></a>改变布局的方法</h1><h2 id="一、-setNeedsLayout与layoutIfNeeded"><a href="#一、-setNeedsLayout与layoutIfNeeded" class="headerlink" title="一、 setNeedsLayout与layoutIfNeeded"></a>一、 <code>setNeedsLayout</code>与<code>layoutIfNeeded</code></h2><p>更新Autolayout后，如何要立即刷新布局，还要依次调用以下两个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 立即刷新布局（自己和subview的）</span><br><span class="line"></span><br><span class="line">self.view.setNeedsLayout()</span><br><span class="line"></span><br><span class="line">self.view.layoutIfNeeded()</span><br></pre></td></tr></table></figure><p><code>setNeedsLayout</code>给当前 UIView 立一个 flag，以表示后续应该调用 <code>layoutSubviews</code>方法，以调整当前视图及其子视图的布局。</p><p><code>layoutIfNeeded</code>如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）</p><h2 id="二、-layoutSubviews"><a href="#二、-layoutSubviews" class="headerlink" title="二、 layoutSubviews"></a>二、 <code>layoutSubviews</code></h2><h3 id="触发时机——Frame改变就会触发，具体如下"><a href="#触发时机——Frame改变就会触发，具体如下" class="headerlink" title="触发时机——Frame改变就会触发，具体如下"></a>触发时机——Frame改变就会触发，具体如下</h3><ol><li><p>初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发</p></li><li><p>addSubview会触发layoutSubviews</p></li><li><p>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化</p></li><li><p>滚动一个UIScrollView会触发layoutSubviews</p></li><li><p>旋转Screen会触发父UIView上的layoutSubviews事件</p></li><li><p>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p></li></ol><h3 id="何时重写-layoutSubviews-方法"><a href="#何时重写-layoutSubviews-方法" class="headerlink" title="何时重写 layoutSubviews 方法"></a>何时重写 <code>layoutSubviews</code> 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们在某个类的内部调整子视图位置时，需要调用；如果你想要在外部设置subviews的位置，就不要重写。</span><br></pre></td></tr></table></figure><h2 id="三、sizeToFit"><a href="#三、sizeToFit" class="headerlink" title="三、sizeToFit"></a>三、<code>sizeToFit</code></h2><p>调用sizeToFit的时候，系统会根据内容的帮我布局一个它认为最合适的大小。</p><p>我们一般在不方便手动布局的时候才调用sizeToFit方法。比如</p><ol><li><p>navigationBar中对navigationItem的设置，（添加两个视图以上的控件到Item）</p></li><li><p>toolBar中的对UIBarButtonItem的设置（一般我们还要添加弹簧控件）</p></li></ol><p>上述两种场合就可以用sizeToFit这个方法，来让系统给我们做自动布局。（注意：如果就添加一个控件的话，我们直接设置fram也是可以的）</p><ol start="3"><li><p>在tabBar中我们不能手动的添加的子控件，因为tabBar是根据控制器系统默认自动添加的tabBarItem。（猜想系统可能也会自动调用了这个方法）</p></li><li><p>UILabel中添加文字，然后让调整label的大小来适应文字，我们也调用sizeToFit的方法。</p></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>iOS调试内存泄露</title>
      <link href="/2016/10/09/iOS%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2016/10/09/iOS%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Xcode8使用Memory-Graph"><a href="#Xcode8使用Memory-Graph" class="headerlink" title="Xcode8使用Memory Graph"></a>Xcode8使用Memory Graph</h1><ul><li><p>第一步：真机下运行APP后，点击<br><img src="https://upload-images.jianshu.io/upload_images/1120923-296131fcf6ffee5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第二步：查看issue面板，注意选择右边Runtime<br><img src="https://upload-images.jianshu.io/upload_images/1120923-8ee8fe78474da0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第三步：查看可能出现的内存泄露<br>比如上图的 <code>1 instance of __NSMallocBlock_leaked</code>，点击后出现下图<br><img src="https://upload-images.jianshu.io/upload_images/1120923-7765184c6159e657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>原因在于如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">group.didSelectedRowBlock = &#123; [unowned self, group] row in</span><br><span class="line">guard let indexPaths = group.selectedIndexPaths else &#123;return&#125;</span><br><span class="line">if indexPaths.count &gt; 0 &#123;</span><br><span class="line">self.shouldAdd = true</span><br><span class="line">let row = (indexPaths.firstObject as! IndexPath).row</span><br><span class="line">self.deviceAttri?.attrValue = String(row)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">self.shouldAdd = false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>group的block中又使用了group，导致了循环引用，虽然使用了[unowned group]，事实证明并没有效果<br>最后的解决办法是修改didSelectedRowBlock的接口，直接将selectedIndexPaths参数传入block参数中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">group.didSelectedRowBlock = &#123; [unowned self] indexPaths in</span><br><span class="line">guard let indexPaths = indexPaths else &#123;return&#125;</span><br><span class="line">if indexPaths.count &gt; 0 &#123;</span><br><span class="line">self.shouldAdd = true</span><br><span class="line">self.deviceAttri?.attrValue = String(indexPaths.first!.row)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">self.shouldAdd = false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>第四步：在 debug 页面查看内存泄露情况<br><img src="https://upload-images.jianshu.io/upload_images/1120923-5d076268da519675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>有叹号说明需要注意可能存在内存泄露，可以看到 CoreFoundation中也可能存在内存泄露情况</li></ul><h1 id="使用Instruments的Leaks工具"><a href="#使用Instruments的Leaks工具" class="headerlink" title="使用Instruments的Leaks工具"></a>使用Instruments的Leaks工具</h1><h2 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a><code>Time Profiler</code></h2><ul><li>查看多个线程里那些方法费时过多的方法</li><li>Call Tree上会默认按照费时的线程进行排序，单个线程中会也会按照对应的费时方法排序<br><img src="https://upload-images.jianshu.io/upload_images/1120923-b7b30c7aedac7d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h2 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a><code>Allocations</code></h2><ul><li>可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置</li><li>具体操作</li></ul><ol><li>在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，</li><li>切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，</li><li>这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。</li></ol><h2 id="Leak"><a href="#Leak" class="headerlink" title="Leak"></a>Leak</h2><p>可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的<code>Statistics&gt;Allocation Summary</code>能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。</p><h1 id="其他调试方法"><a href="#其他调试方法" class="headerlink" title="其他调试方法"></a>其他调试方法</h1><h2 id="勾选Address-Sanitizer可以在运行时看到坏内存访问情况"><a href="#勾选Address-Sanitizer可以在运行时看到坏内存访问情况" class="headerlink" title="勾选Address Sanitizer可以在运行时看到坏内存访问情况"></a>勾选<code>Address Sanitizer</code>可以在运行时看到坏内存访问情况</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-a6440da959e589ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>使用WireShark 调试真机网络</title>
      <link href="/2016/10/09/%E4%BD%BF%E7%94%A8WireShark-%E8%B0%83%E8%AF%95%E7%9C%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2016/10/09/%E4%BD%BF%E7%94%A8WireShark-%E8%B0%83%E8%AF%95%E7%9C%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<h1 id="使用WireShark-调试真机网络"><a href="#使用WireShark-调试真机网络" class="headerlink" title="使用WireShark 调试真机网络"></a>使用WireShark 调试真机网络</h1><p>需求：调试UIWebView加载缓慢问题</p><ul><li><ol><li>获取iPhone的UDID<br><img src="https://upload-images.jianshu.io/upload_images/1120923-d7d6872480927c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol></li><li><p>2：根据获取的 UDID 创建一个虚拟的网卡<br><code>rvictl -s &lt;UDID&gt;</code><br><img src="https://upload-images.jianshu.io/upload_images/1120923-f7f78d28cb94eda6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>通过 <code>ifconfig</code> 可以看到多了一个 <code>rvi0</code>接口<br>通过 <code>rvictl -l</code> 命令可以列出所有挂接的虚拟接口</p><ul><li>3: 在 Wireshark 首页选择 rvi0，使用默认的 Capture Options 即可开始对 iPhone 进行抓包。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-602c6eb7b8e0f13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>其中 iPhone 手机连接 WiFi 动态获取的 IP 地址为 192.168.100.1。</p><blockquote><p>黑色的内容表示遇到错误，需要重点关注<br>关闭wifi，可以抓取移动网络数据包</p></blockquote><p>-4 ： 使用<code>rvictl  -x</code>命令删除虚拟接口, 使用 iPhone 的 UDID 作为参数。</p><h1 id="WireShark-抓包技巧"><a href="#WireShark-抓包技巧" class="headerlink" title="WireShark 抓包技巧"></a>WireShark 抓包技巧</h1><ul><li>第一步：找到请求网址的 IP 地址<br>方法一：用ping命令得到对应的IP地址（可能不对，此时要用方法二）<br><img src="https://upload-images.jianshu.io/upload_images/1120923-4ff29746a38a13a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>方法二：使用DNS包来确定IP地址</p><blockquote><p>注意手机上 DNS 解析的结果并不总是和电脑上的解析结果一致。这种情况下我们可以通过查看 DNS 数据包来确定<br>DNS 是基于 UDP 的协议，不会有 TCP 重传</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1120923-368232f0c1e87923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>第二步：过滤 IP 地址<br><img src="https://upload-images.jianshu.io/upload_images/1120923-78b3a639da943708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第三步：确定端口号<br><img src="https://upload-images.jianshu.io/upload_images/1120923-730d2741f957db51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>注意红框中的 <strong>SourcePort</strong>，这是客户端端口。我们知道 HTTP 支持并发请求，不同的并发请求肯定是占用不同的端口。所以在图中看到的上下两个数据包，并非一定是请求与响应的关系，他们可能属于两个不同的端口，彼此之间毫无关系，只是恰好在时间上最接近而已。</p><blockquote><p>如果只想显示某个端口的数据，可以使用:</p></blockquote><p><code>ip.addr == 220.194.203.68 and tcp.dstport == 52914</code></p><blockquote><p>如果只想看 HTTP 协议的 GET 请求与响应，可以使用 </p></blockquote><p><code></code>ip.addr == 220.194.203.68 and (http.request.method == “GET” || http.response.code == 200)<code></code>来过滤。</p><blockquote><p>如果想看丢包方面的数据，可以用 </p></blockquote><p><code>ip.addr == 220.194.203.68 and (tcp.analysis.fast_retransmission || tcp.analysis.retransmission)</code></p><p><code># 参考</code></p><p><a href="http://ios.jobbole.com/93159/" target="_blank" rel="noopener">http://ios.jobbole.com/93159/</a></p><p><a href="http://blog.csdn.net/phunxm/article/details/38590561" target="_blank" rel="noopener">http://blog.csdn.net/phunxm/article/details/38590561</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>如何更新React Native</title>
      <link href="/2016/04/12/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0React-Native/"/>
      <url>/2016/04/12/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0React-Native/</url>
      <content type="html"><![CDATA[<blockquote><p>最新的React Native已经更新到了0.33.0，如何更新自己已经搭建好的React Native开发环境呢，我按照以下步骤完成了更新，现记录下来，供有需要的人参考。</p></blockquote><h2 id="1-查看-react-native-的最新版本。"><a href="#1-查看-react-native-的最新版本。" class="headerlink" title="1.查看 react native 的最新版本。"></a>1.查看 react native 的最新版本。</h2><p>进入项目根目录，命令行执行<br><code>npm info react-native</code></p><p>查看当前版本<code>react-native --version</code></p><h2 id="2-在项目目录下修改package-json文件，将下列代码中的-react-native-改为最新版本"><a href="#2-在项目目录下修改package-json文件，将下列代码中的-react-native-改为最新版本" class="headerlink" title="2.在项目目录下修改package.json文件，将下列代码中的 react-native 改为最新版本"></a>2.在项目目录下修改<code>package.json</code>文件，将下列代码中的 react-native 改为最新版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">      &quot;react&quot;: &quot;^0.14.8&quot;,</span><br><span class="line">          &quot;react-native&quot;: &quot;^0.33.0&quot;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><pre><code>## 3. 命令行执行`npm install --save react-native@0.33.0`如果升级后出现类似于`react-native@0.33.0 requires a peer of react@~15.3.1 but none was installed.`执行`npm install --save react@~15.3.1`## 4. 运行程序如果更新后执行react-native run-android不能正确运行，而是出现类似： Could not find com.facebook.react:react-native:0.23.0. 错误，或者在Android Studio中直接运行app时报错： Android Studio failed to resolve com.facebook.react:react-native:0.23.0 那么可以按照下列命令修复，首先在命令行中执行： `npm i` 执行完毕且不报错后，执行下面的命令，**注意，在执行命令之后，某些文件可能会产生冲突，请确保你的本地文件记录可以恢复**（在Android Studio中可以查看历史记录来恢复文件） `react-native upgrade` 执行上面的命令可能会提示你是否覆盖文件。在解决冲突之后重新运行App即可。 ## 如果还有问题，可以更新一下npm和Node.js再试 - 如何更新npm `npm install -g npm` - 如何更新Node.js `npm update node.js`</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hexo GitHub博客搭建</title>
      <link href="/2015/09/09/Hexo-GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2015/09/09/Hexo-GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>[TOC]</p><h1 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>1、安装<code>Node.js</code><br><a href="https://blog.csdn.net/u011619283/article/details/52368759" target="_blank" rel="noopener">https://blog.csdn.net/u011619283/article/details/52368759</a></p></li><li><p>2、安装hexo<br><code>npm install -g hexo-cli</code></p></li></ul><h1 id="本地站点搭建"><a href="#本地站点搭建" class="headerlink" title="本地站点搭建"></a>本地站点搭建</h1><ul><li><p>1、初始化 Hexo<br>进入自己创建的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></li><li><p>2、生成静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li><li><p>3、启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>4、查看效果<br>打开浏览器，输入 <code>http://localhost:4000/</code></p></li></ul><h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h1><ul><li><p>1、创建仓库<br>仓库名称固定格式如下：<br><code>yourGitbubUsername.github.io</code><br>注意yourGitbubUsername必须与你的github用户名相同，否则无法部署</p></li><li><p>2、安装github部署器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure></li><li><p>3、修改本地配置文件<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/action456789/action456789.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li><li><p>4、部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>5、测试<br>部署成功以后，在浏览器中输入 <a href="http://action456789.github.io" target="_blank" rel="noopener">http://action456789.github.io</a> 即可在线浏览自己的博客啦</p></li></ul><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p><a href="https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html（亲测可行）" target="_blank" rel="noopener">https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html（亲测可行）</a></p><h1 id="修改主题后"><a href="#修改主题后" class="headerlink" title="修改主题后"></a>修改主题后</h1><p>输入<code>hexo s --debug</code>进行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo generate </span><br><span class="line">hexo server (若是想本地预览和执行该命令预览) </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><h1 id="博客的创建、修改与删除"><a href="#博客的创建、修改与删除" class="headerlink" title="博客的创建、修改与删除"></a>博客的创建、修改与删除</h1><ul><li><p>1、创建新博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;test_blog&quot;</span><br></pre></td></tr></table></figure></li><li><p>删除博客<br>删除博客文件后重新发布更新即可<br>可能需要等几分钟才有效果</p></li><li><p>2、发布更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>3、一些快捷键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g == hexo generate</span><br><span class="line">hexo d == hexo deploy</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo n == hexo new</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>iOS中的时间</title>
      <link href="/2015/08/12/iOS%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4/"/>
      <url>/2015/08/12/iOS%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<p>[TOC]</p><h1 id="设备开机后的时间"><a href="#设备开机后的时间" class="headerlink" title="设备开机后的时间"></a>设备开机后的时间</h1><ul><li><code>CACurrentMediaTime()</code></li></ul><p>设备从开机时起到现在的时间，设备重启会重置，单位为秒</p><ul><li><code>[[NSProcessInfo processInfo] systemUptime]</code> </li></ul><p>与<code>CACurrentMediaTime()</code>等价</p><h1 id="相对某个参考系的时间"><a href="#相对某个参考系的时间" class="headerlink" title="相对某个参考系的时间"></a>相对某个参考系的时间</h1><ul><li><code>Date().timeIntervalSince1970</code> </li></ul><p>1970年1月1日凌晨为参考系，到现在的时间，一般用于表示时间戳</p><p><br></p><ul><li><code>Date().timeIntervalSinceReferenceDate</code></li></ul><p>世界时间（UTC）2001年1月1日凌晨到现在经过的时间，单位为秒</p><p><br></p><ul><li><code>CFAbsoluteTimeGetCurrent()</code></li></ul><p>与<code>Date().timeIntervalSinceReferenceDate</code>等价</p><p><br></p><blockquote><p>当用户手动改变了设备上的系统时间后，基于系统时钟的上述方法返回的结果也会一同改变</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">CACurrentMediaTime</span>()) <span class="comment">// 设备刚重启</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Date</span>().timeIntervalSince1970)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Date</span>().timeIntervalSinceReferenceDate)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">CFAbsoluteTimeGetCurrent</span>())</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1120923-1bb36e607297d7c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="必要时，从服务器上获取时间"><a href="#必要时，从服务器上获取时间" class="headerlink" title="必要时，从服务器上获取时间"></a>必要时，从服务器上获取时间</h1><p>如果App本身对获取的时间精度要求很高，还是直接通过网络从服务器获取时间戳会比较保险。</p><p>当网络可用时，直接从服务器获取；</p><p>网络不可用时，且设备没有被重启过，可以根据上一次获取服务器时间戳的时刻到此时的时间差来推算出正确的时间</p>]]></content>
      
      
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱工作·爱生活</title>
  
  <subtitle>action456789</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://superkk.top/"/>
  <updated>2019-08-29T09:07:04.749Z</updated>
  <id>http://superkk.top/</id>
  
  <author>
    <name>action456789</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组件化模块间通信方案</title>
    <link href="http://superkk.top/2018/08/22/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%9D%97%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://superkk.top/2018/08/22/组件化模块间通信方案/</id>
    <published>2018-08-21T17:12:20.000Z</published>
    <updated>2019-08-29T09:07:04.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件化模块间通信方案"><a href="#组件化模块间通信方案" class="headerlink" title="组件化模块间通信方案"></a>组件化模块间通信方案</h1><h3 id="1、公共模块下沉"><a href="#1、公共模块下沉" class="headerlink" title="1、公共模块下沉"></a>1、公共模块下沉</h3><p>比如一些公共的基础UI组件应该互相独立，并且可以下沉为一个单独的层（比如通用业务层），供其他业务模块调用。</p><h3 id="2、OpenURL统跳协议"><a href="#2、OpenURL统跳协议" class="headerlink" title="2、OpenURL统跳协议"></a>2、<code>OpenURL统跳协议</code></h3><p>用一个url表示一个页面（Controller），或者UI控件，或者任意一个类的对象。</p><p>需要创建一个字典，key是url，value是相应的对象，这个字典由路由类去管理，典型的方案就是<code>MGJRouter</code>。</p><ul><li><p>优点：能解决组件间的依赖，并且方案成熟，有很多知名公司都在用这种方案（蘑菇街）；</p></li><li><p>缺点：编译阶段无法发现潜在bug，并且需要去注册&amp;维护路由表。</p></li></ul><pre><code class="Objective-C">// 注册路由[[Router sharedInstance] registerURL:@&quot;myapp://good/detail&quot; with:^UIViewController *{     return [GoodDetailViewController new];}];// 通过url获取UIViewController *vc = [[Router sharedInstance] openURL:@&quot;myapp://good/detail&quot;]</code></pre><p><a href="https://www.jianshu.com/p/2af9c063fd85" target="_blank" rel="noopener">参考</a></p><h3 id="3、Target-Action-反射"><a href="#3、Target-Action-反射" class="headerlink" title="3、Target-Action(反射)"></a>3、<code>Target-Action</code>(反射)</h3><p>例如从A中push到BViewController，需要在AViewController类文件中import进BViewController，这样二者就会产生耦合<br>现在利用Target-Action机制，我们不再直接import进BViewController，而是利用<code>NSClassFromString(&lt;#NSString * _Nonnull aClassName#&gt;)</code>这个api将BViewController这个字符串反射成BViewController这个类，这样我们就可以根据反射后的类进行实例化，再调用实例化对象的各种方法。</p><ul><li>优点：相比于URL Router，Target-Action也不需要注册和内存占用。</li><li>缺点：编译阶段无法发现潜在的BUG，而且，开发者所创建的类和定义的方法必须要遵守Target-Action的命名规则，调用者可能会因为硬编码问题导致调用失败。</li></ul><p>第三方框架有<code>CTMediator</code>和<code>BeeHive</code>在github</p><h3 id="4、NSNotificationCenter"><a href="#4、NSNotificationCenter" class="headerlink" title="4、NSNotificationCenter"></a>4、<code>NSNotificationCenter</code></h3><ul><li>优点：简单直接。</li><li>缺点：遍地都是通知，如果同事间协调不好会使得代码很混乱。</li></ul><h3 id="5、依赖注入：推荐方法"><a href="#5、依赖注入：推荐方法" class="headerlink" title="5、依赖注入：推荐方法"></a>5、<code>依赖注入</code>：推荐方法</h3><p>比如业务C将自己注入中间层，业务A去中间层去获取依赖的方法和变量。</p><ul><li>实现方式：通过中间层协议实现<br>业务B遵从这个协议，实现协议的代理方法，返回与中间层商量好的一个实际对象。<br>业务A通过中间层的某个方法（与B商量），获取遵从了这个协议的实例B，将其当做一个遵从了这个协议的透明对象来使用。</li><li><p>编程实现：具体运用了java的<code>面向接口编程`</code>Protocol - Class<code>，即iOS的</code>面向协议编程`</p></li><li><p>优点：<br>1、接口类似代码，可以非常灵活的定义函数和回调等。</p></li><li><p>缺点：<br>1、接口定义文件需要放在一个模块以供依赖，但是这个模块不会贡献代码，所以还好。<br>2、使用较为麻烦，每各调用都需要定义一个service，并实现, 对于一些具有普适性规律的场景不太合适，比如页面统一跳转</p></li><li><p>面向接口的调用会产生依赖<br><code>`</code>Objective-C<br>// A 模块</p></li><li>(void)getSomeDataFromB {<br>  B.getSomeData();<br>}</li></ul><p>// B 模块</p><ul><li>(void)getSomeData {<br>  return self.data;<br>}<br><code>`</code></li></ul><ul><li>示例<br><code>ServiceBProtocol</code><pre><code class="Swift">protocol ServiceBProtocol {  func getSomeDataFromServiceB() -&gt; String;}</code></pre></li></ul><p><code>MiddleLayer</code></p><pre><code class="Swift">class MiddleLayer: NSObject {    class func findServiceB() -&gt; ServiceBProtocol {        return ServiceB()    }}</code></pre><p><code>ServiceB</code></p><pre><code class="Swift">// 模块Bclass ServiceB: NSObject {    let serviceB_Data = &quot;ServiceB&quot;}extension ServiceB: ServiceBProtocol {    func getSomeDataFromServiceB() -&gt; String {        return self.serviceB_Data    }}</code></pre><p><code>ServiceA</code></p><pre><code class="Swift">// 模块Aclass ServiceA: NSObject {    func getDataFromB() {        print(MiddleLayer.findServiceB().getSomeDataFromServiceB())    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组件化模块间通信方案&quot;&gt;&lt;a href=&quot;#组件化模块间通信方案&quot; class=&quot;headerlink&quot; title=&quot;组件化模块间通信方案&quot;&gt;&lt;/a&gt;组件化模块间通信方案&lt;/h1&gt;&lt;h3 id=&quot;1、公共模块下沉&quot;&gt;&lt;a href=&quot;#1、公共模块下沉&quot; cla
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="高级" scheme="http://superkk.top/categories/iOS/%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa冷热信号详解</title>
    <link href="http://superkk.top/2018/07/30/ReactiveCocoa%E5%86%B7%E7%83%AD%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://superkk.top/2018/07/30/ReactiveCocoa冷热信号详解/</id>
    <published>2018-07-30T12:08:40.000Z</published>
    <updated>2019-08-29T09:07:04.741Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>函数响应式编程(Functional Reactive Programming:FRP)，ReactiveCocoa 版本 2.5</p><h1 id="冷热信号"><a href="#冷热信号" class="headerlink" title="冷热信号"></a>冷热信号</h1><ul><li><p>冷信号<br>只有当你订阅的时候，它才会发布消息，<br>一对一，当有不同的订阅者，消息是重新完整发送。</p></li><li><p>热信号<br>尽管你并没有订阅事件，但是它会时刻推送，类似“直播”，错过了就不再处理。<br>可以有多个订阅者，是一对多</p></li></ul><h1 id="RACSignal-与RACSubject-的区别"><a href="#RACSignal-与RACSubject-的区别" class="headerlink" title="RACSignal 与RACSubject 的区别"></a><code>RACSignal</code> 与<code>RACSubject</code> 的区别</h1><ul><li><code>RACSignal</code>是冷信号</li><li><code>RACSubject</code>是热信号</li></ul><p>如下图</p><ul><li><code>signal</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-cba016d495b9a1b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><code>subject</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5974af889c88a7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><code>replaySubject</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-282c50256b5bae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>Subject可以附加行为，例如<code>RACReplaySubject</code>具备为未来订阅者缓冲事件的能力。（这一点与冷信号类似，即使是在数据发送之后才订阅的，依然会收到全部消息）</p></blockquote><h1 id="冷信号示例：延时订阅，依然能收到所有信号数据"><a href="#冷信号示例：延时订阅，依然能收到所有信号数据" class="headerlink" title="冷信号示例：延时订阅，依然能收到所有信号数据"></a>冷信号示例：延时订阅，依然能收到所有信号数据</h1><pre><code>- (void)test1 {    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [subscriber sendNext:@1];        [subscriber sendNext:@2];        [subscriber sendNext:@3];        [subscriber sendCompleted];        return nil;    }];    NSLog(@&quot;Signal was created.&quot;);    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber1 recveive: %@&quot;, x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber2 recveive: %@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-419d5730a235a595.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="热信号示例：错过了订阅时机，就收不到信号数据，类似于直播"><a href="#热信号示例：错过了订阅时机，就收不到信号数据，类似于直播" class="headerlink" title="热信号示例：错过了订阅时机，就收不到信号数据，类似于直播"></a>热信号示例：错过了订阅时机，就收不到信号数据，类似于直播</h1><blockquote><p>冷信号会收到全部的数据，即使是在数据发送之后才订阅的</p></blockquote><pre><code>- (void)test2 {    RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{            [subscriber sendNext:@1];        }];        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{            [subscriber sendNext:@2];        }];        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{            [subscriber sendNext:@3];            [subscriber sendCompleted];        }];        return nil;    }] publish];    [connection connect];    NSLog(@&quot;Signal was created.&quot;);    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{        [connection.signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber1 recveive: %@&quot;, x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{        [connection.signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber2 recveive: %@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5e7083e9f1760611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="SideEffect示例：多次订阅导致信号block多次执行"><a href="#SideEffect示例：多次订阅导致信号block多次执行" class="headerlink" title="SideEffect示例：多次订阅导致信号block多次执行"></a>SideEffect示例：多次订阅导致信号block多次执行</h1><pre><code>- (void)test3 {    // 多次订阅会多次执行    RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];        }];        return nil;    }];    // 【请求数据次数 +1】    [requestSignal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1&quot;);    }];    // 【请求数据次数 +1】    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2&quot;);    }];    // 将信号转换为内容为2的信号    RACSignal *signal1 = [requestSignal flattenMap:^RACStream *(id value) {        return [RACSignal return:@&quot;2&quot;];    }];    // 将signal1信号所有错误信息转换为字符串@&quot;Error&quot;    [signal1 catchTo:[RACSignal return:@&quot;Error&quot;]];    // 在没有获取值之前以字符串@&quot;Loading...&quot;占位    [signal1 startWith:@&quot;Loading...&quot;];    // 将信号进行绑定    // 【请求数据次数 +1】    RAC(self.acountField, text) = signal1;    // 订阅多个信号的任何错误，并且弹出UIAlertView    // 【请求数据次数 +2】    [[RACSignal merge:@[requestSignal, signal1]] subscribeError:^(NSError *error) {        NSLog(@&quot;发生错误&quot;);    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-465cde44e32e9612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="解决方式一：使用-RACMulticastConnection把冷信号转化为热信号"><a href="#解决方式一：使用-RACMulticastConnection把冷信号转化为热信号" class="headerlink" title="解决方式一：使用 RACMulticastConnection把冷信号转化为热信号"></a>解决方式一：使用 <code>RACMulticastConnection</code>把冷信号转化为热信号</h2><pre><code>- (void)test4 {    RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];            [subscriber sendCompleted];        }];        return nil;    }];    RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]];//    RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]];    [connection connect];    [connection.signal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [connection.signal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [connection.signal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><h3 id="使用RACSubject时"><a href="#使用RACSubject时" class="headerlink" title="使用RACSubject时"></a>使用<code>RACSubject</code>时</h3><pre><code>RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]];</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-85b4314b53586f26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="使用RACReplaySubject时"><a href="#使用RACReplaySubject时" class="headerlink" title="使用RACReplaySubject时"></a>使用<code>RACReplaySubject</code>时</h3><pre><code>RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]];</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-4ae4c9e7dbfebe09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="解决方式二：使用-replayLazily把冷信号转化为热信号"><a href="#解决方式二：使用-replayLazily把冷信号转化为热信号" class="headerlink" title="解决方式二：使用 replayLazily把冷信号转化为热信号"></a>解决方式二：使用 <code>replayLazily</code>把冷信号转化为热信号</h2><pre><code>- (void)test5 {    RACSignal *requestSignal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];            [subscriber sendCompleted];        }];        return nil;    }] replayLazily]; // modify here!!    [requestSignal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [requestSignal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-437a9f7928924eaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="使用RACCommand把冷信号转化为热信号"><a href="#使用RACCommand把冷信号转化为热信号" class="headerlink" title="使用RACCommand把冷信号转化为热信号"></a>使用<code>RACCommand</code>把冷信号转化为热信号</h2><pre><code>- (void)test6 {    RACCommand *requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {        return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {            NSLog(@&quot;开始请求网络数据&quot;);            [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{                [subscriber sendNext:@&quot;1&quot;];                [subscriber sendCompleted];            }];            return nil;        }];    }];    RACSignal *requestSignal = [requestCommand execute:nil];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [requestSignal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-e1f4373d8b49a171.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>RACMulticastConnection</code>与<code>RACSubject</code>结合使用时是直播的热信号</p><p><code>RACCommand</code>、<code>replayLazily</code>、<code>RACReplaySubject</code>都是类似于冷信号的情况，不管何时订阅，都会收到所有数据</p><h1 id="ReactiveCocoa中潜在的内存泄漏与解决方案"><a href="#ReactiveCocoa中潜在的内存泄漏与解决方案" class="headerlink" title="ReactiveCocoa中潜在的内存泄漏与解决方案"></a>ReactiveCocoa中潜在的内存泄漏与解决方案</h1><ul><li><p><code>RACObserve</code>中潜在使用了self，要注意循环引用</p></li><li><p><code>RACSubject</code>中如果没有调用<code>sendCompleted</code>，调用map等操作将造成内存泄漏（循环引用）。RACSignal不会有这个问题</p></li></ul><p>代码参见<a href="http://fromwiz.com/share/s/3rEj7C20FAXK2jIwRi1uhc1v0WQKj83L7k142p7dil0ygtoZ" target="_blank" rel="noopener">https://github.com/action456789/ReactiveCocoaDemo</a></p><p>参考：<a href="http://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="noopener">http://tech.meituan.com/tag/ReactiveCocoa</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;函数响应式编程(Functional Reactive Programming:FRP)，ReactiveCoco
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="Rx &amp; RAC" scheme="http://superkk.top/categories/iOS/Rx-RAC/"/>
    
    
  </entry>
  
  <entry>
    <title>UITableView的beginUpdates与endUpdates用法详解</title>
    <link href="http://superkk.top/2018/06/05/UITableView%E7%9A%84%60beginUpdates%60%E4%B8%8E%60endUpdates%60%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://superkk.top/2018/06/05/UITableView的`beginUpdates`与`endUpdates`用法详解/</id>
    <published>2018-06-04T18:05:12.000Z</published>
    <updated>2019-08-29T14:57:40.604Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="UITaUITableView的beginUpdates和endUpdates"><a href="#UITaUITableView的beginUpdates和endUpdates" class="headerlink" title="UITaUITableView的beginUpdates和endUpdates"></a>UITaUITableView的<code>beginUpdates</code>和<code>endUpdates</code></h1><ol><li>这个方法用于在调用插入，删除，选择方法时，同时有动画效果。 </li><li>用endUpdate能动画改变行高(触发<code>heightForRowAtIndexPath</code>回调)，而无需relaod这个cell。</li></ol><h2 id="使用场景一：点击cell，cell的高度就变高"><a href="#使用场景一：点击cell，cell的高度就变高" class="headerlink" title="使用场景一：点击cell，cell的高度就变高"></a>使用场景一：点击cell，cell的高度就变高</h2><p>Cell点击方法执行</p><pre><code class="Objective-C">  [tableView beginUpdates];  [tableView endUpdates];</code></pre><p>这两句代码中间没有任何其他部分，但是会触发<code>heightForRowAtIndexPath</code>回调，从而修改cell的高度</p><h2 id="使用场景二：有一个-TableView，现在我希望每按一次-update-按钮，就动态地在下方加两行。"><a href="#使用场景二：有一个-TableView，现在我希望每按一次-update-按钮，就动态地在下方加两行。" class="headerlink" title="使用场景二：有一个 TableView，现在我希望每按一次 update 按钮，就动态地在下方加两行。"></a>使用场景二：有一个 TableView，现在我希望每按一次 update 按钮，就动态地在下方加两行。</h2><ul><li>方法一：简单粗暴的做法 ，更改数据源，然后刷新一下列表</li></ul><pre><code class="Objective-C">// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;] @IBAction func update(_ sender: AnyObject) {     tableData.append(&quot;\(tableData.count)&quot;)     tableData.append(&quot;\(tableData.count)&quot;)     tableView.reloadData() }</code></pre><ul><li>方法二</li></ul><pre><code class="Objective-C">// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]@IBAction func update(_ sender: AnyObject) {    tableData.append(&quot;\(tableData.count)&quot;)    tableData.append(&quot;\(tableData.count)&quot;)    tableView.beginUpdates()    let indexPaths = [IndexPath(row: tableData.count-2, section: 0), IndexPath(row: tableData.count-1, section: 0)]    tableView.insertRows(at: indexPaths, with: UITableViewRowAnimation.automatic)    tableView.endUpdates()}</code></pre><p>这里 beginUpdates 和 endUpdates 方法的作用是，将这两条语句之间的对 tableView 的 insert/delete 操作聚合起来，然后同时更新 UI。</p><h1 id="动态改变tableHeaderView高度"><a href="#动态改变tableHeaderView高度" class="headerlink" title="动态改变tableHeaderView高度"></a>动态改变<code>tableHeaderView</code>高度</h1><p>view 作为 tableView 的 tableHeaderView，单纯的改变 view 的 frame 是无济于事的，tableView 不会时刻适应它的高度，</p><p>所以，如何告诉tableView 它的 tableHeaderView 已经改变了？</p><pre><code class="Objective-C">headerView.frame = newFrame;[self.tableView setTableHeaderView:headerView];</code></pre><p>或者</p><pre><code class="Objective-C">[self.tableView beginUpdates];[self.tableView setTableHeaderView:headerView];[self.tableView endUpdates];</code></pre><h2 id="如何检测动画在UITableView-beginUpdates-endUpdates上结束"><a href="#如何检测动画在UITableView-beginUpdates-endUpdates上结束" class="headerlink" title="如何检测动画在UITableView beginUpdates / endUpdates上结束"></a>如何检测动画在UITableView beginUpdates / endUpdates上结束</h2><pre><code class="Objective-C">[CATransaction begin];[CATransaction setCompletionBlock:^{    // animation has finished}];[tableView beginUpdates];// do some work[tableView endUpdates];[CATransaction commit];</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;UITaUITableView的beginUpdates和endUpdates&quot;&gt;&lt;a href=&quot;#UITaUITableView的beginUpdates和endUpdates&quot; class=&quot;headerlink&quot; title=&quot;U
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Native数据传递</title>
    <link href="http://superkk.top/2018/05/21/React-Native%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>http://superkk.top/2018/05/21/React-Native数据传递/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T15:18:04.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过react-navigation传递数据"><a href="#通过react-navigation传递数据" class="headerlink" title="通过react-navigation传递数据"></a>通过react-navigation传递数据</h1><h2 id="顺传"><a href="#顺传" class="headerlink" title="顺传"></a>顺传</h2><p>传递数据</p><pre><code>_onItemPress = (item) =&gt; {    NavigationService.navigate(&quot;Page1&quot;, {        data: item    });};</code></pre><p>获取数据</p><pre><code>componentDidMount() {    // 或者使用 this.props.navigation.getParam(&#39;data&#39;)    let data = this.props.navigation.state.params.data;}</code></pre><h2 id="逆传"><a href="#逆传" class="headerlink" title="逆传"></a>逆传</h2><p>传递数据</p><pre><code>_callback = (message) =&gt; {    console.log(message);}_onItemPress = (item) =&gt; {    NavigationService.navigate(&quot;Page1&quot;, {        callback: this._callback    });};</code></pre><p>子组件获取回调并执行</p><pre><code>render() {    return (        &lt;View style={styles.container}&gt;            &lt;Button                title={&#39;点击测试&#39;}                onPress={() =&gt; this.props.navigation.state.params.callback(&#39;hello world&#39;) }&gt;            &lt;/Button&gt;        &lt;/View&gt;    );}</code></pre><h1 id="通过组件传递数据"><a href="#通过组件传递数据" class="headerlink" title="通过组件传递数据"></a>通过组件传递数据</h1><h2 id="顺传-1"><a href="#顺传-1" class="headerlink" title="顺传"></a>顺传</h2><p>传递数据</p><pre><code>_renderItem = ({item, index}) =&gt; {    return (&lt;View&gt;        &lt;Component1 msg={item} index={index} dataA={this.state.dataA} navigation={this.props.navigation}/&gt;    &lt;/View&gt;)};</code></pre><p>子组件获取数据</p><pre><code>export default class Component1 extends Component&lt;Props&gt; {    constructor(props) {        super(props);        this.state = {            msg: this.props.msg,            index: this.props.index,            dataA: this.props.dataA,        }    }    //父组件更新数据，子组件不刷新时使用    componentWillReceiveProps(nextProps) {        this.setState({            msg: nextProps.msg,            index: nextProps.index,            dataA: nextProps.dataA,        });    }}</code></pre><h2 id="逆传-1"><a href="#逆传-1" class="headerlink" title="逆传"></a>逆传</h2><p>组件A<br>传递callback</p><pre><code>_callback = (message) =&gt; {    console.log(message);}render() {    return (    &lt;View&gt;        &lt;ComponentB callback={this._callback}&gt;&lt;/ComponentB&gt;    &lt;/View&gt;)};</code></pre><p>组件B<br>子组件获取传递过来的callback并执行</p><pre><code>class ComponentB extends React.PureComponent {    _onPress = () =&gt; {        this.props.callback(&#39;hello world&#39;)    };    render() {        return (            &lt;View style={styles.container} &gt;                &lt;Button                    title={&quot;点击测试&quot;}                    onPress={this._onPress}                &gt;                &lt;/Button&gt;            &lt;/View&gt;        );    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过react-navigation传递数据&quot;&gt;&lt;a href=&quot;#通过react-navigation传递数据&quot; class=&quot;headerlink&quot; title=&quot;通过react-navigation传递数据&quot;&gt;&lt;/a&gt;通过react-navigation传递
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Native布局</title>
    <link href="http://superkk.top/2018/05/21/React-Native%20%E5%B8%83%E5%B1%80/"/>
    <id>http://superkk.top/2018/05/21/React-Native 布局/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:25:25.038Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://facebook.github.io/react-native/docs/flexbox" target="_blank" rel="noopener">https://facebook.github.io/react-native/docs/flexbox</a><br><a href="https://yogalayout.com/playground" target="_blank" rel="noopener">https://yogalayout.com/playground</a></p><h1 id="颜色字符串"><a href="#颜色字符串" class="headerlink" title="颜色字符串"></a>颜色字符串</h1><p>backgroundColor: ‘#30576EA0’,<br>前面两位（30）表示透明度，范围是0～99</p><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829215932.png" alt=""><br> 边框属性(border)用来设定一个元素的边线。</p><ul><li>边距属性(margin)是用来设置一个元素所占空间的边缘到相邻元素之间的距离。</li><li>间隙属性(padding)是用来设置元素内容到元素边界的距离。</li></ul><p><br></p><h1 id="Flexbox布局属性"><a href="#Flexbox布局属性" class="headerlink" title="Flexbox布局属性"></a>Flexbox布局属性</h1><h2 id="伸缩容器的属性"><a href="#伸缩容器的属性" class="headerlink" title="伸缩容器的属性"></a>伸缩容器的属性</h2><h3 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h3><ul><li><p><code>flexDirection</code>  ：决定布局的主轴，默认值是竖直轴(column)</p><ul><li><code>row</code>:（默认值）</li><li><code>row-reverse</code></li><li><code>column</code> (RN默认值)</li><li><code>column-reverse</code></li></ul></li><li><p><code>justifyContent</code> ：决定其子元素沿着主轴的排列方式</p><ul><li><code>flex-start</code>:（默认值）从主轴的起点对齐    </li><li><code>flex-end</code>: 从主轴的终点对齐    </li><li><code>center</code>:从主轴的中间位置对齐    </li><li><code>space-between</code>:平均分布在主轴线上    </li><li><code>space-around</code>:平均分布在主轴线上，两端留下一半的距离</li></ul></li></ul><ul><li><code>flexWap</code><br>伸缩容器在主轴线方向空间不足的情况下，是否换行以及该如何换行<ul><li><code>nowrap</code>（默认值）</li><li><code>wrap</code>    </li><li><code>wrap-reverse</code></li></ul></li></ul><h3 id="次轴"><a href="#次轴" class="headerlink" title="次轴"></a>次轴</h3><ul><li><p><code>alignItems</code>：决定其子元素沿着次轴的排列方式</p><ul><li><code>flex-start</code>（默认值）交叉轴起点对齐</li><li><code>flex-end</code> 交叉轴终点对齐</li><li><code>center</code> 中点对齐</li><li><code>stretch</code> 拉伸</li><li><code>baseline</code> 基线对齐<br><code>baseline</code>对齐效果：<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829221739.png" alt=""><br><code>stretch</code>效果（不设置高度时）<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829221759.png" alt=""></li></ul></li><li><p><code>align-content</code><br>用来调整伸缩项目出现换行后在交叉轴上的对齐方式</p><ul><li><code>flex-start</code></li><li><code>flex-end</code>    </li><li><code>center</code>    </li><li><code>space-between</code>    </li><li><code>space-around</code>    </li><li><code>stretch</code>（默认值）</li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>display</code><ul><li><code>flex</code>    块级伸缩容器    </li><li><code>inline-flex</code>行内级伸缩容器</li><li><code>none</code>隐藏元素</li></ul></li></ul><ul><li><code>flex-flow</code><br>同时定义了伸缩容器的主轴和侧轴, 其默认值为 <ul><li><code>row</code> </li><li><code>nowrap</code></li></ul></li></ul><h2 id="伸缩项目的属性"><a href="#伸缩项目的属性" class="headerlink" title="伸缩项目的属性"></a>伸缩项目的属性</h2><ul><li><p><code>order</code><br>定义项目的排列顺序，数值越小，排列越靠前，默认值为0<br>语法为：order：整数值</p></li><li><p><code>flex-grow</code><br>定义伸缩项目的放大比例，为整数值</p><ul><li>0(默认值): 不放大</li><li>其他值: 如果存在剩余空间，那么将自动占据全部剩余空间，每个item所占据的空间大小会根据这个值自动调整</li></ul></li><li><p><code>flex-shrink</code><br>定义伸缩项目的收缩能力，默认值为1 ，其语法为：flex-shrink:整数值</p><ul><li>1(默认值)    其他值</li><li>如果不存在剩余空间，那么将自动缩小</li></ul></li><li><p><code>flex-basis</code><br>用来设置伸缩项目的基准值，剩余的空间按比率进行伸缩</p><ul><li><code>auto</code>(默认值)    </li><li><code>length</code></li></ul></li><li><p><code>flex</code><br>是flex-grow flex-shrink flex-basis这三个属性的缩写，其语法为：flex:none | flex-grow flex-shrink flex-basis，其中第二个和第三个参数为可选参数，默认值为：0 1 auto</p></li><li><p><code>alignSelf</code><br>用来设置单独的伸缩项目在交叉轴上的对齐方式，会覆盖默认的对齐方式 </p><ul><li><code>auto</code> 按照自身设置的宽高进行显示    </li><li><code>flex-start</code>    </li><li><code>flex-end</code>    </li><li><code>center</code>    </li><li><code>baseline</code>    </li><li><code>stretch</code>默认,伸缩项目在交叉轴方向占满伸缩容器，如果交叉轴为垂直方向的话，只有在不设置高度的情况下才能看到效果</li></ul></li></ul><h1 id="React-Native中的postion定位"><a href="#React-Native中的postion定位" class="headerlink" title="React Native中的postion定位"></a>React Native中的postion定位</h1><ul><li><code>relative</code> 相对定位(默认)，以元素本来的位置为基准进行偏移。</li><li><code>absolute</code> 绝对定位，以父元素的边框为基准进行偏移。<br><a href="https://blog.csdn.net/al4fun/article/details/80253364" target="_blank" rel="noopener">https://blog.csdn.net/al4fun/article/details/80253364</a></li></ul><h1 id="width-39-100-39-与width-39-auto-39"><a href="#width-39-100-39-与width-39-auto-39" class="headerlink" title="width:&#39;100%&#39;与width:&#39;auto&#39;"></a><code>width:&#39;100%&#39;与width:&#39;auto&#39;</code></h1><ul><li><code>width:auto</code> 会将元素撑开至整个父元素width，但是会减去子节点自己的margin，padding或者border的大小。</li><li><code>width:100%</code> 会强制将元素变成和父元素一样的宽，并且添加额外的空间到这个元素的width上。就是因为这个，会导致很多问题。</li></ul><p>使用width:100%永远都不是一个好主意。这个属性容易让人产生你正在定义一个元素可视大小，其实，你是在对这个元素的状态做了巨大的改变。</p><pre><code>&lt;TouchableOpacity style={[styles.comButton]}&gt;    &lt;Text        style={[        {            width: &quot;100%&quot;,            height: &quot;100%&quot;,        }]}&gt;        {item.title}    &lt;/Text&gt;&lt;/TouchableOpacity&gt;comButton: {    padding:0,    flex: 1,    alignItems: &quot;center&quot;,    justifyContent: &quot;center&quot;,    color: CommonStyle.col_gray_dark,    borderColor: CommonStyle.col_gray_dark,    borderWidth: 0.8,    borderRadius: 48,    height: 44  }</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829222452.png" alt=""></p><pre><code>&lt;TouchableOpacity style={[styles.comButton]}&gt;    &lt;Text        style={[        {            width: Platform.OS === &#39;ios&#39; ? &#39;auto&#39; : &quot;100%&quot;,            height: Platform.OS === &#39;ios&#39; ? &#39;auto&#39; : &quot;100%&quot;,        }]}&gt;        {item.title}    &lt;/Text&gt;&lt;/TouchableOpacity&gt;</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829222515.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react-native/docs/flexbox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://facebook.github.io/react-native/doc
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>RxSwift基本概念</title>
    <link href="http://superkk.top/2018/05/21/RxSwift%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://superkk.top/2018/05/21/RxSwift基本概念/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T16:10:11.474Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><p>Observables是一个事件流的对象</p><h2 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h2><p>通过empty函数，可以生成一个空的流，在这个流中只会产生一个Completed信息。</p><pre><code class="Swift">let emptyStream: Observable&lt;Int&gt; = Observable.empty()_ = emptyStream.subscribe { event in    print(event)  completed}</code></pre><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>通过never函数产生的流对象，将不会有任何的事件发生。</p><pre><code class="Swift">let neverStream: Observable&lt;Int&gt; = Observable.never()_ = neverStream.subscribe({ _ in    print(&quot;这个方法永远都不会被执行&quot;)})</code></pre><h2 id="just"><a href="#just" class="headerlink" title="just"></a>just</h2><p>just函数调用之后将会产生一个next事件以及一个Completed事件，其中next可以用来传递数据，最后的Completed事件发送之后将不会再有事件了。<br>简单的说：just函数可以发送一个数据。</p><pre><code class="Swift">let justStream = Observable.just(32)_ = justStream.subscribe({ event in    print(event)    /*    next(32)    completed    */})</code></pre><h2 id="of"><a href="#of" class="headerlink" title="of"></a>of</h2><p>将一个集合内的数据所有数据顺序的发送出去。</p><pre><code class="Swift">let ofStream = Observable.of(0, 1, 2)_ = ofStream.subscribe({ event in    print(event)    /*    next(0)    next(1)    next(2)    completed    */})</code></pre><h2 id="from"><a href="#from" class="headerlink" title="from"></a>from</h2><p>将一个集合对象（比如数组、Range等）转换成流对象，通过订阅可以获得这个集合对象的所有内容。</p><pre><code class="Swift">let streamFromArray = Observable.from([0, 1, 2])_ = streamFromArray.subscribe({ (event) in    print(event)    /*    next(0)    next(1)    next(2)    completed    */})</code></pre><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>create 函数是通过利用闭包来生成流对象的函数</p><pre><code class="Swift">let myJust = { (singleElement: Int) -&gt; Observable &lt;Int&gt; inreturn Observable.create({ (observer) -&gt; Disposable in    observer.onNext(singleElement)    observer.onCompleted()    return Disposables.create()})}let singleElementStream = myJust(32)_ = singleElementStream.subscribe { (event) in    print(event)    /*    next(32)    completed    */}</code></pre><h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>通过error函数将会生成一个终止的流，这个流中只会产生一次error事件并结束掉。</p><pre><code class="Swift">let error = NSError(domain: &quot;com.RxSwiftDemo.kesen&quot;, code: -1, userInfo: nil)let errorStream: Observable&lt;Int&gt; = Observable.error(error)_ = errorStream.subscribe { (event) in    print(event)    error(Error Domain=com.RxSwiftDemo.kesen Code=-1 &quot;(null)&quot;)}</code></pre><h2 id="deffered"><a href="#deffered" class="headerlink" title="deffered"></a>deffered</h2><p>deffered函数生成的流对象，只有在添加了订阅者才会被创建。</p><pre><code class="Swift">let defferedStream = Observable.deferred { () -&gt; Observable&lt;Int&gt; inreturn Observable.create({ (observer) -&gt; Disposable in    observer.onNext(0)    observer.onNext(1)    observer.onCompleted()    return Disposables.create()})}_ = defferedStream.subscribe({ (event) in    print(event)    /*    next(0)    next(1)    completed    */})</code></pre><h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>Subject其实就是Observer，拥有Observer的所有功能，也可以认为是热的Observer。</p><h2 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h2><p>它仅仅会发送observer订阅之后的事件，也就是说如果sequence上有.Next 的到来，但是这个时候某个observer还没有subscribe它，这个observer就收不到这条信息，它只会收到它订阅之后发生的事件。</p><h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>它和PublishSubject不同之处在于它不会漏消息。即使observer在subscribe的时候已经有事件发生过了，它也会收到之前的事件序列。</p><h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>当有observer在订阅一个BehaviorSubject的时候，它首先将会收到Observable上最近发送一个信号（或者是默认值），接着才会收到Observable上会发送的序列。</p><h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>Variable是BehaviorSubject的封装，它和BehaviorSubject不同之处在于，不能向Variable发送.Complete和.Error，它会在生命周期结束被释放的时候自动发送.Complete。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Observable&quot;&gt;&lt;a href=&quot;#Observable&quot; class=&quot;headerlink&quot; title=&quot;Observable&quot;&gt;&lt;/a&gt;Observable&lt;/h1&gt;&lt;p&gt;Observables是一个事件流的对象&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="Rx &amp; RAC" scheme="http://superkk.top/categories/iOS/Rx-RAC/"/>
    
    
      <category term="Swift" scheme="http://superkk.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift要点</title>
    <link href="http://superkk.top/2018/05/21/Swift%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/"/>
    <id>http://superkk.top/2018/05/21/Swift面向协议编程/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T16:17:20.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扩展协议"><a href="#扩展协议" class="headerlink" title="扩展协议"></a>扩展协议</h1><ul><li>为协议方法增加默认实现</li><li>为协议增加方法，可以扩展系统中的协议</li><li>为协议增加计算属性</li></ul><pre><code class="Swift">protocol Recordable: CustomStringConvertible {    var wins: Int {get}    var losses: Int {get}    func winningPercent() -&gt; Double}// 扩展 Record 协议extension Recordable {    // 增加协议默认实现    var description: String {        return &quot;Wins: \(wins), Losses: \(losses)&quot;    }    // 增加计算属性    var gamePlayed: Int {        return wins + losses    }    // 增加方法    func winningPercent() -&gt; Double {        return Double(wins) / Double(gamePlayed)    }}</code></pre><h1 id="针对某个类扩展协议"><a href="#针对某个类扩展协议" class="headerlink" title="针对某个类扩展协议"></a>针对某个类扩展协议</h1><pre><code class="Swift">protocol SomeProtocolA {    func someProtocolMethodA()}class A: SomeProtocolA {    let a = 1        func someProtocolMethodA() {        print(a)    }}class B {    let b = 2}// 针对类 A 扩展协议// 基类A继承了SomeProtocol协议才能添加扩展// 说人话：如果类A实现了 SomeProtocol 协议，那么可以进行扩展extension SomeProtocolA where Self: A {    func showParamA() {        print(self.a)    }}// 针对类 B 扩展协议// 反例，不符合where条件extension SomeProtocolA where Self: B {    func someProtocolMethodA() {        print(&quot;someMethodProtocolA&quot;)    }}test(&quot;协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展）&quot;) {    // 换个说法， 多个类实现了同一个协议，该语法根据类名分别为这些类添加扩展， 注意是分别(以类名区分)！！！    let objA = A()    let objB = B()  // 类B没实现SomeProtocol， 所有没有协议方法    objA.showParamA()  //输出1}protocol SomeProtocolB {    func someProtocolMethodB()}// 针对协议 A 扩展协议 Bextension SomeProtocolB where Self: SomeProtocolA {    func someProtocolMethodB() {        print(&quot;SomeProtocolB&quot;)    }}class C: SomeProtocolA &amp; SomeProtocolB {    func someProtocolMethodA() {        print(#function)    }      func someProtocolMethodB() {        print(#function)    }}</code></pre><h1 id="同时满足多个协议才进行扩展"><a href="#同时满足多个协议才进行扩展" class="headerlink" title="同时满足多个协议才进行扩展"></a>同时满足多个协议才进行扩展</h1><p>只有当类实现了Tieable协议才会进行扩展，换个说法：只有当某个类同时实现了这两个协议，才会有下列扩展的效果。</p><pre><code class="Swift">protocol Tieable {    var ties: Int {get set}}// 同时扩展Record协议和Tieable协议（同时遵守了两个协议）extension Recordable where Self: Tieable {    var gamePlayed: Int {        return wins + losses + ties    }    // 有平局的情况下，需要计算ties    func winningPercent() -&gt; Double {        return Double(wins) / Double(gamePlayed)    }}</code></pre><h1 id="覆盖协议中的默认实现"><a href="#覆盖协议中的默认实现" class="headerlink" title="覆盖协议中的默认实现"></a>覆盖协议中的默认实现</h1><pre><code class="Swift">// 棒球struct BaseballRecord: Recordable {    var wins: Int    var losses: Int      // 覆盖协议中的默认实现    let gamePlayed: Int = 162}</code></pre><h1 id="协议聚合"><a href="#协议聚合" class="headerlink" title="协议聚合"></a>协议聚合</h1><p>表示某个对象要满足多个协议，使用 <code>&amp;</code>连接多个协议</p><pre><code class="Swift">protocol Prizable {    func isPrizable() -&gt; Bool}// one要满足多个协议func award(one: Prizable &amp; CustomStringConvertible) {    if one.isPrizable() {        print(one)        print(&quot;Congratulation&quot;)    }}</code></pre><h1 id="为泛型参数增加协议约束"><a href="#为泛型参数增加协议约束" class="headerlink" title="为泛型参数增加协议约束"></a>为泛型参数增加协议约束</h1><pre><code class="Swift">// 单个协议func top&lt;T: Recordable&gt;(seq: [T]) -&gt; T? {    return seq.first}// 多个协议func top&lt;T: Recordable &amp; Prizable&gt;(seq: [T]) -&gt; T? {    return seq.first}</code></pre><h1 id="可选协议"><a href="#可选协议" class="headerlink" title="可选协议"></a>可选协议</h1><ul><li>需要标志位@objc，使得它兼容Objective-C代码，因为Swift要使用Objective-C的运行时来检查类所遵守的可选方法是否存在。</li><li>拥有可选方法的协议只能被类遵守，结构体和枚举是不可以遵守该协议的。</li></ul><pre><code class="Swift">@objc protocol Animal {    @objc optional func fly()}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;扩展协议&quot;&gt;&lt;a href=&quot;#扩展协议&quot; class=&quot;headerlink&quot; title=&quot;扩展协议&quot;&gt;&lt;/a&gt;扩展协议&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;为协议方法增加默认实现&lt;/li&gt;
&lt;li&gt;为协议增加方法，可以扩展系统中的协议&lt;/li&gt;
&lt;li&gt;为协议增加计算
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://superkk.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>JS常用点</title>
    <link href="http://superkk.top/2018/05/21/JS%E5%B8%B8%E7%94%A8%E7%82%B9/"/>
    <id>http://superkk.top/2018/05/21/JS常用点/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T15:08:41.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="for-of：遍历数组value"><a href="#for-of：遍历数组value" class="headerlink" title="for of：遍历数组value"></a><code>for of</code>：遍历数组value</h3><blockquote><p>TIPS: for of 断点时，获取不到变量信息</p><pre><code class="javascript">const array = [    {        name: &quot;张三&quot;    }, {        name: &quot;李四&quot;    }, {        name: &quot;王五&quot;    }, {        name: &quot;小红&quot;    }];let obj = {    name: &quot;小红&quot;,    age: 19,    sex: &#39;女&#39;,}// for of：遍历数组valuefor (const item of array) {    console.log(item.name);}</code></pre></blockquote><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829222714.png" alt=""></p><h3 id="for-in：遍历对象key"><a href="#for-in：遍历对象key" class="headerlink" title="for in：遍历对象key"></a><code>for in</code>：遍历对象key</h3><pre><code class="javascript">// for in：遍历对象keyfor (const key in obj) {    console.log(`${key}:${obj[key]}`);}</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829222733.png" alt=""></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><pre><code class="javascript">let nArray = array.map((value, index) =&gt; {    return { ...value, type: &#39;哈哈&#39; }})console.log(nArray);</code></pre><h3 id="切片：splice"><a href="#切片：splice" class="headerlink" title="切片：splice"></a>切片：<code>splice</code></h3><pre><code>- [start, end) 从下标start开始，到下标end结束，不包括end- end 大于数组长度会截取到数组结束</code></pre><pre><code>let subArray = array.splice(0, 6)console.log(subArray)</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829222753.png" alt=""></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>本质是<code>模式匹配</code></p><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><ul><li><p>本质：实现了Iterator 接口的对象就可以按顺序解构赋值<br>数组的元素是按次序排列的，变量的取值由它的位置决定</p><pre><code class="javascript">let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4</code></pre></li><li><p>默认值</p><pre><code class="javascript">let [x = 1, y = x] = [2];    // x=2; y=2let [foo = true] = [];foo // truelet [x = 1] = [undefined];x // 1</code></pre></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="变量与属性同名"><a href="#变量与属性同名" class="headerlink" title="变量与属性同名"></a>变量与属性同名</h3><ul><li>字符串赋值<pre><code class="javascript">let { bar, foo, hello } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };foo // &quot;aaa&quot;bar // &quot;bbb&quot;hello // &quot;undefined&quot;</code></pre></li><li>对象方法赋值<pre><code class="javascript">const { log } = console;log(&#39;hello&#39;) // hello</code></pre><h3 id="变量名与属性名不同名"><a href="#变量名与属性名不同名" class="headerlink" title="变量名与属性名不同名"></a>变量名与属性名不同名</h3><pre><code class="javascript">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };baz // &quot;aaa&quot;</code></pre>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</li></ul><h3 id="嵌套对象赋值"><a href="#嵌套对象赋值" class="headerlink" title="嵌套对象赋值"></a>嵌套对象赋值</h3><ul><li>注意，对象嵌套赋值里，<code>冒号:</code>代表模式，并不是取值</li></ul><pre><code class="javascript">const node = {    loc: {      start: {        line: 1,        column: 5      }    }  };let { loc: { start }} = node;start // Object {line: 1, column: 5}loc // undefinedlet { loc, loc: { start }}start // Object {line: 1, column: 5}loc // Object {start: Object}let { loc: { start: { line }}} = node;line // 1loc // undefinedstart // undefined</code></pre><h3 id="获取对象继承的属性"><a href="#获取对象继承的属性" class="headerlink" title="获取对象继承的属性"></a>获取对象继承的属性</h3><pre><code class="javascript">const obj1 = {};const obj2 = { foo: &#39;bar&#39; };Object.setPrototypeOf(obj1, obj2);const { foo } = obj1;foo // &quot;bar&quot;</code></pre><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><pre><code class="javascript">var {x = 3} = {};x // 3var {x = 3} = {x: undefined};x // 3</code></pre><h3 id="已声明变量的解构赋值"><a href="#已声明变量的解构赋值" class="headerlink" title="已声明变量的解构赋值"></a>已声明变量的解构赋值</h3><ul><li>错误的写法</li></ul><pre><code class="javascript">let x;{x} = {x: 1};// SyntaxError: syntax error</code></pre><ul><li>正确的写法</li></ul><pre><code class="javascript">let x;({x} = {x: 1});</code></pre><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><p>函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p><pre><code class="javascript">function add([x, y]){  return x + y;}add([1, 2]); // 3</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
  <entry>
    <title>TextInput</title>
    <link href="http://superkk.top/2018/05/21/TextInput/"/>
    <id>http://superkk.top/2018/05/21/TextInput/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T13:11:48.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用属性-Android-amp-iOS"><a href="#通用属性-Android-amp-iOS" class="headerlink" title="通用属性(Android &amp; iOS)"></a>通用属性(Android &amp; iOS)</h1><ul><li>(1)支持View的相关属性</li><li><p>(2)<code>autoCapitalize</code>:控制输入的字符进行切换成大写(参数:’none’,’sentences’,’words’,’characters’)<br><code>none</code>: 不自动切换任何字符大写<br><code>sentences</code>: 默认每个句子的首字母大写<br><code>words</code>:每个单词的首字母变成大写<br><code>characters</code>:每个字母全部变成大写</p></li><li><p>(3)<code>autoCorrect(bool)</code>:设置瓶邪自动修正功能,默认开启(true)</p></li><li><p>(4)<code>autoFocus(bool)</code>:设置是否默认获取到焦点,默认为关闭(false).需要comonentDidMount方法调用之后才会获取焦点(componentDidMount是React组件被渲染之后React主动回调的方法)</p></li><li><p>(5)<code>defaultValue(string)</code>:给文本框输入一个默认初始值.</p></li><li><p>(6)<code>editable(bool)</code>:设置文本框是否可以编辑,默认为true,可以进行编辑</p></li><li><p>(7)<code>keyboardType</code>:<br>键盘类型(可选参数:”default”, ‘email-address’, ‘numeric’, ‘phone-pad’, “ascii-capable”, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’) 该用来选择默认弹出键盘的类型例如我们甚至numeric就是弹出数字键盘。鉴于平台的原因如下的值是所有平台都可以进行通用的</p></li><li><p>(8)<code>maxLength(number)</code>:可以限制文本输入框最大的输入字符长度</p></li><li><p>(9)<code>multiline (bool)</code> : 设置可以输入多行文字，默认为false(表示无论文本输入多少，都是单行显示)</p></li><li>(10)<code>onBlur (function)</code>: 监听方法，文本框失去焦点回调方法</li><li>(11)<code>onChange (function)</code>: 监听方法,文本框内容发生改变回调方法</li><li>(12)<code>onChangeText (function)</code>:监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容</li><li>(13)<code>onEndEditing (function)</code>:监听方法，当文本结束文本输入回调方法</li><li>(14)<code>onFocus (function)</code> :监听方法 文本框获取到焦点回调方法</li><li>(15)<code>onLayout (function)</code>:监听方法 组价布局发生变化的时候调用，调用方法参数为 {x,y,width,height}</li><li>(16)<code>onSubmitEditing (function)</code>:监听方法，当编辑提交的时候回调方法。不过如果multiline={true}的时候，该属性就不生效</li><li>(17)<code>placeholder (string</code>) :当文本输入框还没有任何输入的时候，默认显示信息，当有输入的时候该值会被清除</li><li>(18)<code>placeholderText Color (string)</code>: 设置默认信息颜色(placeholer)</li><li>(19)<code>secureTextEntry (bool)</code>: 设置是否为密码安全输入框 ，默认为false</li><li>(20)<code>style</code> 风格属性 可以参考Text组件风格</li><li>(21)<code>value ( string )</code>:输入框中的内容值</li><li>(22)<code>returnKeyType</code>:决定“确定”按钮显示的内容。<br>done<br>go<br>next<br>search<br>send</li></ul><h1 id="Android-平台属性"><a href="#Android-平台属性" class="headerlink" title="Android 平台属性"></a>Android 平台属性</h1><ul><li>(22)<code>numberOfLines (number)</code>:设置文本输入框行数，该需要首先设置multiline为true,设置TextInput为多行文本。</li><li>(23)<code>textAlign</code> 设置文本横向布局方式 可选参数(‘start’, ‘center’, ‘end’)</li><li>(24)<code>textAlignVertical</code>: 设置文本垂直方向布局方式 可选参数(‘top’, ‘center’, ‘bottom’)</li><li>(25)<code>underlineColorAndroid</code>: 设置文本输入框下划线的颜色</li></ul><h1 id="长按出现菜单键为英文，如何改为中文"><a href="#长按出现菜单键为英文，如何改为中文" class="headerlink" title="长按出现菜单键为英文，如何改为中文"></a>长按出现菜单键为英文，如何改为中文</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829210921.png" alt=""><br>在Xcode中，TARGETS—你的项目名—info，选择Localization native development region，选择China，这样文字都会变成中文啦，包括时间选择器等也会变成中文。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829210959.png" alt=""></p><h1 id="键盘处理"><a href="#键盘处理" class="headerlink" title="键盘处理"></a>键盘处理</h1><p><a href="https://facebook.github.io/react-native/docs/inputaccessoryview#docsNav" target="_blank" rel="noopener">参考</a><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211043.png" alt=""></p><pre><code class="javascript">    const inputAccessoryViewID = &quot;inputAccessoryViewID&quot;;    _renderLeaveWordInput() {         return &lt;View style={{height: 60}}&gt;                &lt;TextInput style={{                    fontSize: 13,                    textAlignVertical: 'top',                    autoCapitalize: 'none',                    autoCorrect: false                 }}                   multiline={true}                   maxLength={50}                   onChangeText={this._onInputCommentsChange}                   value={this.state.comments}                   inputAccessoryViewID={inputAccessoryViewID}                   ref={&#39;LeaveWordTextInput&#39;}                   placeholder={&#39;请输入留言&#39;}/&gt;                &lt;InputAccessoryView nativeID={inputAccessoryViewID}&gt;                    &lt;View style={{flexDirection:'row-reverse'}}&gt;                        &lt;Button onPress={() =&gt; {this.refs.LeaveWordTextInput.blur();}}                                title=&quot;完成&quot;                                color=&quot;red&quot;                        /&gt;                    &lt;/View&gt;                &lt;/InputAccessoryView&gt;            &lt;/View&gt;    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通用属性-Android-amp-iOS&quot;&gt;&lt;a href=&quot;#通用属性-Android-amp-iOS&quot; class=&quot;headerlink&quot; title=&quot;通用属性(Android &amp;amp; iOS)&quot;&gt;&lt;/a&gt;通用属性(Android &amp;amp; iOS)
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift中where的使用</title>
    <link href="http://superkk.top/2018/05/21/Swift%E4%B8%ADwhere%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://superkk.top/2018/05/21/Swift中where的使用/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T16:12:50.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合遍历-forEach-中使用"><a href="#集合遍历-forEach-中使用" class="headerlink" title="集合遍历 forEach 中使用"></a>集合遍历 <code>forEach</code> 中使用</h1><pre><code class="Swift">let array = [0, 1, 2, 3, 4, 5, 6]test(&quot;集合遍历 forEach&quot;) {    //使用switch遍历    array.forEach {        switch $0 {        case let x where x &gt; 3:   //where相当于判断条件            print(x)        default:            print(&quot;默认值&quot;)        }    }}</code></pre><h1 id="集合遍历-for-in"><a href="#集合遍历-for-in" class="headerlink" title="集合遍历 for in"></a>集合遍历 <code>for in</code></h1><p> 中使用</p><pre><code class="Swift">test(&quot;集合遍历 for in&quot;) {    for value in array where value &gt; 2 {        print(value)   //输出3 4 5 6    }    for (index, value) in array.enumerated() where index &gt; 2 &amp;&amp; value &gt; 3 {        print(&quot;下标:\(index), 值：\(value)&quot;)    }}</code></pre><h1 id="在补充异常的do-catch里使用"><a href="#在补充异常的do-catch里使用" class="headerlink" title="在补充异常的do/catch里使用"></a>在补充异常的<code>do/catch</code>里使用</h1><pre><code class="Swift">enum SomeError: Error {    case error1(Int)    case error2(String)}func methodError() throws {    throw SomeError.error1(3)}test(&quot;在补充异常的do/catch里使用&quot;) {    do {        try methodError()    } catch SomeError.error1(let param) where param &gt; 2 { // 捕获异常时判断参数        print(&quot;判断参数的异常: \(param)&quot;)    } catch {        print(&quot;默认异常处理&quot;)    }}</code></pre><h1 id="协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展"><a href="#协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展" class="headerlink" title="协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展"></a>协议使用<code>where</code>情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展</h1><p>也可参考Swift面向协议编程.md</p><pre><code class="Swift">protocol SomeProtocolA {    func someProtocolMethodA()}class A: SomeProtocolA {    let a = 1       func someProtocolMethodA() {        print(a)    }}class B {    let b = 2}// 针对类 A 扩展协议// 基类A继承了SomeProtocol协议才能添加扩展// 说人话：如果类A实现了 SomeProtocol 协议，那么可以进行扩展extension SomeProtocolA where Self: A {    func showParamA() {        print(self.a)    }}// 针对类 B 扩展协议// 反例，不符合where条件extension SomeProtocolA where Self: B {    func someProtocolMethodA() {        print(&quot;someMethodProtocolA&quot;)    }}test(&quot;协议使用where情形一：针对某个类扩展协议（只有基类实现了当前协议才能添加扩展）&quot;) {    // 换个说法， 多个类实现了同一个协议，该语法根据类名分别为这些类添加扩展， 注意是分别(以类名区分)！！！        let objA = A()    let objB = B()  // 类B没实现SomeProtocol， 所有没有协议方法    objA.showParamA()  //输出1}protocol SomeProtocolB {    func someProtocolMethodB()}// 针对协议 A 扩展协议 Bextension SomeProtocolB where Self: SomeProtocolA {    func someProtocolMethodB() {        print(&quot;SomeProtocolB&quot;)    }}class C: SomeProtocolA &amp; SomeProtocolB {    func someProtocolMethodA() {        print(#function)    }    func someProtocolMethodB() {        print(#function)    }}</code></pre><h1 id="协议使用where-情形二：只有基类同时遵守了另外一个协议才能添加扩展"><a href="#协议使用where-情形二：只有基类同时遵守了另外一个协议才能添加扩展" class="headerlink" title="协议使用where:情形二：只有基类同时遵守了另外一个协议才能添加扩展"></a>协议使用<code>where</code>:情形二：只有基类同时遵守了另外一个协议才能添加扩展</h1><pre><code class="Swift">protocol SomeProtocolB {    func someProtocolMethodB()}// 针对协议 A 扩展协议 Bextension SomeProtocolB where Self: SomeProtocolA {    func someProtocolMethodB() {        print(&quot;SomeProtocolB&quot;)    }}class C: SomeProtocolA &amp; SomeProtocolB {    func someProtocolMethodA() {        print(#function)    }    func someProtocolMethodB() {        print(#function)    }}test(&quot;协议使用where:情形二：只有基类同时遵守了另外一个协议才能添加扩展&quot;) {    let objC = C()    objC.someProtocolMethodA()}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合遍历-forEach-中使用&quot;&gt;&lt;a href=&quot;#集合遍历-forEach-中使用&quot; class=&quot;headerlink&quot; title=&quot;集合遍历 forEach 中使用&quot;&gt;&lt;/a&gt;集合遍历 &lt;code&gt;forEach&lt;/code&gt; 中使用&lt;/h1&gt;&lt;pre
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://superkk.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>React-Native模版</title>
    <link href="http://superkk.top/2018/05/21/React-Native%E6%A8%A1%E7%89%88/"/>
    <id>http://superkk.top/2018/05/21/React-Native模版/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:37:06.699Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift高阶函数</title>
    <link href="http://superkk.top/2018/05/21/Swift%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>http://superkk.top/2018/05/21/Swift中的高阶函数/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T16:10:11.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift高阶函数"><a href="#Swift高阶函数" class="headerlink" title="Swift高阶函数"></a>Swift高阶函数</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h2><p>对数组中的每个元素执行一次block中的操作</p><p>例如，获取数组中对象的某个属性，返回一个新的数组</p><pre><code>// 获取字典中所有 value 返回一个数组，然后获取数组中对象的name字段，返回一个数组let huxingMapDeviceNames:[String : DeviceModal] = Array(huxingMapDevices.values).map {$0.name}</code></pre><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><code>flatMap</code></h2><ul><li>flatMap 与 map 不同之处是</li></ul><ol><li>flatMap返回后的数组中不存在 nil 同时它会把Optional解包;</li><li>flatMap 还能把数组中存有数组的数组 一同打开变成一个新的数组 ;</li><li>flatMap也能把两个不同的数组合并成一个数组 这个合并的数组元素个数是前面两个数组元素个数的乘积</li></ol><p>例如上面的例子中返回的数组每个元素类型是 option(string)</p><p>而如果使用 flatmap 那么就是 string</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a><code>Filter</code></h2><p>filter 可以取出数组中符合条件的元素 重新组成一个新的数组, 可以帮我们把数组中不需要的值都去掉</p><pre><code>let numbers = [1,2,3,4,5,6]let evens = numbers.filter { $0 % 2 == 0 }// [2, 4, 6]</code></pre><h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a><code>Reduce</code></h2><p>用于把所有元素的值合并成一个新的值</p><h3 id="比如我们要获得一个数组中所有元素的和"><a href="#比如我们要获得一个数组中所有元素的和" class="headerlink" title="比如我们要获得一个数组中所有元素的和"></a>比如我们要获得一个数组中所有元素的和</h3><pre><code>let numbers = [1,2,3,4,5]// reduce 函数第一个参数是返回值的初始化值let sum = numbers.reduce(0) { $0 + $1 }</code></pre><blockquote><p> 这里我写下完整的格式</p></blockquote><pre><code>let sum1 = numbers.reduce(0) { total, num in    // 这里写不写return在Playground都循环5次 但上面用最洁简的方法显示循环6次。。。 What The Fuck 这是什么鬼！！！    return total + num}// 15</code></pre><h3 id="合并数组中的字符串"><a href="#合并数组中的字符串" class="headerlink" title="合并数组中的字符串"></a>合并数组中的字符串</h3><pre><code>let numbers = [1,5,1,8,8,8,8,8,8,8,8]// reduce 函数第一个参数是返回值的初始化值let tel = numbers.reduce(&quot;&quot;) { &quot;\($0)&quot; + &quot;\($1)&quot; }// 15188888888</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift高阶函数&quot;&gt;&lt;a href=&quot;#Swift高阶函数&quot; class=&quot;headerlink&quot; title=&quot;Swift高阶函数&quot;&gt;&lt;/a&gt;Swift高阶函数&lt;/h1&gt;&lt;h2 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://superkk.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift要点</title>
    <link href="http://superkk.top/2018/05/21/Swift%E8%A6%81%E7%82%B9/"/>
    <id>http://superkk.top/2018/05/21/Swift要点/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T16:10:11.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift中的Array与Dictionary为struct类型"><a href="#Swift中的Array与Dictionary为struct类型" class="headerlink" title="Swift中的Array与Dictionary为struct类型"></a>Swift中的Array与Dictionary为struct类型</h1><p>在 Swift 中所有的基本类型，包括 Array 和 Dictionary 这些传统意义上会是 class 的东西，统统都是 struct 类型，并不能由 AnyObject 来表示，于是 Apple 提出了一个更为特殊的 Any，除了class 以外，它还可以表示包括 struct 和 enum 在内的所有类型。<br><a href="http://swifter.tips/any-anyobject/" target="_blank" rel="noopener">http://swifter.tips/any-anyobject/</a></p><h1 id="Swift中的-self"><a href="#Swift中的-self" class="headerlink" title="Swift中的.self"></a>Swift中的<code>.self</code></h1><ul><li>2 在 Swift 中，<code>.self</code> 可以用在类型后面取得类型本身，也可以用在某个实例后面取得这个实例本身。<br>前一种方法可以用来获得一个表示该类型的值，这在某些时候会很有用；而后者因为拿到的实例本身<br><a href="http://swifter.tips/self-anyclass/" target="_blank" rel="noopener">http://swifter.tips/self-anyclass/</a></li></ul><h1 id="Swift中类转字符串"><a href="#Swift中类转字符串" class="headerlink" title="Swift中类转字符串"></a>Swift中类转字符串</h1><pre><code class="Swift">NSStringFromClass(UserProfileCell.self)// &quot;WechatMoments.UserProfileCell&quot;String(describing: UserProfileCell.self)// &quot;UserProfileCell&quot;String(describing: type(of: UserProfileCell.self))// &quot;UserProfileCell.Type&quot;String(describing: type(of: self))// &quot;UserProfileSectionController&quot;</code></pre><h1 id="NSObject-AnyObject-Any"><a href="#NSObject-AnyObject-Any" class="headerlink" title="NSObject, AnyObject, Any"></a><code>NSObject</code>, <code>AnyObject</code>, <code>Any</code></h1><ul><li><p><code>NSObject</code>：是OC中的基类</p></li><li><p><code>AnyObject</code>： 包含了<code>NSObject</code>以及Swift中定义的类的对象</p></li><li><p><code>Any</code>：所有的类型，包括了AnyObject，以及闭包类型</p></li></ul><p>所以在范围上：Any &gt; AnyObject &gt; NSObject</p><h1 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a><code>is</code>运算符</h1><p>is 用于运行时判断具体类型，类似于isKindOfClass</p><h1 id="Swift包管理工具"><a href="#Swift包管理工具" class="headerlink" title="Swift包管理工具"></a>Swift包管理工具</h1><p><a href="https://swift.org/package-manager/#example-usage" target="_blank" rel="noopener">https://swift.org/package-manager/#example-usage</a></p><p>|命令|描述|</p><p>|:-|:-|</p><p>|<code>swift package init --type executable</code>|创建可执行的包|</p><p>|<code>swift package init --type library</code>|创建库|</p><p>| <code>swift package update</code> | 更新一个包的依赖 |</p><p>| <code>swift package generate-xcodeproj</code> | 为包生成 Xcode 项目 |</p><p>| <code>swift build</code> | 编译库或可执行文件 |</p><p>| <code>swift test</code> | 运行测试 |</p><h1 id="swift-中-static-与-class-关键字"><a href="#swift-中-static-与-class-关键字" class="headerlink" title="swift 中 static 与 class 关键字"></a>swift 中 <code>static</code> 与 <code>class</code> 关键字</h1><h2 id="在类中"><a href="#在类中" class="headerlink" title="在类中"></a>在类中</h2><h3 id="static方法-与-class方法"><a href="#static方法-与-class方法" class="headerlink" title="static方法 与 class方法"></a><code>static方法</code> 与 <code>class方法</code></h3><ul><li><p><code>class 方法</code> 即 OC 中的类方法</p></li><li><p><code>static 方法</code> 类方法，同时不允许子类重载</p></li></ul><h3 id="static变量-与-class变量"><a href="#static变量-与-class变量" class="headerlink" title="static变量 与 class变量"></a><code>static变量</code> 与 <code>class变量</code></h3><ul><li><p><code>class 变量</code> swift当前版本暂不支持</p></li><li><p><code>static 变量</code> 类变量</p></li></ul><h1 id="Swift性能优化分析"><a href="#Swift性能优化分析" class="headerlink" title="Swift性能优化分析"></a>Swift性能优化分析</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190830000526.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190830000534.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift中的Array与Dictionary为struct类型&quot;&gt;&lt;a href=&quot;#Swift中的Array与Dictionary为struct类型&quot; class=&quot;headerlink&quot; title=&quot;Swift中的Array与Dictionary为stru
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://superkk.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift map,flatMap,flatMapLatest的区别</title>
    <link href="http://superkk.top/2018/05/21/RxSwift%20map,flatMap,flatMapLatest%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://superkk.top/2018/05/21/RxSwift map,flatMap,flatMapLatest的区别/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T16:19:38.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190830001857.png" alt=""></p><h1 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190830001915.png" alt=""></p><h1 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190830001930.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink&quot; title=&quot;map&quot;&gt;&lt;/a&gt;map&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/action456789/Image/mas
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="Rx &amp; RAC" scheme="http://superkk.top/categories/iOS/Rx-RAC/"/>
    
    
      <category term="Swift" scheme="http://superkk.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>fastlane</title>
    <link href="http://superkk.top/2018/05/21/fastlane/"/>
    <id>http://superkk.top/2018/05/21/fastlane/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T15:39:53.109Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="官方文档（推荐）"><a href="#官方文档（推荐）" class="headerlink" title="官方文档（推荐）"></a>官方文档（推荐）</h1><p><a href="https://docs.fastlane.tools/getting-started/ios/setup/" target="_blank" rel="noopener">https://docs.fastlane.tools/getting-started/ios/setup/</a></p><h1 id="Mac上ruby管理工具-RVM"><a href="#Mac上ruby管理工具-RVM" class="headerlink" title="Mac上ruby管理工具 RVM"></a>Mac上ruby管理工具 <code>RVM</code></h1><p>因为rvm可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。</p><h2 id="安装rvm"><a href="#安装rvm" class="headerlink" title="安装rvm"></a>安装rvm</h2><pre><code>$ curl -L get.rvm.io | bash -s stable$ source ~/.rvm/scripts/rvm</code></pre><p>等待终端加载完毕,后输入：</p><pre><code>rvm -v</code></pre><p>如果能显示版本好则安装成功了。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>|描述|命令|</p><p>|:-|:-|</p><p>| 列出ruby可安装的版本信息 | <code>rvm list known</code> |</p><p>| 更新RVM | <code>rvm get stable</code> |</p><p>| 查看当前ruby版本 | rvm -v |</p><p>| 安装一个ruby版本 | <code>rvm install 2.3.3</code> |</p><p>| 设置为默认版本 | <code>rvm use 2.3.3 --default</code> |</p><p>| 使用某个版本 | <code>rvm use 2.3.3</code> |</p><p>| 查看已安装的ruby | <code>rvm list</code> |</p><p>| 卸载一个已安装ruby版本 | <code>rvm remove 2.3.3</code> |</p><p>| 查看已有的源 | <code>gem source -l</code> |</p><p><br></p><p><br></p><hr><p><br></p><h1 id="gem-常用命令"><a href="#gem-常用命令" class="headerlink" title="gem 常用命令"></a>gem 常用命令</h1><p>官网<a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a></p><p>|描述|命令|</p><p>|:-|:-|</p><p>| 更新 gem | <code>sudo gem update --system</code>  |</p><p>| 从Gem源安装gem包  |  <code>gem install [gemname]</code> |</p><p>| 更新所有已安装的gem包 |<code>gem update</code> |</p><p>| 更新指定的gem包 | <code>gem update [gemname]</code>|</p><p>| 删除指定的gem包，注意此命令将删除所有已安装的版本| <code>gem uninstall [gemname]</code>|</p><p>| 查看本机已安装的所有gem包 | <code>gem list [--local]</code> |</p><p>| 查看镜像 | <code>gem sources -l</code> |</p><p>| 修改镜像 |gem sources –add <a href="https://gems.ruby-china.org/" target="_blank" rel="noopener">https://gems.ruby-china.org/</a> –remove <a href="https://rubygems.org/，可以进入这两个网址查看详细信息" target="_blank" rel="noopener">https://rubygems.org/，可以进入这两个网址查看详细信息</a> |</p><h1 id="fastlane"><a href="#fastlane" class="headerlink" title="fastlane"></a>fastlane</h1><p>官网<a href="https://fastlane.tools/" target="_blank" rel="noopener">https://fastlane.tools/</a></p><p>github: <a href="https://github.com/fastlane/fastlane/tree/master/snapshot" target="_blank" rel="noopener">https://github.com/fastlane/fastlane/tree/master/snapshot</a></p><p>|命令|描述|</p><p>|:-|:-|</p><p>| <code>sudo gem install fastlane -NV</code> | 安装/更新 fastlane |</p><p> | <code>fastlane init</code>| 进入工程目录，初始化 fastlane 配置 |</p><p>| <code>fastlane update_fastlane</code> | 更新fastlane各种插件等 |</p><p>| <code>fastlane actions</code> |      列出所有可用fastlane活动 | </p><p>| <code>fastlane action [action_name]</code> |    显示一个更详细的活动描述| </p><p> | <code>fastlane lanes</code>   |     列出所有可用lanes (有描述) | </p><p> | <code>fastlane list</code>  |     列出所有可用lanes (没有描述)  | </p><p> | <code>fastlane new_action</code> |    在fastlane创建一个活动(集成) | </p><p> | <code>fastlane search_plugins</code> |  查看所有插件 | </p><p> | <code>fastlane add_plugin firim</code> |  安装插件 firim | </p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a>TODO:</h1><p>由于<code>xcodebuild -showBuildSettings -project ./RiciBellSDKDemo.xcodeproj</code> 命令卡死，导致无法继续，暂时没有找到解决办法，可能是因为使用了Xcode9 beta 版的Bug导致，后期再继续</p><p>收藏一篇博客<a href="http://www.jianshu.com/p/228354881eab" target="_blank" rel="noopener">http://www.jianshu.com/p/228354881eab</a></p><h2 id="gym"><a href="#gym" class="headerlink" title="gym"></a>gym</h2><p> 类似于<code>shenzhen</code></p><p><a href="https://github.com/fastlane/fastlane/tree/master/gym#export-options" target="_blank" rel="noopener">https://github.com/fastlane/fastlane/tree/master/gym#export-options</a></p><p>|命令|描述|</p><p>|:-|:-|</p><p>| <code>gym init</code> | 创建Gymfile文件 |</p><h2 id="fastlane-的工具链"><a href="#fastlane-的工具链" class="headerlink" title="fastlane 的工具链"></a>fastlane 的工具链</h2><p>在 fastlane 这个大家庭中，包含了下列工具：</p><ul><li>produce 创建可用于 iTunes Connect 和 Apple Developer Portal 的 iOS app。</li><li>cert 自动创建和维护 iOS 代码签名证书。</li><li>sigh 创建、更新、下载和修复 provisioning profiles。</li><li>snapshot 自动将 App 屏幕截图本地化到每种设备上。</li><li>frameit 将屏幕截图适配到适当的设备屏幕大小。</li><li>gym 创建和打包 iOS app。</li><li>deliver 上传屏幕截图、元数据和 App 到 App 商店。<h1 id="安装-fir"><a href="#安装-fir" class="headerlink" title="安装 fir"></a>安装 fir</h1></li></ul><p>1、安装</p><p>|描述|命令|</p><p>|:-|:-|</p><p>| 安装 fir-cli | <code>gem install fir-cli</code> |</p><p>2、获取token登陆</p><p>获取 fir 账号的 token，当使用 fir login 登录了之后, 后续命令都不需要加上 -T 参数, 会默认使用当前用户的 token 进行相关操作</p><p>|描述|命令|</p><p>|:-|:-|</p><p>| 登陆 fir-cli | <code>fir login XXX_YOUR_API_TOKEN_XXX</code> |</p><p>3、编译打包 ipa 文件</p><p>|描述|命令| 参数说明|</p><p>|:-|:-|:- |</p><p>| 编译打包 ipa 文件 | <code>schema=&quot;testFir&quot; fir build_ipa ~/Developer/$schema -o ~/Developer/build -w -C Release -S &quot;$schema&quot;</code> | -w 是 –workspace 的简写，表示编译 *.xcworkspace, 没有带这个参数则编译 xcodeproj 文件。<br> -C Release, 以 Release 方式打包，若 Debug 则是打调试包。 <br> -S: 编译用 CocoaPods 做依赖管理的 .ipa 包|</p><p>4、上传 ipa</p><p>|描述|命令| 参数说明|</p><p>|:-|:-|:- |</p><p>| 上传 ipa | <code>fir publish -c &quot;first version log&quot; ${schema}*.ipa</code> | -c 后带 log。默认的包名是 schema-版本号-build－build 号，如 testFir-2.5.3-build-576.ipa。 |</p><h1 id="使用-fastlane进行持续集成"><a href="#使用-fastlane进行持续集成" class="headerlink" title="使用 fastlane进行持续集成"></a>使用 fastlane进行持续集成</h1><h1 id="报错：You-don-39-t-have-write-permissions-for-the-usr-bin-directory"><a href="#报错：You-don-39-t-have-write-permissions-for-the-usr-bin-directory" class="headerlink" title="报错：You don&#39;t have write permissions for the /usr/bin directory."></a>报错：<code>You don&#39;t have write permissions for the /usr/bin directory.</code></h1><p><code>sudo gem install fastlane -n /usr/local/bin</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;官方文档（推荐）&quot;&gt;&lt;a href=&quot;#官方文档（推荐）&quot; class=&quot;headerlink&quot; title=&quot;官方文档（推荐）&quot;&gt;&lt;/a&gt;官方文档（推荐）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.fastlane.to
      
    
    </summary>
    
      <category term="工具" scheme="http://superkk.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序</title>
    <link href="http://superkk.top/2018/05/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://superkk.top/2018/05/21/微信小程序/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:54:14.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="升级（检查更新）"><a href="#升级（检查更新）" class="headerlink" title="升级（检查更新）"></a>升级（检查更新）</h1><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html</a></p><h1 id="使用mpvue进行小程序开发"><a href="#使用mpvue进行小程序开发" class="headerlink" title="使用mpvue进行小程序开发"></a>使用mpvue进行小程序开发</h1><h2 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h2><p><code>一斤代码</code>的简书<a href="https://www.jianshu.com/p/8f779950bfd9" target="_blank" rel="noopener">https://www.jianshu.com/p/8f779950bfd9</a></p><h2 id="在mpvue中使用Vant-Weapp组件库"><a href="#在mpvue中使用Vant-Weapp组件库" class="headerlink" title="在mpvue中使用Vant Weapp组件库"></a>在mpvue中使用Vant Weapp组件库</h2><ul><li><p>1、将下载的小程序组件的<code>dist</code>目录拷贝到工程static目录下，然后改名，比如van-weapp<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225337.png" alt=""></p></li><li><p>2、打开ES6转ES5<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225350.png" alt=""></p></li><li><p>3、在需要使用van-weapp组件的页面创建main.json文件，并进行引入<br>然后在main.json中添加如下内容</p><pre><code class="json">{  &quot;usingComponents&quot;: {      &quot;van-tab&quot;: &quot;../../../static/vant-weapp/tab/index&quot;,      &quot;van-tabs&quot;: &quot;../../../static/vant-weapp/tabs/index&quot;  }}</code></pre></li><li>4、使用自定义组件<pre><code class="Vue">  &lt;!-- 使用第三方组件 --&gt;  &lt;van-tabs v-bind:active=&quot;active&quot; @click=&quot;onChange&quot;&gt;    &lt;van-tab title=&quot;标签 1&quot;&gt;内容 1&lt;/van-tab&gt;    &lt;van-tab title=&quot;标签 2&quot;&gt;内容 2&lt;/van-tab&gt;    &lt;van-tab title=&quot;标签 3&quot;&gt;内容 3&lt;/van-tab&gt;    &lt;van-tab title=&quot;标签 4&quot;&gt;内容 4&lt;/van-tab&gt;  &lt;/van-tabs&gt;</code></pre></li><li>注意：在vant-weapp的官方文档中的具体用法是使用wxml的语法，所以我们不能直接照搬使用<br>比如官方文档示例代码为：<pre><code>&lt;van-tabs active=&quot;{{ active }}&quot; bind:change=&quot;onChange&quot;&gt;&lt;van-tab title=&quot;标签 1&quot;&gt;内容 1&lt;/van-tab&gt;&lt;van-tab title=&quot;标签 2&quot;&gt;内容 2&lt;/van-tab&gt;&lt;van-tab title=&quot;标签 3&quot;&gt;内容 3&lt;/van-tab&gt;&lt;van-tab title=&quot;标签 4&quot;&gt;内容 4&lt;/van-tab&gt;&lt;/van-tabs&gt;</code></pre>具体参考<a href="https://www.jianshu.com/p/2adff147b8a6" target="_blank" rel="noopener">https://www.jianshu.com/p/2adff147b8a6</a></li></ul><p>其他参考：<a href="https://www.jianshu.com/p/1b3b9e17ac88" target="_blank" rel="noopener">https://www.jianshu.com/p/1b3b9e17ac88</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;升级（检查更新）&quot;&gt;&lt;a href=&quot;#升级（检查更新）&quot; class=&quot;headerlink&quot; title=&quot;升级（检查更新）&quot;&gt;&lt;/a&gt;升级（检查更新）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/mini
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="微信小程序" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Native Tips</title>
    <link href="http://superkk.top/2018/05/21/React-Native%20Tips/"/>
    <id>http://superkk.top/2018/05/21/React-Native Tips/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:25:52.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速进入断点"><a href="#快速进入断点" class="headerlink" title="快速进入断点"></a>快速进入断点</h1><ol><li>模拟器开启远程调试</li><li>在浏览器上<code>cmd+option+I</code>打开调试页面</li><li>代码输入<code>dubugger</code>进入断点<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211638.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211651.png" alt=""></li></ol><h1 id="更新node"><a href="#更新node" class="headerlink" title="更新node"></a>更新node</h1><ul><li>1、更新npm<br><code>npm -v</code><br><code>npm install npm@latest -g</code></li><li>2、更新node<pre><code>sudo npm cache clean -fsudo npm install -g nsudo n stable</code></pre></li></ul><p>参考：<a href="https://www.hostingadvice.com/how-to/update-node-js-latest-version/" target="_blank" rel="noopener">https://www.hostingadvice.com/how-to/update-node-js-latest-version/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速进入断点&quot;&gt;&lt;a href=&quot;#快速进入断点&quot; class=&quot;headerlink&quot; title=&quot;快速进入断点&quot;&gt;&lt;/a&gt;快速进入断点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;模拟器开启远程调试&lt;/li&gt;
&lt;li&gt;在浏览器上&lt;code&gt;cmd+option+I&lt;/code
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>MacOS安装Jenkins</title>
    <link href="http://superkk.top/2018/05/21/Jenkins%E5%AE%89%E8%A3%85/"/>
    <id>http://superkk.top/2018/05/21/Jenkins安装/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T15:10:23.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文档建议只看两处，蒲公英和fastlane的"><a href="#文档建议只看两处，蒲公英和fastlane的" class="headerlink" title="文档建议只看两处，蒲公英和fastlane的"></a>文档建议只看两处，蒲公英和fastlane的</h1><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>启动<br><code>sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</code></li><li>关闭<br><code>sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</code></li></ul><h1 id="解决无法安装插件问题"><a href="#解决无法安装插件问题" class="headerlink" title="解决无法安装插件问题"></a>解决无法安装插件问题</h1><ol><li>第一步：<code>插件管理 -&gt; Advanced -&gt; Update Site</code>中，将https改为http</li><li>第二部：重启jenkins服务</li></ol><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225004.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225013.png" alt=""></p><h1 id="权限问题导致无法执行脚本"><a href="#权限问题导致无法执行脚本" class="headerlink" title="权限问题导致无法执行脚本"></a>权限问题导致无法执行脚本</h1><p>有两种解决办法：</p><h2 id="方法一：设置用户权限（不推荐）"><a href="#方法一：设置用户权限（不推荐）" class="headerlink" title="方法一：设置用户权限（不推荐）"></a>方法一：设置用户权限（不推荐）</h2><p><strong>这样设置后依然会存在其他的一系列问题，例如执行fastlane脚本报错 </strong></p><p>一般情况下，使用jenkins官网下载的安装包安装会出现这个问题。</p><p>在官网下载dmg安装包，安装完毕即可在本机搭建jenkins的工作。但是jenkins不会用本地的用户去构建，任何创建的文件都是“jenkins”用户所有，这会造成很多权限问题，无法调用自己写的脚本，执行shell会出现没有权限的错误。</p><ul><li>解决办法：修改jenkins用户群组和用户</li><li>第一步：查看自己的群组和用户名称： </li></ul><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225032.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225044.png" alt=""></p><ul><li>第二步：更改 Jenkins 用户群组和用户名称</li></ul><pre><code class="javascript">//停止Jenkinssudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist// 修改group 和usersudo vim +1 +/daemon +’s/daemon/staff/’ +/daemon +’s/daemon/ks’ +wq org.jenkins-ci.plistsudo chown -R ks:staff /Users/Shared/Jenkins/// 开始Jenkinssudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</code></pre><p>或者你也可以手动修改 org.jenkins-ci.plist 文件中的内容<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225107.png" alt=""></p><ul><li>第三步：若无法打开jenkins，需要修改下权限</li></ul><pre><code class="script">$ sudo chown -R userName /Users/Shared/Jenkins$ sudo chown -R userName /var/log/jenkins#重启Jenkins$ sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</code></pre><ul><li>WARING: Jenkins更改工作空间会导致原来的数据全部丢失<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225126.png" alt=""><br>参考：<a href="https://www.cnblogs.com/ihojin/p/jenkins-permission.html" target="_blank" rel="noopener">https://www.cnblogs.com/ihojin/p/jenkins-permission.html</a></li></ul><h2 id="方法二：使用gem重新安装jenkins（推荐）"><a href="#方法二：使用gem重新安装jenkins（推荐）" class="headerlink" title="方法二：使用gem重新安装jenkins（推荐）"></a>方法二：使用gem重新安装jenkins（推荐）</h2><ul><li>卸载使用安装包安装的jenkins</li></ul><pre><code>//进入以下目录，双击运行/Library/Application Support/Jenkins/Uninstall.command//也可以这样运行sh &quot;/Library/Application Support/Jenkins/Uninstall.command&quot;//删除配置，这个可选sudo rm -rf /var/root/.jenkins ~/.jenkinssudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plistsudo rm /Library/LaunchDaemons/org.jenkins-ci.plistsudo rm -rf /Applications/Jenkins &quot;/Library/Application Support/Jenkins&quot; /Library/Documentation/Jenkinssudo rm -rf /Users/Shared/Jenkinssudo dscl . -delete /Users/jenkinssudo dscl . -delete /Groups/jenkinssudo rm -f /etc/newsyslog.d/jenkins.confpkgutil --pkgs | grep &#39;org\.jenkins-ci\.&#39; | xargs -n 1 sudo pkgutil --forget//如果使用brew安装的，可以执行以下命令brew uninstall jenkins</code></pre><ul><li>安装</li></ul><pre><code>brew update &amp;&amp; brew install jenkins</code></pre><ul><li>启动</li></ul><pre><code>jenkins</code></pre><p>参考：<a href="https://docs.fastlane.tools/best-practices/continuous-integration/jenkins/" target="_blank" rel="noopener">https://docs.fastlane.tools/best-practices/continuous-integration/jenkins/</a></p><p><br></p><h1 id="Jenkins如何使用本地git仓库"><a href="#Jenkins如何使用本地git仓库" class="headerlink" title="Jenkins如何使用本地git仓库"></a>Jenkins如何使用本地git仓库</h1><p>git地址填写为本地文件路径即可<br><code>file:///home/rbkcbeqc/dev/git/gitsandbox.</code><br>参考：<a href="https://stackoverflow.com/questions/10498554/jenkins-linking-to-my-local-git-repository" target="_blank" rel="noopener">https://stackoverflow.com/questions/10498554/jenkins-linking-to-my-local-git-repository</a></p><h1 id="全局变量如何使用"><a href="#全局变量如何使用" class="headerlink" title="全局变量如何使用"></a>全局变量如何使用</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225149.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829225218.png" alt=""></p><p>这里自己添加的变量可以在shell脚本中直接使用。</p><pre><code class="sh">echo $TOKEN_SIT</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文档建议只看两处，蒲公英和fastlane的&quot;&gt;&lt;a href=&quot;#文档建议只看两处，蒲公英和fastlane的&quot; class=&quot;headerlink&quot; title=&quot;文档建议只看两处，蒲公英和fastlane的&quot;&gt;&lt;/a&gt;文档建议只看两处，蒲公英和fastlan
      
    
    </summary>
    
      <category term="工具" scheme="http://superkk.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>快捷键</title>
    <link href="http://superkk.top/2018/05/21/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://superkk.top/2018/05/21/快捷键/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:57:04.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webstrom-IDEA-快捷键"><a href="#Webstrom-IDEA-快捷键" class="headerlink" title="Webstrom/IDEA 快捷键"></a>Webstrom/IDEA 快捷键</h1><ul><li><code>双击 Shift / cmd + shift + A</code>：全局搜索</li><li><code>cmd + B</code>: 跳到变量申明处</li><li><code>cmd + iption + B</code>: 跳转接口实现类</li><li><code>ctrl + F12</code>: 可以显示当前文件的结构</li><li><code>ctrl + D</code>: 行复制</li><li><code>cmd + Home/End</code>：跳到文件头/尾</li><li><code>cmd + K</code>: 代码补全 </li><li><code>cmd + option + T</code>：用 if, else, try, catch, for 等来围绕选中的代码块</li><li><code>cmd + N / ctrl + 回车</code>：打开代码生成菜单</li><li><code>cmd + P</code>：显示方法具体信息</li><li><code>ctrl + J</code>：查看方法文档</li><li><code>cmd + E</code>：显示打开的文件历史记录</li><li><code>cmd + U</code>：进入父类</li><li><code>cmd + ⬆️/⬇️</code>：进入上一个/下一个方法</li><li><code>cmd  + shift + T</code>：查看类、属性列表</li><li><code>option+ F7</code>：全局找到自己被使用的地方</li><li><code>cmd + F7</code>：在当前文件找到自己被使用的地方</li><li><code>cmd + PgUp / PgDn</code>：左右tab切换</li><li><code>cmd +W</code>：关闭当前tab</li><li><code>cmd + option + U</code>：显示类/接口的依赖关系UML图</li><li><code>cmd + option + V</code>：自动生成返回值</li><li><code>cmd + F9</code>：编译（idea热部署）</li><li><p><code>option + shift +  ⬆️/⬇️</code>： 移动行</p></li><li><p>自动import</p><ul><li><code>ctrl+option+O</code>：删除未使用的引用</li></ul></li><li><p>多光标操作</p><ul><li><code>ctrl+G</code>：选中出现的单词并添加光标（Windows上为<code>Alt + J</code>）</li><li><code>ctrl+shift+G</code>：取消选中出现的单词（Windows上的Alt + Shift + J）</li><li><code>option+shift+鼠标左键单机</code>：在单击处添加光标</li><li><code>option+鼠标拖动</code>：在选中处添加光标</li></ul></li><li><p>选中操作</p><ul><li><code>option+ ⬆️/⬇️</code>：增加选中范围 / 减少选中范围</li><li><code>cmd+option+M</code>：使用选中代码段生成函数</li><li><code>cmd+option+T</code>：使用try catch等包围代码段</li></ul></li></ul><p><a href="https://blog.jetbrains.com/phpstorm/2014/03/working-with-multiple-selection-in-phpstorm-8-eap/" target="_blank" rel="noopener">https://blog.jetbrains.com/phpstorm/2014/03/working-with-multiple-selection-in-phpstorm-8-eap/</a></p><h1 id="android模拟器快捷键"><a href="#android模拟器快捷键" class="headerlink" title="android模拟器快捷键"></a>android模拟器快捷键</h1><ul><li><code>cmd + m</code> 显示开发者菜单</li><li><code>R + R</code> reload</li></ul><h1 id="iOS模拟器快捷键"><a href="#iOS模拟器快捷键" class="headerlink" title="iOS模拟器快捷键"></a>iOS模拟器快捷键</h1><ul><li><code>cmd + d</code>/<code>ctrl+command+z</code> 显示开发者菜单</li><li><code>cmd + r</code> reload<br>单使用模拟器软键盘时，<code>cmd+r</code>/<code>cmd+d</code>可能失效，此时使用<code>ctrl+command+z</code>即可<br>或者：<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829224617.png" alt=""><h2 id="React-Native-命令"><a href="#React-Native-命令" class="headerlink" title="React Native 命令"></a>React Native 命令</h2><code>react-native start</code>：启动react native服务器<br>在特定模拟器上启动<br><code>react-native run-ios --simulator &quot;iPhone 7 Plus”</code><h1 id="VSCode快捷键"><a href="#VSCode快捷键" class="headerlink" title="VSCode快捷键"></a>VSCode快捷键</h1><h2 id="JSON-格式化"><a href="#JSON-格式化" class="headerlink" title="JSON 格式化"></a>JSON 格式化</h2></li></ul><p>安装插件<code>JSON Tools</code></p><p><a href="https://marketplace.visualstudio.com/items?itemName=eriklynd.json-tools" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=eriklynd.json-tools</a></p><p><code>Ctrl(Cmd)+Alt+M</code> for JSON pretty.</p><p><code>Alt+M</code> for JSON minify.</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>Cmd + Shift + p</code>打开命令面板</p><p><code>Cmd+T</code>跳转到关键字（全局搜索变量或者函数）</p><p><code>Option + Cmd + ⬅️/➡️</code> 不同tab间切换</p><p><code>Ctrl + -</code> 前进（跳转到函数之后跳转回之前的位置）</p><p><code>Ctrl + Shift + -</code> 后退</p><p><code>ctrl + shift + y</code>打开/关闭Debug Console</p><p><code>Ctrl + ~</code> 打开/关闭终端（注意要在英文输入状态下，英文状态下是ctrl + ·导致无效）</p><p><code>Cmd+1</code>显示/隐藏侧边栏</p><p><code>Shift+cmd+k</code>删除当前行</p><p><code>Ctrl + G</code> 转到行</p><p><code>Ctrl + P</code> 转到文件</p><p><code>Ctrl + Shift + O</code> 跳转到关键字（文件内搜索变量或者函数）</p><p><code>Shift+Option+ ↑ / ↓</code> 移动当前行到上一行/下一行</p><p><code>Cmd+E</code>打开最近项目目录</p><ul><li>多光标操作</li></ul><p><code>cmd+shift+L</code>添加光标到所有出现的单词处，并选中</p><p><code>cmd+g</code>与<code>cmd+shift+L</code>配合可以在选中的单词间跳转</p><h1 id="微信小程序编辑器快捷键"><a href="#微信小程序编辑器快捷键" class="headerlink" title="微信小程序编辑器快捷键"></a>微信小程序编辑器快捷键</h1><h2 id="windows-下"><a href="#windows-下" class="headerlink" title="windows 下"></a>windows 下</h2><p><code>ctrl+p</code> 快速查找文件<br><code>ctrl+e</code> 快速查找最近打开过的文件</p><h1 id="eclipse快捷键"><a href="#eclipse快捷键" class="headerlink" title="eclipse快捷键"></a>eclipse快捷键</h1><p>选中代码，ctrl + 1，打开列表<br>反撤销，ctrl + y</p><h1 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h1><ul><li>撤销: 退出编辑模式，然后快速输入 u 两次 </li><li>反撤销:    退出编辑模式，然后快速输入 ctrl + r 两次</li><li>粘贴:p</li></ul><h1 id="Xcode快捷键"><a href="#Xcode快捷键" class="headerlink" title="Xcode快捷键"></a>Xcode快捷键</h1><p>| 快捷键 | 说明 |</p><p>|:-|:-|</p><p>| Command + Shift + O | 快速查找文件/文件夹 |</p><p>| Ctrl + 6 | 在类中快速查查找方法 |</p><p>| Ctrl + 2| 显示最近的浏览记录|</p><p>| Command + Shift + j  | 显示当前文件，在导航拦中的位置 |</p><p>|option + cmd + 回车| 打开辅助视图 |</p><p>|cmd + 回车 | 取消辅助视图 |</p><p>| option（即windows下Alt键） + Cmd + 0 | 关闭Xcode右边的窗口 |</p><p>| Cmd + 上方向键/下方向键 | 跳到代码开头/结尾 |</p><p>| Control + Cmd + 方向键 | 在.h和.m间切换 |</p><p>| cmd + 0 | 打开或者取消左边的导航栏 |</p><p>| option + cmd 0 | 打开或者取消右边的属性视图 |</p><p>| Control + I | 重新缩进代码 |</p><p>| Control + Cmd + E | 统一修改变量名 |</p><p>| <code>Command + [</code> 或 <code>Command +  ]</code> | 左移/右移代码块 |</p><p>| <code>Option + Command + [</code> 或 <code>Option + Command + ]</code> | 上移/下移代码 |</p><p>| Command + Shift + 左/右方向键 | 选中当前行 |</p><p>| Control + D | 删除光标右边的字符，相当与 windows 下的 Delete |</p><p>| Command + Alt + ⬅️／➡️ | 折叠展开代码段 |</p><p>| Command + L | 跳转到指定行 |</p><p>| Command + option + / | 添加标准注释 |</p><p>大小写转换<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829224804.png" alt=""></p><h2 id="storyBoard-快捷键"><a href="#storyBoard-快捷键" class="headerlink" title="storyBoard 快捷键"></a>storyBoard 快捷键</h2><ol><li>Command + Shift + _ / | 在                 storyBoard 上添加辅助线</li><li>Command + Shift + 鼠标右键             选中某个 View</li><li>使用键盘移动控件</li></ol><p>第一步：使用鼠标选中某个控件<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829224821.png" alt=""><br>第二步：使用<code>方向键</code>进行移动，按住<code>shift键 + 方向键</code>可以更快的移动</p><ol start="4"><li>多个控件层叠时选择某个控件<br><code>鼠标右键+shift</code></li></ol><h2 id="模拟器快捷键"><a href="#模拟器快捷键" class="headerlink" title="模拟器快捷键"></a>模拟器快捷键</h2><ul><li><p><code>Cmd + shift + H</code>回到桌面</p></li><li><p>按住<code>Ctrl + Shift</code> 点击控件，显示这个点上的所有控件</p></li></ul><p>⌥代表option键</p><h1 id="Mac-快捷键"><a href="#Mac-快捷键" class="headerlink" title="Mac 快捷键"></a>Mac 快捷键</h1><ul><li><p>全屏截图：Command-Shift-3</p></li><li><p>指定区域截图：Command-Shift-4</p></li><li><p>显示隐藏快捷键：Command+Shift+.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Webstrom-IDEA-快捷键&quot;&gt;&lt;a href=&quot;#Webstrom-IDEA-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Webstrom/IDEA 快捷键&quot;&gt;&lt;/a&gt;Webstrom/IDEA 快捷键&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;cod
      
    
    </summary>
    
      <category term="工具" scheme="http://superkk.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>JS原型链与prototype</title>
    <link href="http://superkk.top/2018/05/21/JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Eprototype/"/>
    <id>http://superkk.top/2018/05/21/JS原型链与prototype/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:40:08.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包：函数-在函数创建时刻关联的父作用域的一个集合体"><a href="#闭包：函数-在函数创建时刻关联的父作用域的一个集合体" class="headerlink" title="闭包：函数+在函数创建时刻关联的父作用域的一个集合体"></a>闭包：<code>函数</code>+<code>在函数创建时刻关联的父作用域</code>的一个集合体</h1><p>闭包在JavaScript当中就是一个函数和在函数创建时刻关联的父作用域的一个集合体，通过这个集合体，一个函数就可以访问外部函数的变量了。<br>注意：是在函数创建时刻关联父作用域，而不是运行时刻关联。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223729.png" alt=""></p><p>当执行creatEatFunction的时候， eat函数才会被创建出来，此时eat函数就会把外部函数的作用域链记录下来（其中包含desc=’ is eating’)，以便执行时使用”<br>比如eat函数的作用域链是这样的。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223756.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223809.png" alt=""><br>输出1</p><h1 id="JS中继承的实现：JS中没有类的概念，如何实现继承"><a href="#JS中继承的实现：JS中没有类的概念，如何实现继承" class="headerlink" title="JS中继承的实现：JS中没有类的概念，如何实现继承"></a>JS中继承的实现：JS中没有类的概念，如何实现继承</h1><ul><li>1、通过<code>__proto__</code>实现继承：<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223828.png" alt=""><br><code>`</code>JavaScript<br>var animal = {<br>  name: ‘animal’,<br>  eat: function() {<pre><code>  console.log(this.name+&#39; is eating&#39;);</code></pre>  }<br>};</li></ul><p>var dog={<br>    name: ‘dog’,<br>    <strong>proto</strong>: animal<br>};</p><p>var cat={<br>    name: ‘cat’,<br>    <strong>proto</strong>: animal<br>};</p><p>dog.eat();<br>cat.eat();</p><pre><code>![](https://raw.githubusercontent.com/action456789/Image/master/20190829223846.png)- 2、语法糖：`new````JavaScriptfunction Student(name){    this.name=name,    this.sayHello=function(){        console.log(&quot;Hi, I am &quot;+this.name);    }}andy=new Student(&#39;andy&#39;);lisa=new Student(&#39;lisa&#39;);andy.sayHello();lisa.sayHello();</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223906.png" alt=""></p><ul><li>3、通过prototype实现继承，避免同一方法的多个副本。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223918.png" alt=""><br><code>`</code>JavaScript<br>// 通过prototype实现继承<br>Student.prototype={<br>  sayHello2:function(){<pre><code>  console.log(&quot;Hi, I am &quot;+this.name);</code></pre>  }<br>}</li></ul><p>andy=new Student(‘andy’);<br>lisa=new Student(‘lisa’);</p><p>andy.sayHello();<br>lisa.sayHello();</p><pre><code>![](https://raw.githubusercontent.com/action456789/Image/master/20190829223937.png)- 4、语法糖：`class````JavaScript// 语法糖class Student2{    constructor(name){        this.name=name;    }    sayHello() {        console.log(&quot;Hi, I am &quot;+this.name);    }}andy=new Student2(&#39;andy&#39;);andy.sayHello();</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223955.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闭包：函数-在函数创建时刻关联的父作用域的一个集合体&quot;&gt;&lt;a href=&quot;#闭包：函数-在函数创建时刻关联的父作用域的一个集合体&quot; class=&quot;headerlink&quot; title=&quot;闭包：函数+在函数创建时刻关联的父作用域的一个集合体&quot;&gt;&lt;/a&gt;闭包：&lt;code
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱工作·爱生活</title>
  
  <subtitle>action456789</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://superkk.top/"/>
  <updated>2019-08-29T09:07:04.749Z</updated>
  <id>http://superkk.top/</id>
  
  <author>
    <name>action456789</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组件化模块间通信方案</title>
    <link href="http://superkk.top/2018/08/22/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A8%A1%E5%9D%97%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://superkk.top/2018/08/22/组件化模块间通信方案/</id>
    <published>2018-08-21T17:12:20.000Z</published>
    <updated>2019-08-29T09:07:04.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件化模块间通信方案"><a href="#组件化模块间通信方案" class="headerlink" title="组件化模块间通信方案"></a>组件化模块间通信方案</h1><h3 id="1、公共模块下沉"><a href="#1、公共模块下沉" class="headerlink" title="1、公共模块下沉"></a>1、公共模块下沉</h3><p>比如一些公共的基础UI组件应该互相独立，并且可以下沉为一个单独的层（比如通用业务层），供其他业务模块调用。</p><h3 id="2、OpenURL统跳协议"><a href="#2、OpenURL统跳协议" class="headerlink" title="2、OpenURL统跳协议"></a>2、<code>OpenURL统跳协议</code></h3><p>用一个url表示一个页面（Controller），或者UI控件，或者任意一个类的对象。</p><p>需要创建一个字典，key是url，value是相应的对象，这个字典由路由类去管理，典型的方案就是<code>MGJRouter</code>。</p><ul><li><p>优点：能解决组件间的依赖，并且方案成熟，有很多知名公司都在用这种方案（蘑菇街）；</p></li><li><p>缺点：编译阶段无法发现潜在bug，并且需要去注册&amp;维护路由表。</p></li></ul><pre><code class="Objective-C">// 注册路由[[Router sharedInstance] registerURL:@&quot;myapp://good/detail&quot; with:^UIViewController *{     return [GoodDetailViewController new];}];// 通过url获取UIViewController *vc = [[Router sharedInstance] openURL:@&quot;myapp://good/detail&quot;]</code></pre><p><a href="https://www.jianshu.com/p/2af9c063fd85" target="_blank" rel="noopener">参考</a></p><h3 id="3、Target-Action-反射"><a href="#3、Target-Action-反射" class="headerlink" title="3、Target-Action(反射)"></a>3、<code>Target-Action</code>(反射)</h3><p>例如从A中push到BViewController，需要在AViewController类文件中import进BViewController，这样二者就会产生耦合<br>现在利用Target-Action机制，我们不再直接import进BViewController，而是利用<code>NSClassFromString(&lt;#NSString * _Nonnull aClassName#&gt;)</code>这个api将BViewController这个字符串反射成BViewController这个类，这样我们就可以根据反射后的类进行实例化，再调用实例化对象的各种方法。</p><ul><li>优点：相比于URL Router，Target-Action也不需要注册和内存占用。</li><li>缺点：编译阶段无法发现潜在的BUG，而且，开发者所创建的类和定义的方法必须要遵守Target-Action的命名规则，调用者可能会因为硬编码问题导致调用失败。</li></ul><p>第三方框架有<code>CTMediator</code>和<code>BeeHive</code>在github</p><h3 id="4、NSNotificationCenter"><a href="#4、NSNotificationCenter" class="headerlink" title="4、NSNotificationCenter"></a>4、<code>NSNotificationCenter</code></h3><ul><li>优点：简单直接。</li><li>缺点：遍地都是通知，如果同事间协调不好会使得代码很混乱。</li></ul><h3 id="5、依赖注入：推荐方法"><a href="#5、依赖注入：推荐方法" class="headerlink" title="5、依赖注入：推荐方法"></a>5、<code>依赖注入</code>：推荐方法</h3><p>比如业务C将自己注入中间层，业务A去中间层去获取依赖的方法和变量。</p><ul><li>实现方式：通过中间层协议实现<br>业务B遵从这个协议，实现协议的代理方法，返回与中间层商量好的一个实际对象。<br>业务A通过中间层的某个方法（与B商量），获取遵从了这个协议的实例B，将其当做一个遵从了这个协议的透明对象来使用。</li><li><p>编程实现：具体运用了java的<code>面向接口编程`</code>Protocol - Class<code>，即iOS的</code>面向协议编程`</p></li><li><p>优点：<br>1、接口类似代码，可以非常灵活的定义函数和回调等。</p></li><li><p>缺点：<br>1、接口定义文件需要放在一个模块以供依赖，但是这个模块不会贡献代码，所以还好。<br>2、使用较为麻烦，每各调用都需要定义一个service，并实现, 对于一些具有普适性规律的场景不太合适，比如页面统一跳转</p></li><li><p>面向接口的调用会产生依赖<br><code>`</code>Objective-C<br>// A 模块</p></li><li>(void)getSomeDataFromB {<br>  B.getSomeData();<br>}</li></ul><p>// B 模块</p><ul><li>(void)getSomeData {<br>  return self.data;<br>}<br><code>`</code></li></ul><ul><li>示例<br><code>ServiceBProtocol</code><pre><code class="Swift">protocol ServiceBProtocol {  func getSomeDataFromServiceB() -&gt; String;}</code></pre></li></ul><p><code>MiddleLayer</code></p><pre><code class="Swift">class MiddleLayer: NSObject {    class func findServiceB() -&gt; ServiceBProtocol {        return ServiceB()    }}</code></pre><p><code>ServiceB</code></p><pre><code class="Swift">// 模块Bclass ServiceB: NSObject {    let serviceB_Data = &quot;ServiceB&quot;}extension ServiceB: ServiceBProtocol {    func getSomeDataFromServiceB() -&gt; String {        return self.serviceB_Data    }}</code></pre><p><code>ServiceA</code></p><pre><code class="Swift">// 模块Aclass ServiceA: NSObject {    func getDataFromB() {        print(MiddleLayer.findServiceB().getSomeDataFromServiceB())    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组件化模块间通信方案&quot;&gt;&lt;a href=&quot;#组件化模块间通信方案&quot; class=&quot;headerlink&quot; title=&quot;组件化模块间通信方案&quot;&gt;&lt;/a&gt;组件化模块间通信方案&lt;/h1&gt;&lt;h3 id=&quot;1、公共模块下沉&quot;&gt;&lt;a href=&quot;#1、公共模块下沉&quot; cla
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="高级" scheme="http://superkk.top/categories/iOS/%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa冷热信号详解</title>
    <link href="http://superkk.top/2018/07/30/ReactiveCocoa%E5%86%B7%E7%83%AD%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://superkk.top/2018/07/30/ReactiveCocoa冷热信号详解/</id>
    <published>2018-07-30T12:08:40.000Z</published>
    <updated>2019-08-29T09:07:04.741Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>函数响应式编程(Functional Reactive Programming:FRP)，ReactiveCocoa 版本 2.5</p><h1 id="冷热信号"><a href="#冷热信号" class="headerlink" title="冷热信号"></a>冷热信号</h1><ul><li><p>冷信号<br>只有当你订阅的时候，它才会发布消息，<br>一对一，当有不同的订阅者，消息是重新完整发送。</p></li><li><p>热信号<br>尽管你并没有订阅事件，但是它会时刻推送，类似“直播”，错过了就不再处理。<br>可以有多个订阅者，是一对多</p></li></ul><h1 id="RACSignal-与RACSubject-的区别"><a href="#RACSignal-与RACSubject-的区别" class="headerlink" title="RACSignal 与RACSubject 的区别"></a><code>RACSignal</code> 与<code>RACSubject</code> 的区别</h1><ul><li><code>RACSignal</code>是冷信号</li><li><code>RACSubject</code>是热信号</li></ul><p>如下图</p><ul><li><code>signal</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-cba016d495b9a1b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><code>subject</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5974af889c88a7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><code>replaySubject</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1120923-282c50256b5bae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>Subject可以附加行为，例如<code>RACReplaySubject</code>具备为未来订阅者缓冲事件的能力。（这一点与冷信号类似，即使是在数据发送之后才订阅的，依然会收到全部消息）</p></blockquote><h1 id="冷信号示例：延时订阅，依然能收到所有信号数据"><a href="#冷信号示例：延时订阅，依然能收到所有信号数据" class="headerlink" title="冷信号示例：延时订阅，依然能收到所有信号数据"></a>冷信号示例：延时订阅，依然能收到所有信号数据</h1><pre><code>- (void)test1 {    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [subscriber sendNext:@1];        [subscriber sendNext:@2];        [subscriber sendNext:@3];        [subscriber sendCompleted];        return nil;    }];    NSLog(@&quot;Signal was created.&quot;);    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber1 recveive: %@&quot;, x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{        [signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber2 recveive: %@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-419d5730a235a595.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="热信号示例：错过了订阅时机，就收不到信号数据，类似于直播"><a href="#热信号示例：错过了订阅时机，就收不到信号数据，类似于直播" class="headerlink" title="热信号示例：错过了订阅时机，就收不到信号数据，类似于直播"></a>热信号示例：错过了订阅时机，就收不到信号数据，类似于直播</h1><blockquote><p>冷信号会收到全部的数据，即使是在数据发送之后才订阅的</p></blockquote><pre><code>- (void)test2 {    RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{            [subscriber sendNext:@1];        }];        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{            [subscriber sendNext:@2];        }];        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{            [subscriber sendNext:@3];            [subscriber sendCompleted];        }];        return nil;    }] publish];    [connection connect];    NSLog(@&quot;Signal was created.&quot;);    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{        [connection.signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber1 recveive: %@&quot;, x);        }];    }];    [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{        [connection.signal subscribeNext:^(id x) {            NSLog(@&quot;Subscriber2 recveive: %@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5e7083e9f1760611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="SideEffect示例：多次订阅导致信号block多次执行"><a href="#SideEffect示例：多次订阅导致信号block多次执行" class="headerlink" title="SideEffect示例：多次订阅导致信号block多次执行"></a>SideEffect示例：多次订阅导致信号block多次执行</h1><pre><code>- (void)test3 {    // 多次订阅会多次执行    RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];        }];        return nil;    }];    // 【请求数据次数 +1】    [requestSignal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1&quot;);    }];    // 【请求数据次数 +1】    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2&quot;);    }];    // 将信号转换为内容为2的信号    RACSignal *signal1 = [requestSignal flattenMap:^RACStream *(id value) {        return [RACSignal return:@&quot;2&quot;];    }];    // 将signal1信号所有错误信息转换为字符串@&quot;Error&quot;    [signal1 catchTo:[RACSignal return:@&quot;Error&quot;]];    // 在没有获取值之前以字符串@&quot;Loading...&quot;占位    [signal1 startWith:@&quot;Loading...&quot;];    // 将信号进行绑定    // 【请求数据次数 +1】    RAC(self.acountField, text) = signal1;    // 订阅多个信号的任何错误，并且弹出UIAlertView    // 【请求数据次数 +2】    [[RACSignal merge:@[requestSignal, signal1]] subscribeError:^(NSError *error) {        NSLog(@&quot;发生错误&quot;);    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-465cde44e32e9612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="解决方式一：使用-RACMulticastConnection把冷信号转化为热信号"><a href="#解决方式一：使用-RACMulticastConnection把冷信号转化为热信号" class="headerlink" title="解决方式一：使用 RACMulticastConnection把冷信号转化为热信号"></a>解决方式一：使用 <code>RACMulticastConnection</code>把冷信号转化为热信号</h2><pre><code>- (void)test4 {    RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];            [subscriber sendCompleted];        }];        return nil;    }];    RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]];//    RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]];    [connection connect];    [connection.signal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [connection.signal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [connection.signal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><h3 id="使用RACSubject时"><a href="#使用RACSubject时" class="headerlink" title="使用RACSubject时"></a>使用<code>RACSubject</code>时</h3><pre><code>RACMulticastConnection *connection = [requestSignal multicast:[RACSubject subject]];</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-85b4314b53586f26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="使用RACReplaySubject时"><a href="#使用RACReplaySubject时" class="headerlink" title="使用RACReplaySubject时"></a>使用<code>RACReplaySubject</code>时</h3><pre><code>RACMulticastConnection *connection = [requestSignal multicast:[RACReplaySubject subject]];</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-4ae4c9e7dbfebe09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="解决方式二：使用-replayLazily把冷信号转化为热信号"><a href="#解决方式二：使用-replayLazily把冷信号转化为热信号" class="headerlink" title="解决方式二：使用 replayLazily把冷信号转化为热信号"></a>解决方式二：使用 <code>replayLazily</code>把冷信号转化为热信号</h2><pre><code>- (void)test5 {    RACSignal *requestSignal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        NSLog(@&quot;开始请求网络数据&quot;);        [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{            [subscriber sendNext:@&quot;1&quot;];            [subscriber sendCompleted];        }];        return nil;    }] replayLazily]; // modify here!!    [requestSignal subscribeNext:^(id x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [requestSignal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-437a9f7928924eaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="使用RACCommand把冷信号转化为热信号"><a href="#使用RACCommand把冷信号转化为热信号" class="headerlink" title="使用RACCommand把冷信号转化为热信号"></a>使用<code>RACCommand</code>把冷信号转化为热信号</h2><pre><code>- (void)test6 {    RACCommand *requestCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {        return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {            NSLog(@&quot;开始请求网络数据&quot;);            [RACScheduler.mainThreadScheduler afterDelay:1 schedule:^{                [subscriber sendNext:@&quot;1&quot;];                [subscriber sendCompleted];            }];            return nil;        }];    }];    RACSignal *requestSignal = [requestCommand execute:nil];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者1:%@&quot;, x);    }];    [requestSignal subscribeNext:^(NSArray *x) {        NSLog(@&quot;订阅者2:%@&quot;, x);    }];    [RACScheduler.mainThreadScheduler afterDelay:2 schedule:^{        [requestSignal subscribeNext:^(NSArray *x) {            NSLog(@&quot;订阅者3:%@&quot;, x);        }];    }];}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-e1f4373d8b49a171.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>RACMulticastConnection</code>与<code>RACSubject</code>结合使用时是直播的热信号</p><p><code>RACCommand</code>、<code>replayLazily</code>、<code>RACReplaySubject</code>都是类似于冷信号的情况，不管何时订阅，都会收到所有数据</p><h1 id="ReactiveCocoa中潜在的内存泄漏与解决方案"><a href="#ReactiveCocoa中潜在的内存泄漏与解决方案" class="headerlink" title="ReactiveCocoa中潜在的内存泄漏与解决方案"></a>ReactiveCocoa中潜在的内存泄漏与解决方案</h1><ul><li><p><code>RACObserve</code>中潜在使用了self，要注意循环引用</p></li><li><p><code>RACSubject</code>中如果没有调用<code>sendCompleted</code>，调用map等操作将造成内存泄漏（循环引用）。RACSignal不会有这个问题</p></li></ul><p>代码参见<a href="http://fromwiz.com/share/s/3rEj7C20FAXK2jIwRi1uhc1v0WQKj83L7k142p7dil0ygtoZ" target="_blank" rel="noopener">https://github.com/action456789/ReactiveCocoaDemo</a></p><p>参考：<a href="http://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="noopener">http://tech.meituan.com/tag/ReactiveCocoa</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;函数响应式编程(Functional Reactive Programming:FRP)，ReactiveCoco
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="Rx &amp; RAC" scheme="http://superkk.top/categories/iOS/Rx-RAC/"/>
    
    
  </entry>
  
  <entry>
    <title>UITableView的`beginUpdates`与`endUpdates`用法详解</title>
    <link href="http://superkk.top/2018/06/05/UITableView%E7%9A%84%60beginUpdates%60%E4%B8%8E%60endUpdates%60%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://superkk.top/2018/06/05/UITableView的`beginUpdates`与`endUpdates`用法详解/</id>
    <published>2018-06-04T18:05:12.000Z</published>
    <updated>2019-08-29T09:07:04.720Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="UITaUITableView的beginUpdates和endUpdates"><a href="#UITaUITableView的beginUpdates和endUpdates" class="headerlink" title="UITaUITableView的beginUpdates和endUpdates"></a>UITaUITableView的<code>beginUpdates</code>和<code>endUpdates</code></h1><ol><li>这个方法用于在调用插入，删除，选择方法时，同时有动画效果。 </li><li>用endUpdate能动画改变行高(触发<code>heightForRowAtIndexPath</code>回调)，而无需relaod这个cell。</li></ol><h2 id="使用场景一：点击cell，cell的高度就变高"><a href="#使用场景一：点击cell，cell的高度就变高" class="headerlink" title="使用场景一：点击cell，cell的高度就变高"></a>使用场景一：点击cell，cell的高度就变高</h2><p>Cell点击方法执行</p><pre><code class="Objective-C">  [tableView beginUpdates];  [tableView endUpdates];</code></pre><p>这两句代码中间没有任何其他部分，但是会触发<code>heightForRowAtIndexPath</code>回调，从而修改cell的高度</p><h2 id="使用场景二：有一个-TableView，现在我希望每按一次-update-按钮，就动态地在下方加两行。"><a href="#使用场景二：有一个-TableView，现在我希望每按一次-update-按钮，就动态地在下方加两行。" class="headerlink" title="使用场景二：有一个 TableView，现在我希望每按一次 update 按钮，就动态地在下方加两行。"></a>使用场景二：有一个 TableView，现在我希望每按一次 update 按钮，就动态地在下方加两行。</h2><ul><li>方法一：简单粗暴的做法 ，更改数据源，然后刷新一下列表</li></ul><pre><code class="Objective-C">// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;] @IBAction func update(_ sender: AnyObject) {     tableData.append(&quot;\(tableData.count)&quot;)     tableData.append(&quot;\(tableData.count)&quot;)     tableView.reloadData() }</code></pre><ul><li>方法二</li></ul><pre><code class="Objective-C">// tableData = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]@IBAction func update(_ sender: AnyObject) {    tableData.append(&quot;\(tableData.count)&quot;)    tableData.append(&quot;\(tableData.count)&quot;)    tableView.beginUpdates()    let indexPaths = [IndexPath(row: tableData.count-2, section: 0), IndexPath(row: tableData.count-1, section: 0)]    tableView.insertRows(at: indexPaths, with: UITableViewRowAnimation.automatic)    tableView.endUpdates()}</code></pre><p>这里 beginUpdates 和 endUpdates 方法的作用是，将这两条语句之间的对 tableView 的 insert/delete 操作聚合起来，然后同时更新 UI。</p><h1 id="动态改变tableHeaderView高度"><a href="#动态改变tableHeaderView高度" class="headerlink" title="动态改变tableHeaderView高度"></a>动态改变<code>tableHeaderView</code>高度</h1><p>view 作为 tableView 的 tableHeaderView，单纯的改变 view 的 frame 是无济于事的，tableView 不会时刻适应它的高度，</p><p>所以，如何告诉tableView 它的 tableHeaderView 已经改变了？</p><pre><code class="Objective-C">headerView.frame = newFrame;[self.tableView setTableHeaderView:headerView];</code></pre><p>或者</p><pre><code class="Objective-C">[self.tableView beginUpdates];[self.tableView setTableHeaderView:headerView];[self.tableView endUpdates];</code></pre><h2 id="如何检测动画在UITableView-beginUpdates-endUpdates上结束"><a href="#如何检测动画在UITableView-beginUpdates-endUpdates上结束" class="headerlink" title="如何检测动画在UITableView beginUpdates / endUpdates上结束"></a>如何检测动画在UITableView beginUpdates / endUpdates上结束</h2><pre><code class="Objective-C">[CATransaction begin];[CATransaction setCompletionBlock:^{    // animation has finished}];[tableView beginUpdates];// do some work[tableView endUpdates];[CATransaction commit];</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;UITaUITableView的beginUpdates和endUpdates&quot;&gt;&lt;a href=&quot;#UITaUITableView的beginUpdates和endUpdates&quot; class=&quot;headerlink&quot; title=&quot;U
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>JS原型链与prototype</title>
    <link href="http://superkk.top/2018/05/21/JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Eprototype/"/>
    <id>http://superkk.top/2018/05/21/JS原型链与prototype/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:40:08.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包：函数-在函数创建时刻关联的父作用域的一个集合体"><a href="#闭包：函数-在函数创建时刻关联的父作用域的一个集合体" class="headerlink" title="闭包：函数+在函数创建时刻关联的父作用域的一个集合体"></a>闭包：<code>函数</code>+<code>在函数创建时刻关联的父作用域</code>的一个集合体</h1><p>闭包在JavaScript当中就是一个函数和在函数创建时刻关联的父作用域的一个集合体，通过这个集合体，一个函数就可以访问外部函数的变量了。<br>注意：是在函数创建时刻关联父作用域，而不是运行时刻关联。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223729.png" alt=""></p><p>当执行creatEatFunction的时候， eat函数才会被创建出来，此时eat函数就会把外部函数的作用域链记录下来（其中包含desc=’ is eating’)，以便执行时使用”<br>比如eat函数的作用域链是这样的。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223756.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223809.png" alt=""><br>输出1</p><h1 id="JS中继承的实现：JS中没有类的概念，如何实现继承"><a href="#JS中继承的实现：JS中没有类的概念，如何实现继承" class="headerlink" title="JS中继承的实现：JS中没有类的概念，如何实现继承"></a>JS中继承的实现：JS中没有类的概念，如何实现继承</h1><ul><li>1、通过<code>__proto__</code>实现继承：<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223828.png" alt=""><br><code>`</code>JavaScript<br>var animal = {<br>  name: ‘animal’,<br>  eat: function() {<pre><code>  console.log(this.name+&#39; is eating&#39;);</code></pre>  }<br>};</li></ul><p>var dog={<br>    name: ‘dog’,<br>    <strong>proto</strong>: animal<br>};</p><p>var cat={<br>    name: ‘cat’,<br>    <strong>proto</strong>: animal<br>};</p><p>dog.eat();<br>cat.eat();</p><pre><code>![](https://raw.githubusercontent.com/action456789/Image/master/20190829223846.png)- 2、语法糖：`new````JavaScriptfunction Student(name){    this.name=name,    this.sayHello=function(){        console.log(&quot;Hi, I am &quot;+this.name);    }}andy=new Student(&#39;andy&#39;);lisa=new Student(&#39;lisa&#39;);andy.sayHello();lisa.sayHello();</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223906.png" alt=""></p><ul><li>3、通过prototype实现继承，避免同一方法的多个副本。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223918.png" alt=""><br><code>`</code>JavaScript<br>// 通过prototype实现继承<br>Student.prototype={<br>  sayHello2:function(){<pre><code>  console.log(&quot;Hi, I am &quot;+this.name);</code></pre>  }<br>}</li></ul><p>andy=new Student(‘andy’);<br>lisa=new Student(‘lisa’);</p><p>andy.sayHello();<br>lisa.sayHello();</p><pre><code>![](https://raw.githubusercontent.com/action456789/Image/master/20190829223937.png)- 4、语法糖：`class````JavaScript// 语法糖class Student2{    constructor(name){        this.name=name;    }    sayHello() {        console.log(&quot;Hi, I am &quot;+this.name);    }}andy=new Student2(&#39;andy&#39;);andy.sayHello();</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829223955.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闭包：函数-在函数创建时刻关联的父作用域的一个集合体&quot;&gt;&lt;a href=&quot;#闭包：函数-在函数创建时刻关联的父作用域的一个集合体&quot; class=&quot;headerlink&quot; title=&quot;闭包：函数+在函数创建时刻关联的父作用域的一个集合体&quot;&gt;&lt;/a&gt;闭包：&lt;code
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Native数据传递</title>
    <link href="http://superkk.top/2018/05/21/React-Native%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>http://superkk.top/2018/05/21/React-Native数据传递/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T13:16:29.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过react-navigation传递数据"><a href="#通过react-navigation传递数据" class="headerlink" title="通过react-navigation传递数据"></a>通过react-navigation传递数据</h1><h2 id="顺传"><a href="#顺传" class="headerlink" title="顺传"></a>顺传</h2><p>传递数据</p><pre><code>_onItemPress = (item) =&gt; {    NavigationService.navigate(&quot;VehicleMonitorCarInfoPage&quot;, {        data: item    });};</code></pre><p>获取数据</p><pre><code>componentDidMount() {    // 或者使用 this.props.navigation.getParam(&#39;data&#39;)    let data = this.props.navigation.state.params.data;}</code></pre><h2 id="逆传"><a href="#逆传" class="headerlink" title="逆传"></a>逆传</h2><p>传递数据</p><pre><code>_callback = (message) =&gt; {    console.log(message);}_onItemPress = (item) =&gt; {    NavigationService.navigate(&quot;VehicleMonitorCarInfoPage&quot;, {        callback: this._callback    });};</code></pre><p>子组件获取回调并执行</p><pre><code>render() {    return (        &lt;View style={styles.container}&gt;            &lt;Button                title={&#39;点击测试&#39;}                onPress={() =&gt; this.props.navigation.state.params.callback(&#39;hello world&#39;) }&gt;            &lt;/Button&gt;        &lt;/View&gt;    );}</code></pre><h1 id="通过组件传递数据"><a href="#通过组件传递数据" class="headerlink" title="通过组件传递数据"></a>通过组件传递数据</h1><h2 id="顺传-1"><a href="#顺传-1" class="headerlink" title="顺传"></a>顺传</h2><p>传递数据</p><pre><code>_renderItem = ({item, index}) =&gt; {    return (&lt;View&gt;        &lt;MsgCard msg={item} index={index} allMsgPageType={this.state.msgType} navigation={this.props.navigation}/&gt;    &lt;/View&gt;)};</code></pre><p>子组件获取数据</p><pre><code>export default class MsgCard extends Component&lt;Props&gt; {    constructor(props) {        super(props);        this.state = {            msg: this.props.msg,            index: this.props.index,            allMsgPageType: this.props.allMsgPageType,        }    }    //父组件更新数据，子组件不刷新时使用    componentWillReceiveProps(nextProps) {        this.setState({            msg: nextProps.msg,            index: nextProps.index,            allMsgPageType: nextProps.allMsgPageType,        });    }}</code></pre><h2 id="逆传-1"><a href="#逆传-1" class="headerlink" title="逆传"></a>逆传</h2><p>组件A<br>传递callback</p><pre><code>_callback = (message) =&gt; {    console.log(message);}render() {    return (    &lt;View&gt;        &lt;MyListItem callback={this._callback}&gt;&lt;/MyListItem&gt;    &lt;/View&gt;)};</code></pre><p>组件B<br>子组件获取传递过来的callback并执行</p><pre><code>class MyListItem extends React.PureComponent {    _onPress = () =&gt; {        this.props.callback(&#39;hello world&#39;)    };    render() {        return (            &lt;View style={styles.flatListItem} &gt;                &lt;Button                    title={&quot;点击测试&quot;}                    onPress={this._onPress}                &gt;                &lt;/Button&gt;            &lt;/View&gt;        );    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过react-navigation传递数据&quot;&gt;&lt;a href=&quot;#通过react-navigation传递数据&quot; class=&quot;headerlink&quot; title=&quot;通过react-navigation传递数据&quot;&gt;&lt;/a&gt;通过react-navigation传递
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>TextInput</title>
    <link href="http://superkk.top/2018/05/21/TextInput/"/>
    <id>http://superkk.top/2018/05/21/TextInput/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T13:11:48.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用属性-Android-amp-iOS"><a href="#通用属性-Android-amp-iOS" class="headerlink" title="通用属性(Android &amp; iOS)"></a>通用属性(Android &amp; iOS)</h1><ul><li>(1)支持View的相关属性</li><li><p>(2)<code>autoCapitalize</code>:控制输入的字符进行切换成大写(参数:’none’,’sentences’,’words’,’characters’)<br><code>none</code>: 不自动切换任何字符大写<br><code>sentences</code>: 默认每个句子的首字母大写<br><code>words</code>:每个单词的首字母变成大写<br><code>characters</code>:每个字母全部变成大写</p></li><li><p>(3)<code>autoCorrect(bool)</code>:设置瓶邪自动修正功能,默认开启(true)</p></li><li><p>(4)<code>autoFocus(bool)</code>:设置是否默认获取到焦点,默认为关闭(false).需要comonentDidMount方法调用之后才会获取焦点(componentDidMount是React组件被渲染之后React主动回调的方法)</p></li><li><p>(5)<code>defaultValue(string)</code>:给文本框输入一个默认初始值.</p></li><li><p>(6)<code>editable(bool)</code>:设置文本框是否可以编辑,默认为true,可以进行编辑</p></li><li><p>(7)<code>keyboardType</code>:<br>键盘类型(可选参数:”default”, ‘email-address’, ‘numeric’, ‘phone-pad’, “ascii-capable”, ‘numbers-and-punctuation’, ‘url’, ‘number-pad’, ‘name-phone-pad’, ‘decimal-pad’, ‘twitter’, ‘web-search’) 该用来选择默认弹出键盘的类型例如我们甚至numeric就是弹出数字键盘。鉴于平台的原因如下的值是所有平台都可以进行通用的</p></li><li><p>(8)<code>maxLength(number)</code>:可以限制文本输入框最大的输入字符长度</p></li><li><p>(9)<code>multiline (bool)</code> : 设置可以输入多行文字，默认为false(表示无论文本输入多少，都是单行显示)</p></li><li>(10)<code>onBlur (function)</code>: 监听方法，文本框失去焦点回调方法</li><li>(11)<code>onChange (function)</code>: 监听方法,文本框内容发生改变回调方法</li><li>(12)<code>onChangeText (function)</code>:监听方法，文本框内容发生改变回调方法，该方法会进行传递文本内容</li><li>(13)<code>onEndEditing (function)</code>:监听方法，当文本结束文本输入回调方法</li><li>(14)<code>onFocus (function)</code> :监听方法 文本框获取到焦点回调方法</li><li>(15)<code>onLayout (function)</code>:监听方法 组价布局发生变化的时候调用，调用方法参数为 {x,y,width,height}</li><li>(16)<code>onSubmitEditing (function)</code>:监听方法，当编辑提交的时候回调方法。不过如果multiline={true}的时候，该属性就不生效</li><li>(17)<code>placeholder (string</code>) :当文本输入框还没有任何输入的时候，默认显示信息，当有输入的时候该值会被清除</li><li>(18)<code>placeholderText Color (string)</code>: 设置默认信息颜色(placeholer)</li><li>(19)<code>secureTextEntry (bool)</code>: 设置是否为密码安全输入框 ，默认为false</li><li>(20)<code>style</code> 风格属性 可以参考Text组件风格</li><li>(21)<code>value ( string )</code>:输入框中的内容值</li><li>(22)<code>returnKeyType</code>:决定“确定”按钮显示的内容。<br>done<br>go<br>next<br>search<br>send</li></ul><h1 id="Android-平台属性"><a href="#Android-平台属性" class="headerlink" title="Android 平台属性"></a>Android 平台属性</h1><ul><li>(22)<code>numberOfLines (number)</code>:设置文本输入框行数，该需要首先设置multiline为true,设置TextInput为多行文本。</li><li>(23)<code>textAlign</code> 设置文本横向布局方式 可选参数(‘start’, ‘center’, ‘end’)</li><li>(24)<code>textAlignVertical</code>: 设置文本垂直方向布局方式 可选参数(‘top’, ‘center’, ‘bottom’)</li><li>(25)<code>underlineColorAndroid</code>: 设置文本输入框下划线的颜色</li></ul><h1 id="长按出现菜单键为英文，如何改为中文"><a href="#长按出现菜单键为英文，如何改为中文" class="headerlink" title="长按出现菜单键为英文，如何改为中文"></a>长按出现菜单键为英文，如何改为中文</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829210921.png" alt=""><br>在Xcode中，TARGETS—你的项目名—info，选择Localization native development region，选择China，这样文字都会变成中文啦，包括时间选择器等也会变成中文。<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829210959.png" alt=""></p><h1 id="键盘处理"><a href="#键盘处理" class="headerlink" title="键盘处理"></a>键盘处理</h1><p><a href="https://facebook.github.io/react-native/docs/inputaccessoryview#docsNav" target="_blank" rel="noopener">参考</a><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211043.png" alt=""></p><pre><code class="javascript">    const inputAccessoryViewID = &quot;inputAccessoryViewID&quot;;    _renderLeaveWordInput() {         return &lt;View style={{height: 60}}&gt;                &lt;TextInput style={{                    fontSize: 13,                    textAlignVertical: 'top',                    autoCapitalize: 'none',                    autoCorrect: false                 }}                   multiline={true}                   maxLength={50}                   onChangeText={this._onInputCommentsChange}                   value={this.state.comments}                   inputAccessoryViewID={inputAccessoryViewID}                   ref={&#39;LeaveWordTextInput&#39;}                   placeholder={&#39;请输入留言&#39;}/&gt;                &lt;InputAccessoryView nativeID={inputAccessoryViewID}&gt;                    &lt;View style={{flexDirection:'row-reverse'}}&gt;                        &lt;Button onPress={() =&gt; {this.refs.LeaveWordTextInput.blur();}}                                title=&quot;完成&quot;                                color=&quot;red&quot;                        /&gt;                    &lt;/View&gt;                &lt;/InputAccessoryView&gt;            &lt;/View&gt;    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通用属性-Android-amp-iOS&quot;&gt;&lt;a href=&quot;#通用属性-Android-amp-iOS&quot; class=&quot;headerlink&quot; title=&quot;通用属性(Android &amp;amp; iOS)&quot;&gt;&lt;/a&gt;通用属性(Android &amp;amp; iOS)
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Native模版</title>
    <link href="http://superkk.top/2018/05/21/React-Native%E6%A8%A1%E7%89%88/"/>
    <id>http://superkk.top/2018/05/21/React-Native模版/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:37:06.699Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中的this绑定</title>
    <link href="http://superkk.top/2018/05/21/JS%E4%B8%AD%E7%9A%84this%E7%BB%91%E5%AE%9A/"/>
    <id>http://superkk.top/2018/05/21/JS中的this绑定/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:37:06.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-中传递闭包会导致this指向丢失"><a href="#React-中传递闭包会导致this指向丢失" class="headerlink" title="React 中传递闭包会导致this指向丢失"></a>React 中传递闭包会导致this指向丢失</h1><pre><code class="JavaScript">// JS中传递闭包会导致this指向丢失tmp:&#39;No!&#39;;let obj = {    tmp:&#39;Yes!&#39;,    testLog:function(){        console.log(this.tmp);    }};obj.testLog();let tmpLog = obj.testLog;tmpLog();</code></pre><p>注意到现在没有直接调用obj对象中的testLog方法，而是使用了一个中间变量tmpLog过渡，当使用括号()调用该方法时，方法中的this丢失了指向，会指向window（或者react中的global），进而window.tmp未定义就是undefined：</p><p>React在事件发生时调用onClick，由于onClick只是中间变量，所以处理函数中的this指向会丢失，为了解决这个问题，我们需要在实例化对象的时候，需要在构造函数中绑定this，使得无论事件处理函数如何传递，它的this的指向都是固定的，固定指向我们所实例化的对象。</p><h1 id="JavaScript中this传递规则"><a href="#JavaScript中this传递规则" class="headerlink" title="JavaScript中this传递规则"></a>JavaScript中this传递规则</h1><h3 id="1、默认绑定，直接使用不带任何修饰的函数，this会指向全局环境。"><a href="#1、默认绑定，直接使用不带任何修饰的函数，this会指向全局环境。" class="headerlink" title="1、默认绑定，直接使用不带任何修饰的函数，this会指向全局环境。"></a>1、默认绑定，直接使用不带任何修饰的函数，this会指向全局环境。</h3><pre><code class="JavaScript">function foo1() {    this.count = 100;}foo1() //直接使用，函数未经修饰console.log(global.count) //输出全局环境中的count变量，就是函数中的this.count，结果为100</code></pre><h3 id="2、隐式绑定，当所调用的函数是某个对象的成员函数时，函数中的this会指向函数所在的对象。"><a href="#2、隐式绑定，当所调用的函数是某个对象的成员函数时，函数中的this会指向函数所在的对象。" class="headerlink" title="2、隐式绑定，当所调用的函数是某个对象的成员函数时，函数中的this会指向函数所在的对象。"></a>2、隐式绑定，当所调用的函数是某个对象的成员函数时，函数中的this会指向函数所在的对象。</h3><pre><code class="JavaScript">function foo() {    console.log(this.count);}let obj = {    count:1000,    foo:foo};obj.foo(); //输出100</code></pre><p>隐式绑定可能会存在绑定丢失的场景，当函数作为参数传入到另外一个函数时，作为参数的函数所绑定的this会失效。</p><pre><code class="js">function foo(){    console.log(this.count);}function bar (func){    func();}let count = 0;let obj = {    count : 100,    foo : foo};bar(obj.foo); //会输出undefined</code></pre><h3 id="3、显式绑定，使用call-、apply-、bind-函数可以显式强制的绑定函数的this"><a href="#3、显式绑定，使用call-、apply-、bind-函数可以显式强制的绑定函数的this" class="headerlink" title="3、显式绑定，使用call()、apply()、bind()函数可以显式强制的绑定函数的this"></a>3、显式绑定，使用call()、apply()、bind()函数可以显式强制的绑定函数的this</h3><pre><code class="JavaScript">function foo (){    console.log(this.count);}let count = &#39;window!&#39;;let obj1 = {    count : 100,    foo : foo};let obj2 = {    count : 200,    foo : foo};foo.call(obj1); //输出100foo.call(obj2); //输出200</code></pre><h3 id="4、new-绑定，使用new操作符，可以将函数的this指向新创建的对象。"><a href="#4、new-绑定，使用new操作符，可以将函数的this指向新创建的对象。" class="headerlink" title="4、new 绑定，使用new操作符，可以将函数的this指向新创建的对象。"></a>4、new 绑定，使用new操作符，可以将函数的this指向新创建的对象。</h3><pre><code class="JavaScript">function Foo(name, age){    this.name = name;    this.age = age; } var obj = new Foo(&#39;Tom&#39;,99);console.log(obj);</code></pre><h1 id="绑定规则的优先级"><a href="#绑定规则的优先级" class="headerlink" title="绑定规则的优先级"></a>绑定规则的优先级</h1><p>new绑定 &gt; 显示绑定 &gt;隐式绑定 &gt; 默认绑定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-中传递闭包会导致this指向丢失&quot;&gt;&lt;a href=&quot;#React-中传递闭包会导致this指向丢失&quot; class=&quot;headerlink&quot; title=&quot;React 中传递闭包会导致this指向丢失&quot;&gt;&lt;/a&gt;React 中传递闭包会导致this指向
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中的Promise, async, await</title>
    <link href="http://superkk.top/2018/05/21/JS%E4%B8%AD%E7%9A%84Promise,%20async,%20await/"/>
    <id>http://superkk.top/2018/05/21/JS中的Promise, async, await/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:32:12.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备代码"><a href="#准备代码" class="headerlink" title="准备代码"></a>准备代码</h2><pre><code class="JS">//做饭function cook() {    console.log(&#39;开始做饭。&#39;);    var p = new Promise(function (resolve, reject) { //做一些异步操作        setTimeout(function () {            resolve(&#39;鸡蛋炒饭&#39;);            // reject(&#39;烧焦的米饭&#39;);        }, 1000);    });    return p;}//吃饭function eat(data) {    console.log(&#39;开始吃饭：&#39; + data);    var p = new Promise(function (resolve, reject) { //做一些异步操作        setTimeout(function () {            resolve(&#39;一块碗和一双筷子&#39;);        }, 2000);    });    return p;}function wash(data) {    console.log(&#39;开始洗碗：&#39; + data);    var p = new Promise(function (resolve, reject) { //做一些异步操作        setTimeout(function () {            resolve(&#39;干净的碗筷&#39;);        }, 2000);    });    return p;}</code></pre><pre><code class="JS">//切菜function cutUp() {    var p = new Promise(function (resolve, reject) { //做一些异步操作        setTimeout(function () {            resolve(&#39;切好的菜&#39;);        }, 1000);    });    return p;}//烧水function boil() {    var p = new Promise(function (resolve, reject) { //做一些异步操作        setTimeout(function () {            resolve(&#39;烧好的水&#39;);        }, 2000);    });    return p;}</code></pre><h2 id="async-await：解决Promise只是减少了嵌套，并不能完全消除嵌套的问题"><a href="#async-await：解决Promise只是减少了嵌套，并不能完全消除嵌套的问题" class="headerlink" title="async/await：解决Promise只是减少了嵌套，并不能完全消除嵌套的问题"></a>async/await：解决Promise只是减少了嵌套，并不能完全消除嵌套的问题</h2><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul><li>当调用一个 async 函数时，会返回一个 Promise 对象</li><li>当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；</li><li>当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。<ul><li>当async 函数没有返回值，它会返回 Promise.resolve()。</li></ul></li></ul><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><ul><li>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。</li><li>await后面调用的函数需要返回一个promise</li><li><p>await 必须出现在 async 函数内部，不能单独使用。</p></li><li><p>若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行async function。</p></li><li>若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。</li><li>若 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。</li></ul><h2 id="一-then-：多个异步事件串行执行"><a href="#一-then-：多个异步事件串行执行" class="headerlink" title="一. then()：多个异步事件串行执行"></a>一. <code>then()</code>：多个异步事件串行执行</h2><p>类似于RxSwift中<code>flatMap</code></p><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h4><pre><code class="JS">cook()    .then(data =&gt; {        return eat(data);    })    .then(data =&gt; {        return wash(data);    })    .then(data =&gt; {        console.log(data);    });</code></pre><h4 id="写法二：-简化的写法"><a href="#写法二：-简化的写法" class="headerlink" title="写法二： 简化的写法"></a>写法二： 简化的写法</h4><pre><code>// 简化的写法cook()    .then(eat)    .then(wash)    .then((data) =&gt; {        console.log(data);    })    .catch(err=&gt;{        console.log(err);    });</code></pre><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><pre><code>// 抛出异常cook()    .then(data =&gt; {        throw new Error(&#39;米饭被打翻了！&#39;);        eat(data);    })    .then(wash)    .then((data) =&gt; {        console.log(data);    })    .catch(err =&gt; {        console.log(err);    });</code></pre><h4 id="写法三：使用async-await"><a href="#写法三：使用async-await" class="headerlink" title="写法三：使用async/await"></a>写法三：使用async/await</h4><pre><code class="js">async function flatMap() {    try {        let cookResult = await cook();        let eatResult = await eat();        let washResult = await wash();        console.log(`async await flatMap test: ${cookResult},${eatResult},${washResult}~~~~~`);    } catch (err) {        console.log(`error: ${err}`);    }}flatMap() // async await flatMap test: 鸡蛋炒饭,一块碗和一双筷子,干净的碗筷~~~~~</code></pre><h2 id="二-all-多个异步事件并行执行，全部执行完毕后再执行then回调"><a href="#二-all-多个异步事件并行执行，全部执行完毕后再执行then回调" class="headerlink" title="二. all(): 多个异步事件并行执行，全部执行完毕后再执行then回调"></a>二. <code>all()</code>: 多个异步事件并行执行，全部执行完毕后再执行then回调</h2><p>类似于RxSwift中<code>zip</code></p><h4 id="方式一：Promise"><a href="#方式一：Promise" class="headerlink" title="方式一：Promise"></a>方式一：Promise</h4><pre><code class="JS">Promise    .all([cutUp(), boil()])    .then(results =&gt; {        console.log(results);    });</code></pre><h4 id="方式二：使用async-await"><a href="#方式二：使用async-await" class="headerlink" title="方式二：使用async await"></a>方式二：使用async await</h4><pre><code class="js">async function zip() {    try {        let results = await Promise.all([cutUp(), boil()]);        console.log(`async await zip test ${results}`)    } catch (err) {        console.log(`error: ${err}`);    }}zip() // async await zip test 切好的菜,烧好的水</code></pre><h2 id="三-race-多个异步事件同时执行，只要有一个执行完毕立即执行then回调"><a href="#三-race-多个异步事件同时执行，只要有一个执行完毕立即执行then回调" class="headerlink" title="三. race(): 多个异步事件同时执行，只要有一个执行完毕立即执行then回调"></a>三. <code>race()</code>: 多个异步事件同时执行，只要有一个执行完毕立即执行then回调</h2><h4 id="方式一：Promise-1"><a href="#方式一：Promise-1" class="headerlink" title="方式一：Promise"></a>方式一：Promise</h4><pre><code class="JS">Promise    .race([cutUp(), boil()])    .then(results =&gt; {        console.log(results);    });</code></pre><h4 id="方式二：使用async-await-1"><a href="#方式二：使用async-await-1" class="headerlink" title="方式二：使用async await"></a>方式二：使用async await</h4><pre><code class="JS">async function race() {    try {        let results = await Promise.race([cutUp(), boil()]);        console.log(`async await race test ${results}`)    } catch (err) {        console.log(`error: ${err}`);    }}race() //async await race test 切好的菜</code></pre><ul><li>应用：为异步操作设置超时时间<br><code>`</code>JS<br>//请求某个图片资源<br>function requestImg(){<br>  var p = new Promise(function(resolve, reject){<br>  var img = new Image();<br>  img.onload = function(){<pre><code> resolve(img);</code></pre>  }<br>  img.src = ‘xxxxxx’;<br>  });<br>  return p;<br>}</li></ul><p>//延时函数，用于给请求计时<br>function timeout(){<br>    var p = new Promise(function(resolve, reject){<br>        setTimeout(function(){<br>            reject(‘图片请求超时’);<br>        }, 5000);<br>    });<br>    return p;<br>}</p><p>Promise<br>.race([requestImg(), timeout()])<br>.then(function(results){<br>    console.log(results);<br>})<br>.catch(function(reason){<br>    console.log(reason);<br>});<br><code>`</code></p><p>参考：<a href="https://www.cnblogs.com/sweeeper/p/8442613.html" target="_blank" rel="noopener">https://www.cnblogs.com/sweeeper/p/8442613.html</a><br><a href="https://segmentfault.com/a/1190000011526612?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011526612?utm_source=tag-newest</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备代码&quot;&gt;&lt;a href=&quot;#准备代码&quot; class=&quot;headerlink&quot; title=&quot;准备代码&quot;&gt;&lt;/a&gt;准备代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;JS&quot;&gt;//做饭
function cook() {
    console.log(&amp;#39
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Native布局</title>
    <link href="http://superkk.top/2018/05/21/React-Native%20%E5%B8%83%E5%B1%80/"/>
    <id>http://superkk.top/2018/05/21/React-Native 布局/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:25:25.038Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://facebook.github.io/react-native/docs/flexbox" target="_blank" rel="noopener">https://facebook.github.io/react-native/docs/flexbox</a><br><a href="https://yogalayout.com/playground" target="_blank" rel="noopener">https://yogalayout.com/playground</a></p><h1 id="颜色字符串"><a href="#颜色字符串" class="headerlink" title="颜色字符串"></a>颜色字符串</h1><p>backgroundColor: ‘#30576EA0’,<br>前面两位（30）表示透明度，范围是0～99</p><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829215932.png" alt=""><br> 边框属性(border)用来设定一个元素的边线。</p><ul><li>边距属性(margin)是用来设置一个元素所占空间的边缘到相邻元素之间的距离。</li><li>间隙属性(padding)是用来设置元素内容到元素边界的距离。</li></ul><p><br></p><h1 id="Flexbox布局属性"><a href="#Flexbox布局属性" class="headerlink" title="Flexbox布局属性"></a>Flexbox布局属性</h1><h2 id="伸缩容器的属性"><a href="#伸缩容器的属性" class="headerlink" title="伸缩容器的属性"></a>伸缩容器的属性</h2><h3 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h3><ul><li><p><code>flexDirection</code>  ：决定布局的主轴，默认值是竖直轴(column)</p><ul><li><code>row</code>:（默认值）</li><li><code>row-reverse</code></li><li><code>column</code> (RN默认值)</li><li><code>column-reverse</code></li></ul></li><li><p><code>justifyContent</code> ：决定其子元素沿着主轴的排列方式</p><ul><li><code>flex-start</code>:（默认值）从主轴的起点对齐    </li><li><code>flex-end</code>: 从主轴的终点对齐    </li><li><code>center</code>:从主轴的中间位置对齐    </li><li><code>space-between</code>:平均分布在主轴线上    </li><li><code>space-around</code>:平均分布在主轴线上，两端留下一半的距离</li></ul></li></ul><ul><li><code>flexWap</code><br>伸缩容器在主轴线方向空间不足的情况下，是否换行以及该如何换行<ul><li><code>nowrap</code>（默认值）</li><li><code>wrap</code>    </li><li><code>wrap-reverse</code></li></ul></li></ul><h3 id="次轴"><a href="#次轴" class="headerlink" title="次轴"></a>次轴</h3><ul><li><p><code>alignItems</code>：决定其子元素沿着次轴的排列方式</p><ul><li><code>flex-start</code>（默认值）交叉轴起点对齐</li><li><code>flex-end</code> 交叉轴终点对齐</li><li><code>center</code> 中点对齐</li><li><code>stretch</code> 拉伸</li><li><code>baseline</code> 基线对齐<br><code>baseline</code>对齐效果：<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829221739.png" alt=""><br><code>stretch</code>效果（不设置高度时）<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829221759.png" alt=""></li></ul></li><li><p><code>align-content</code><br>用来调整伸缩项目出现换行后在交叉轴上的对齐方式</p><ul><li><code>flex-start</code></li><li><code>flex-end</code>    </li><li><code>center</code>    </li><li><code>space-between</code>    </li><li><code>space-around</code>    </li><li><code>stretch</code>（默认值）</li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>display</code><ul><li><code>flex</code>    块级伸缩容器    </li><li><code>inline-flex</code>行内级伸缩容器</li><li><code>none</code>隐藏元素</li></ul></li></ul><ul><li><code>flex-flow</code><br>同时定义了伸缩容器的主轴和侧轴, 其默认值为 <ul><li><code>row</code> </li><li><code>nowrap</code></li></ul></li></ul><h2 id="伸缩项目的属性"><a href="#伸缩项目的属性" class="headerlink" title="伸缩项目的属性"></a>伸缩项目的属性</h2><ul><li><p><code>order</code><br>定义项目的排列顺序，数值越小，排列越靠前，默认值为0<br>语法为：order：整数值</p></li><li><p><code>flex-grow</code><br>定义伸缩项目的放大比例，为整数值</p><ul><li>0(默认值): 不放大</li><li>其他值: 如果存在剩余空间，那么将自动占据全部剩余空间，每个item所占据的空间大小会根据这个值自动调整</li></ul></li><li><p><code>flex-shrink</code><br>定义伸缩项目的收缩能力，默认值为1 ，其语法为：flex-shrink:整数值</p><ul><li>1(默认值)    其他值</li><li>如果不存在剩余空间，那么将自动缩小</li></ul></li><li><p><code>flex-basis</code><br>用来设置伸缩项目的基准值，剩余的空间按比率进行伸缩</p><ul><li><code>auto</code>(默认值)    </li><li><code>length</code></li></ul></li><li><p><code>flex</code><br>是flex-grow flex-shrink flex-basis这三个属性的缩写，其语法为：flex:none | flex-grow flex-shrink flex-basis，其中第二个和第三个参数为可选参数，默认值为：0 1 auto</p></li><li><p><code>alignSelf</code><br>用来设置单独的伸缩项目在交叉轴上的对齐方式，会覆盖默认的对齐方式 </p><ul><li><code>auto</code> 按照自身设置的宽高进行显示    </li><li><code>flex-start</code>    </li><li><code>flex-end</code>    </li><li><code>center</code>    </li><li><code>baseline</code>    </li><li><code>stretch</code>默认,伸缩项目在交叉轴方向占满伸缩容器，如果交叉轴为垂直方向的话，只有在不设置高度的情况下才能看到效果</li></ul></li></ul><h1 id="React-Native中的postion定位"><a href="#React-Native中的postion定位" class="headerlink" title="React Native中的postion定位"></a>React Native中的postion定位</h1><ul><li><code>relative</code> 相对定位(默认)，以元素本来的位置为基准进行偏移。</li><li><code>absolute</code> 绝对定位，以父元素的边框为基准进行偏移。<br><a href="https://blog.csdn.net/al4fun/article/details/80253364" target="_blank" rel="noopener">https://blog.csdn.net/al4fun/article/details/80253364</a></li></ul><h1 id="width-39-100-39-与width-39-auto-39"><a href="#width-39-100-39-与width-39-auto-39" class="headerlink" title="width:&#39;100%&#39;与width:&#39;auto&#39;"></a><code>width:&#39;100%&#39;与width:&#39;auto&#39;</code></h1><ul><li><code>width:auto</code> 会将元素撑开至整个父元素width，但是会减去子节点自己的margin，padding或者border的大小。</li><li><code>width:100%</code> 会强制将元素变成和父元素一样的宽，并且添加额外的空间到这个元素的width上。就是因为这个，会导致很多问题。</li></ul><p>使用width:100%永远都不是一个好主意。这个属性容易让人产生你正在定义一个元素可视大小，其实，你是在对这个元素的状态做了巨大的改变。</p><pre><code>&lt;TouchableOpacity style={[styles.comButton]}&gt;    &lt;Text        style={[        {            width: &quot;100%&quot;,            height: &quot;100%&quot;,        }]}&gt;        {item.title}    &lt;/Text&gt;&lt;/TouchableOpacity&gt;comButton: {    padding:0,    flex: 1,    alignItems: &quot;center&quot;,    justifyContent: &quot;center&quot;,    color: CommonStyle.col_gray_dark,    borderColor: CommonStyle.col_gray_dark,    borderWidth: 0.8,    borderRadius: 48,    height: 44  }</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829222452.png" alt=""></p><pre><code>&lt;TouchableOpacity style={[styles.comButton]}&gt;    &lt;Text        style={[        {            width: Platform.OS === &#39;ios&#39; ? &#39;auto&#39; : &quot;100%&quot;,            height: Platform.OS === &#39;ios&#39; ? &#39;auto&#39; : &quot;100%&quot;,        }]}&gt;        {item.title}    &lt;/Text&gt;&lt;/TouchableOpacity&gt;</code></pre><p><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829222515.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react-native/docs/flexbox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://facebook.github.io/react-native/doc
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Native Tips</title>
    <link href="http://superkk.top/2018/05/21/React-Native%20Tips/"/>
    <id>http://superkk.top/2018/05/21/React-Native Tips/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:25:52.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速进入断点"><a href="#快速进入断点" class="headerlink" title="快速进入断点"></a>快速进入断点</h1><ol><li>模拟器开启远程调试</li><li>在浏览器上<code>cmd+option+I</code>打开调试页面</li><li>代码输入<code>dubugger</code>进入断点<br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211638.png" alt=""><br><img src="https://raw.githubusercontent.com/action456789/Image/master/20190829211651.png" alt=""></li></ol><h1 id="更新node"><a href="#更新node" class="headerlink" title="更新node"></a>更新node</h1><ul><li>1、更新npm<br><code>npm -v</code><br><code>npm install npm@latest -g</code></li><li>2、更新node<pre><code>sudo npm cache clean -fsudo npm install -g nsudo n stable</code></pre></li></ul><p>参考：<a href="https://www.hostingadvice.com/how-to/update-node-js-latest-version/" target="_blank" rel="noopener">https://www.hostingadvice.com/how-to/update-node-js-latest-version/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速进入断点&quot;&gt;&lt;a href=&quot;#快速进入断点&quot; class=&quot;headerlink&quot; title=&quot;快速进入断点&quot;&gt;&lt;/a&gt;快速进入断点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;模拟器开启远程调试&lt;/li&gt;
&lt;li&gt;在浏览器上&lt;code&gt;cmd+option+I&lt;/code
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>JS常用点</title>
    <link href="http://superkk.top/2018/05/21/JS%E5%B8%B8%E7%94%A8%E7%82%B9/"/>
    <id>http://superkk.top/2018/05/21/JS常用点/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T14:31:27.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul><li><code>for of</code>：遍历数组value<blockquote><p>TIPS: for of 断点时，获取不到变量信息<br><code>`</code><br>const array = [<br> {</p><pre><code> name: &quot;张三&quot;</code></pre><p> }, {</p><pre><code> name: &quot;李四&quot;</code></pre><p> }, {</p><pre><code> name: &quot;王五&quot;</code></pre><p> }, {</p><pre><code> name: &quot;小红&quot;</code></pre><p> }];</p></blockquote></li></ul><p>let obj = {<br>    name: “小红”,<br>    age: 19,<br>    sex: ‘女’,<br>}</p><p>// for of：遍历数组value<br>for (const item of array) {<br>    console.log(item.name);<br>}</p><pre><code>![](https://raw.githubusercontent.com/action456789/Image/master/20190829222714.png)- `for in`：遍历对象key</code></pre><p>// for in：遍历对象key<br>for (const key in obj) {<br>    console.log(<code>${key}:${obj[key]}</code>);<br>}</p><pre><code>![](https://raw.githubusercontent.com/action456789/Image/master/20190829222733.png)- `map`</code></pre><p>let nArray = array.map((value, index) =&gt; {<br>    return { …value, type: ‘哈哈’ }<br>})<br>console.log(nArray);</p><pre><code>- 切片：`splice`    - [start, end) 从下标start开始，到下标end结束，不包括end    - end 大于数组长度会截取到数组结束</code></pre><p>let subArray = array.splice(0, 6)<br>console.log(subArray)</p><pre><code>![](https://raw.githubusercontent.com/action456789/Image/master/20190829222753.png)# 解构赋值本质是`模式匹配`## 数组- 本质：实现了Iterator 接口的对象就可以按顺序解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定</code></pre><p>let [a, [b], d] = [1, [2, 3], 4];<br>a // 1<br>b // 2<br>d // 4</p><pre><code>- 默认值</code></pre><p>let [x = 1, y = x] = [2];    // x=2; y=2<br>let [foo = true] = [];<br>foo // true</p><p>let [x = 1] = [undefined];<br>x // 1</p><pre><code>#### 对象#####变量与属性同名- 字符串赋值</code></pre><p>  let { bar, foo, hello } = { foo: ‘aaa’, bar: ‘bbb’ };<br>  foo // “aaa”<br>  bar // “bbb”<br>  hello // “undefined”</p><pre><code>- 对象方法赋值</code></pre><p>const { log } = console;<br>log(‘hello’) // hello</p><pre><code>##### 变量名与属性名不同名</code></pre><p>let { foo: baz } = { foo: ‘aaa’, bar: ‘bbb’ };<br>baz // “aaa”</p><pre><code>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者##### 嵌套对象赋值- 注意，对象嵌套赋值里，`冒号:`代表模式，并不是取值</code></pre><p>const node = {<br>    loc: {<br>      start: {<br>        line: 1,<br>        column: 5<br>      }<br>    }<br>  };</p><p>let { loc: { start }} = node;<br>start // Object {line: 1, column: 5}<br>loc // undefined</p><p>let { loc, loc: { start }}<br>start // Object {line: 1, column: 5}<br>loc // Object {start: Object}</p><p>let { loc: { start: { line }}} = node;<br>line // 1<br>loc // undefined<br>start // undefined</p><pre><code>##### 获取对象继承的属性</code></pre><p>const obj1 = {};<br>const obj2 = { foo: ‘bar’ };<br>Object.setPrototypeOf(obj1, obj2);</p><p>const { foo } = obj1;<br>foo // “bar”</p><pre><code>##### 默认值</code></pre><p>var {x = 3} = {};<br>x // 3</p><p>var {x = 3} = {x: undefined};<br>x // 3</p><pre><code>#### 已声明变量的解构赋值- 错误的写法</code></pre><p>let x;<br>{x} = {x: 1};<br>// SyntaxError: syntax error</p><pre><code>- 正确的写法</code></pre><p>let x;<br>({x} = {x: 1});</p><pre><code>#### 函数参数的解构赋值函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</code></pre><p>function add([x, y]){<br>  return x + y;<br>}</p><p>add([1, 2]); // 3</p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="大前端" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://superkk.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/js/"/>
    
    
  </entry>
  
  <entry>
    <title>RxSwift入门：基本概念</title>
    <link href="http://superkk.top/2018/05/21/RxSwift%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://superkk.top/2018/05/21/RxSwift入门：基本概念/</id>
    <published>2018-05-21T10:01:12.000Z</published>
    <updated>2019-08-29T09:07:04.708Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><p>Observables是一个事件流的对象</p><h2 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h2><p>通过empty函数，可以生成一个空的流，在这个流中只会产生一个Completed信息。</p><pre><code class="Swift">let emptyStream: Observable&lt;Int&gt; = Observable.empty()_ = emptyStream.subscribe { event inprint(event)  completed}</code></pre><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>通过never函数产生的流对象，将不会有任何的事件发生。</p><pre><code class="Swift">let neverStream: Observable&lt;Int&gt; = Observable.never()_ = neverStream.subscribe({ _ inprint(&quot;这个方法永远都不会被执行&quot;)})</code></pre><h2 id="just"><a href="#just" class="headerlink" title="just"></a>just</h2><p>just函数调用之后将会产生一个next事件以及一个Completed事件，其中next可以用来传递数据，最后的Completed事件发送之后将不会再有事件了。<br>简单的说：just函数可以发送一个数据。</p><pre><code class="Swift">let justStream = Observable.just(32)_ = justStream.subscribe({ event inprint(event)/*next(32)completed*/})</code></pre><h2 id="of"><a href="#of" class="headerlink" title="of"></a>of</h2><p>将一个集合内的数据所有数据顺序的发送出去。</p><pre><code class="Swift">let ofStream = Observable.of(0, 1, 2)_ = ofStream.subscribe({ event inprint(event)/*next(0)next(1)next(2)completed*/})</code></pre><h2 id="from"><a href="#from" class="headerlink" title="from"></a>from</h2><p>将一个集合对象（比如数组、Range等）转换成流对象，通过订阅可以获得这个集合对象的所有内容。</p><pre><code class="Swift">let streamFromArray = Observable.from([0, 1, 2])_ = streamFromArray.subscribe({ (event) inprint(event)/*next(0)next(1)next(2)completed*/})</code></pre><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>create 函数是通过利用闭包来生成流对象的函数</p><pre><code class="Swift">let myJust = { (singleElement: Int) -&gt; Observable &lt;Int&gt; inreturn Observable.create({ (observer) -&gt; Disposable inobserver.onNext(singleElement)observer.onCompleted()return Disposables.create()})}let singleElementStream = myJust(32)_ = singleElementStream.subscribe { (event) inprint(event)/*next(32)completed*/}</code></pre><h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>通过error函数将会生成一个终止的流，这个流中只会产生一次error事件并结束掉。</p><pre><code class="Swift">let error = NSError(domain: &quot;com.RxSwiftDemo.kesen&quot;, code: -1, userInfo: nil)let errorStream: Observable&lt;Int&gt; = Observable.error(error)_ = errorStream.subscribe { (event) inprint(event)error(Error Domain=com.RxSwiftDemo.kesen Code=-1 &quot;(null)&quot;)}</code></pre><h2 id="deffered"><a href="#deffered" class="headerlink" title="deffered"></a>deffered</h2><p>deffered函数生成的流对象，只有在添加了订阅者才会被创建。</p><pre><code class="Swift">let defferedStream = Observable.deferred { () -&gt; Observable&lt;Int&gt; inreturn Observable.create({ (observer) -&gt; Disposable inobserver.onNext(0)observer.onNext(1)observer.onCompleted()return Disposables.create()})}_ = defferedStream.subscribe({ (event) inprint(event)/*next(0)next(1)completed*/})</code></pre><h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>Subject其实就是Observer，拥有Observer的所有功能，也可以认为是热的Observer。</p><h2 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h2><p>它仅仅会发送observer订阅之后的事件，也就是说如果sequence上有.Next 的到来，但是这个时候某个observer还没有subscribe它，这个observer就收不到这条信息，它只会收到它订阅之后发生的事件。</p><h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>它和PublishSubject不同之处在于它不会漏消息。即使observer在subscribe的时候已经有事件发生过了，它也会收到之前的事件序列。</p><h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>当有observer在订阅一个BehaviorSubject的时候，它首先将会收到Observable上最近发送一个信号（或者是默认值），接着才会收到Observable上会发送的序列。</p><h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>Variable是BehaviorSubject的封装，它和BehaviorSubject不同之处在于，不能向Variable发送.Complete和.Error，它会在生命周期结束被释放的时候自动发送.Complete。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Observable&quot;&gt;&lt;a href=&quot;#Observable&quot; class=&quot;headerlink&quot; title=&quot;Observable&quot;&gt;&lt;/a&gt;Observable&lt;/h1&gt;&lt;p&gt;Observables是一个事件流的对象&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="Rx &amp; RAC" scheme="http://superkk.top/categories/iOS/Rx-RAC/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS11新特性</title>
    <link href="http://superkk.top/2017/12/22/iOS11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://superkk.top/2017/12/22/iOS11新特性/</id>
    <published>2017-12-22T15:02:12.000Z</published>
    <updated>2019-08-29T09:07:04.726Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="iOS11-大标题"><a href="#iOS11-大标题" class="headerlink" title="iOS11 大标题"></a>iOS11 大标题</h1><pre><code>// 导航控制器的`prefersLargeTitles`为大标题的总开关navigationController?.navigationBar.prefersLargeTitles = true// 各个控制器可以自己通过 largeTitleDisplayMode，如果导航控制器的 `prefersLargeTitles` 为 NO，largeTitleDisplayMode 将没有效果navigationItem.largeTitleDisplayMode = .never</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-d28e28449f722b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="iOS11-导航栏搜索框"><a href="#iOS11-导航栏搜索框" class="headerlink" title="iOS11 导航栏搜索框"></a>iOS11 导航栏搜索框</h1><pre><code>let searchResultsVC = SearchResultTabelViewVC(nibName: nil, bundle: nil)lazy var searchController: UISearchController = {let vc = UISearchController(searchResultsController: searchResultsVC)vc.searchResultsUpdater = self.searchResultsVCvc.hidesNavigationBarDuringPresentation = truevc.dimsBackgroundDuringPresentation = truevc.searchBar.placeholder = &quot;搜索设备&quot;vc.searchBar.enablesReturnKeyAutomatically = falsevc.searchBar.sizeToFit()return vc}()navigationItem.searchController = searchControllernavigationItem.hidesSearchBarWhenScrolling = false</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-d3ea03b58766402f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-de6a6e4434ad40f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="iOS11-Safe-Area-Insets"><a href="#iOS11-Safe-Area-Insets" class="headerlink" title="iOS11 Safe Area Insets"></a>iOS11 Safe Area Insets</h1><pre><code>additionalSafeAreaInsets = UIEdgeInsets(top: 100, left: 0, bottom: 100, right: 100)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1120923-390517a880546e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="UITableView-separatorInsetReference"><a href="#UITableView-separatorInsetReference" class="headerlink" title="UITableView separatorInsetReference"></a>UITableView separatorInsetReference</h1><p><img src="https://upload-images.jianshu.io/upload_images/1120923-67de438546b61af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1120923-1b6960bbfe07be8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>tableView.estimatedRowHeight = 0tableView.estimatedSectionHeaderHeight = 0tableView.estimatedSectionFooterHeight = 0tableView.separatorInsetReference = .fromAutomaticInsetstableView.separatorInset.left = 60</code></pre><h1 id="UITableViewCell-左划、右划"><a href="#UITableViewCell-左划、右划" class="headerlink" title="UITableViewCell 左划、右划"></a>UITableViewCell 左划、右划</h1><pre><code>// iOS11 UITableViewCell 左划override func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {let action = UIContextualAction(style: .normal, title: &quot;收藏&quot;) { (action, view, completionHandler) in// 执行收藏操作// ...completionHandler(true)}action.image =  imageLiteral(resourceName: &quot;favorite&quot;)action.backgroundColor = UIColor.redlet configuration = UISwipeActionsConfiguration(actions: [action])return configuration}// iOS11 UITableViewCell 右划override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {let action = UIContextualAction(style: .destructive, title: &quot;删除&quot;) { (action, view, completionHandler) in// remove item// ...completionHandler(true)}let configuration = UISwipeActionsConfiguration(actions: [action])return configuration}</code></pre><h1 id="代码见"><a href="#代码见" class="headerlink" title="代码见"></a>代码见</h1><p><a href="https://github.com/action456789/iOS11Demo" target="_blank" rel="noopener">https://github.com/action456789/iOS11Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;iOS11-大标题&quot;&gt;&lt;a href=&quot;#iOS11-大标题&quot; class=&quot;headerlink&quot; title=&quot;iOS11 大标题&quot;&gt;&lt;/a&gt;iOS11 大标题&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;// 导航控制器的`prefersLarg
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS SDK 开发</title>
    <link href="http://superkk.top/2017/12/09/iOS-SDK-%E5%BC%80%E5%8F%91/"/>
    <id>http://superkk.top/2017/12/09/iOS-SDK-开发/</id>
    <published>2017-12-09T07:07:25.000Z</published>
    <updated>2019-08-29T09:07:04.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Framework与-a基础"><a href="#一、Framework与-a基础" class="headerlink" title="一、Framework与.a基础"></a>一、Framework与.a基础</h1><p>此处等下一期</p><p><br></p><hr><h1 id="二、工程嵌套联调静态库"><a href="#二、工程嵌套联调静态库" class="headerlink" title="二、工程嵌套联调静态库"></a>二、工程嵌套联调静态库</h1><h2 id="1、新建一个主工程"><a href="#1、新建一个主工程" class="headerlink" title="1、新建一个主工程"></a>1、新建一个主工程</h2><p><br></p><h2 id="2、新建一个Library工程"><a href="#2、新建一个Library工程" class="headerlink" title="2、新建一个Library工程"></a>2、新建一个Library工程</h2><p><br></p><h2 id="3、将静态库工程拖到主工程文件夹下"><a href="#3、将静态库工程拖到主工程文件夹下" class="headerlink" title="3、将静态库工程拖到主工程文件夹下"></a>3、将静态库工程拖到主工程文件夹下</h2><blockquote><p>如果你要拖到其他目录，就要改Library Search Paths<br><img src="https://upload-images.jianshu.io/upload_images/1120923-cce04359a1bbfaad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><br></p></blockquote><h2 id="4、将Library工程下-a文件拖入主工程的Link-Binary-With-Libraries"><a href="#4、将Library工程下-a文件拖入主工程的Link-Binary-With-Libraries" class="headerlink" title="4、将Library工程下.a文件拖入主工程的Link Binary With Libraries"></a>4、将Library工程下.a文件拖入主工程的Link Binary With Libraries</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-a5abaa5e64aee935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果有必要（运行时崩溃），将静态库需要加入 Embedded Binaries 中<br><img src="https://upload-images.jianshu.io/upload_images/1120923-a187820d28065970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="5-主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"><a href="#5-主工程添加对子工程的依赖，避免每次修改都要手动编译子工程" class="headerlink" title="5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"></a>5. 主工程添加对子工程的依赖，避免每次修改都要手动编译子工程</h2><p>如下图给主工程添加对子工程的依赖，这样每次编译主工程的时候也会编译子工程。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-014ee57b806790ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><br></p><hr><h1 id="三、在静态库中使用图片以及-xib-等资源文件"><a href="#三、在静态库中使用图片以及-xib-等资源文件" class="headerlink" title="三、在静态库中使用图片以及 xib 等资源文件"></a>三、在静态库中使用图片以及 xib 等资源文件</h1><h2 id="1、添加-Bundle-Target"><a href="#1、添加-Bundle-Target" class="headerlink" title="1、添加 Bundle Target"></a>1、添加 Bundle Target</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-0daa863f0f458a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>因为iOS框架中没有bundle，要选中OS X框架找到bundle，如下图<br><img src="https://upload-images.jianshu.io/upload_images/1120923-271a68244a055813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h2 id="2、将资源文件加入-bundle-中"><a href="#2、将资源文件加入-bundle-中" class="headerlink" title="2、将资源文件加入 bundle 中"></a>2、将资源文件加入 bundle 中</h2><p>将工程中的资源文件都加入到刚刚建的bundle中，如xib、图片。点+号或直接拖都行。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-54e9d8ebb8086020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="3、iOS-Deployment-Target改为你支持的最低版本"><a href="#3、iOS-Deployment-Target改为你支持的最低版本" class="headerlink" title="3、iOS Deployment Target改为你支持的最低版本"></a>3、iOS Deployment Target改为你支持的最低版本</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-acc55ab1a1c172ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="4、设置base-SDK-为latest-iOS"><a href="#4、设置base-SDK-为latest-iOS" class="headerlink" title="4、设置base SDK 为latest iOS"></a>4、设置base SDK 为latest iOS</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-935ccc7c15d9dd90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="5、编译-Bundle"><a href="#5、编译-Bundle" class="headerlink" title="5、编译 Bundle"></a>5、编译 Bundle</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-89b0b426acb67a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"><a href="#6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程" class="headerlink" title="6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程"></a>6、主工程添加对子工程的依赖，避免每次修改都要手动编译子工程</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-5e09392ed9b3954c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="7、加载-Bundle-里的资源文件"><a href="#7、加载-Bundle-里的资源文件" class="headerlink" title="7、加载 Bundle 里的资源文件"></a>7、加载 Bundle 里的资源文件</h2><h3 id="7-1、加载图片"><a href="#7-1、加载图片" class="headerlink" title="7.1、加载图片"></a>7.1、加载图片</h3><p>使用运行时替换 <code>[UIImage imageNamed:]</code>方法，减少修改代码的工作量。<br>相关代码在以下几个类中<br><img src="https://upload-images.jianshu.io/upload_images/1120923-d22158e1d55e1cab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>// 在AppDelegate中执行以下代码即可swizzle 所有 [UIImage imageNamed:]#import &quot;UIImage+Swizzle.h&quot;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    [UIImage kk_autoLoadImageInBundle];    return YES;}</code></pre><ul><li>UIImage+Swizzle.m<br><code>`</code><br>//<br>// 修改所有的 [UIImage imageNamed:]的实现，改为先从同一项目中的 .bundle 文件中加载，没有再使用系统默认实现加载</li></ul><ul><li>(void)kk_autoLoadImageInBundle {<br>  SEL original = @selector(imageNamed:);<br>  SEL new = @selector(hook_kk_imageWithName:);<br>  [self kk_swizzleClassMethod:original with:new];<br>}</li></ul><p>// 1. 从 .bundle 中加载图片<br>// 2. 按照默认的方法加载图片</p><ul><li><p>(instancetype)hook_kk_imageWithName:(NSString <em>)imageName {<br>  UIImage </em>image = [NSBundle kk_imageInBundle:kk_BundleName imageName:imageName];<br>  if (!image) {</p><pre><code>  image = [self hook_kk_imageWithName:imageName];</code></pre><p>  }</p><p>  return image;<br>}<br><code>`</code></p></li></ul><ul><li>NSObject+Swizzle.m<br><code>`</code><br>#import “NSObject+Swizzle.h”<br>#import &lt;objc/objc.h&gt;<br>#import &lt;objc/runtime.h&gt;</li></ul><p>@implementation NSObject (Swizzle)</p><ul><li><p>(BOOL)kk_swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel {<br>  Class class = object_getClass(self);<br>  Method originalMethod = class_getInstanceMethod(class, originalSel);<br>  Method newMethod = class_getInstanceMethod(class, newSel);</p><p>  if (!originalMethod || !newMethod) return NO;<br>  method_exchangeImplementations(originalMethod, newMethod);</p><p>  return YES;<br>}</p></li><li><p>(BOOL)kk_swizzleClassMethod:(SEL)originalSel with:(SEL)newSel {<br>  Class class = object_getClass(self);<br>  Method originalMethod = class_getClassMethod(class, originalSel);<br>  Method newMethod = class_getClassMethod(class, newSel);</p><p>  if (!originalMethod || !newMethod) return NO;<br>  method_exchangeImplementations(originalMethod, newMethod);</p><p>  return YES;<br>}</p></li></ul><p>@end</p><pre><code>### 7.2、加载 `xib`#### 7.2.1 加载xib对应的`UIViewController`需要重写xib对应控制器的 init 方法，否则可能出现找不到xib文件导致crash参考[bundle打包xib文件](http://www.jianshu.com/p/a8c9e52c80de)</code></pre><ul><li><p>(instancetype)init {</p><p>  NSBundle *bundle = [NSBundle kk_bundleWithName:kBundleTargetName];</p><p>  self = [super initWithNibName:@”CalculatePriceViewController” bundle:bundle];</p><p>  return self;</p></li></ul><p>}</p><pre><code>代码参见：[github]([https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h)](https://github.com/action456789/SKS_Collection/blob/master/SKS_Collection/Classes/Category/Framework开发/NSBundle%2BResource.h))#### 7.2.1 加载xib对应的`UIVIew`需要重写xib对应View的 init 方法，，否则可能出现找不到xib文件导致crash</code></pre><p>@implementation OfflineView</p><p>//重写要加载的view的init方法</p><ul><li>(instancetype)init {<br>  if (self = [super init]) {<pre><code>  NSBundle *bundle = [NSBundle kk_bundleWithName:kk_BundleName];  self = [[bundle loadNibNamed:@&quot;OfflineView&quot; owner:self options:nil] lastObject];</code></pre>  }<br>  return self;<br>}</li></ul><p>@end</p><pre><code>### 7.3、加载 `Localizable.strings`#### 第一步：在Bundle中新建国际化文件![image.png](https://upload-images.jianshu.io/upload_images/1120923-6f11bf3b8f5d2236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)#### 第二步：添加语言，并将之前的国际化文件中的代码复制过来![image.png](https://upload-images.jianshu.io/upload_images/1120923-37cc110dd92a5079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)#### 第三步：使用 NSBundle+Resource 如下方法</code></pre><ul><li>(NSString <em>)mj_localizedStringForKey:(NSString </em>)key;</li><li>(NSString <em>)mj_localizedStringForKey:(NSString </em>)key value:(NSString *)value;<pre><code>然后使用如下宏定义</code></pre>// 加载 Bundle 中的国际化语句<br>#undef NSLocalizedString<br>#define NSLocalizedString(key, comment) \<br>[NSBundle mj_localizedStringForKey:(key)]<br><code>`</code><br>然后就可以自动的加载Bundle中的字符串了</li></ul><p><br></p><hr><h1 id="四、将整个App打包为Framework"><a href="#四、将整个App打包为Framework" class="headerlink" title="四、将整个App打包为Framework"></a>四、将整个App打包为Framework</h1><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ol><li>整个项目都要解除 AppDelegate 的依赖，AppDelegate不能打入Framework中</li><li>图片和xib文件需要按照 三 中的处理</li><li>可以使用 runtime 动态加载图片和xib文件，减少工作量</li><li>注意点：bundle中的国际化文件需要重新新建，添加语言，然后将之前App中的内容复制过来，直接拖进去是无效的</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1120923-57f527356830710e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="实际操作中存在的问题"><a href="#实际操作中存在的问题" class="headerlink" title="实际操作中存在的问题"></a>实际操作中存在的问题</h2><ol><li>图片同时存在@2x和@3x后缀导致加载的图片为nil的问题<br>解决办法为只要@2x的图片</li></ol><p><br></p><hr><h1 id="五、使用-appledoc-生成文档"><a href="#五、使用-appledoc-生成文档" class="headerlink" title="五、使用 appledoc 生成文档"></a>五、使用 <code>appledoc</code> 生成文档</h1><p><a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">官网</a></p><ul><li>安装<br><code>brew install appledoc</code></li><li>查看版本<br><code>appledoc --version</code></li><li>查看帮助<br><code>appledoc --help</code></li><li>生成文档<pre><code>appledoc --output ./doc --project-name &quot;D103Framework&quot;  --project-company &quot;RICISUNG&quot; --company-id &quot;RICISUNG&quot; .  </code></pre>”.“ 和前面的符号一定要加 空格 否则就会报错。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-dbc07ae1c94010da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h1 id="iOS-工程套子工程，主工程和framework工程或-a-library静态库工程联调-http-www-cnblogs-com-zhanglinfeng-p-5494762-html"><a href="#iOS-工程套子工程，主工程和framework工程或-a-library静态库工程联调-http-www-cnblogs-com-zhanglinfeng-p-5494762-html" class="headerlink" title="iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调](http://www.cnblogs.com/zhanglinfeng/p/5494762.html))"></a><a href="[http://www.cnblogs.com/zhanglinfeng/p/5494762.html"><a href="http://www.cnblogs.com/zhanglinfeng/p/5494762.html" target="_blank" rel="noopener">iOS 工程套子工程，主工程和framework工程或.a library静态库工程联调</a></a>](<a href="http://www.cnblogs.com/zhanglinfeng/p/5494762.html)" target="_blank" rel="noopener">http://www.cnblogs.com/zhanglinfeng/p/5494762.html)</a>)</h1><h1 id="iOS-framework静态库中使用xib和图片资源详解"><a href="#iOS-framework静态库中使用xib和图片资源详解" class="headerlink" title="iOS framework静态库中使用xib和图片资源详解"></a><a href="http://www.cnblogs.com/zhanglinfeng/p/5510717.html" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/zhanglinfeng/p/5510717.html" target="_blank" rel="noopener">iOS framework静态库中使用xib和图片资源详解</a></a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Framework与-a基础&quot;&gt;&lt;a href=&quot;#一、Framework与-a基础&quot; class=&quot;headerlink&quot; title=&quot;一、Framework与.a基础&quot;&gt;&lt;/a&gt;一、Framework与.a基础&lt;/h1&gt;&lt;p&gt;此处等下一期&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="高级" scheme="http://superkk.top/categories/iOS/%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>git命令大全</title>
    <link href="http://superkk.top/2017/09/09/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://superkk.top/2017/09/09/git命令大全/</id>
    <published>2017-09-09T13:09:46.000Z</published>
    <updated>2019-08-29T09:02:37.954Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC] </p><p>#基本概念</p><ul><li><code>master</code>指针：指向最新的提交</li></ul><hr><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://sfault-image.b0.upaiyun.com/37/92/37923f2478edc5709b36562b26c9e008" target="_blank" rel="noopener">http://sfault-image.b0.upaiyun.com/37/92/37923f2478edc5709b36562b26c9e008</a></p><hr><p>#全局配置<br><code>$ git config --global user.name &quot;kk&quot;</code><br><code>$ git config --global user.email &quot;superkesen@gmail.com&quot;</code></p><ul><li><p>编辑模式查看全局设置：<br><code>git config --global -e</code></p></li><li><p>列表形式查看全局设置：<br><code>git config --global -l</code></p></li></ul><hr><h1 id="使用GitHub时，在本地创建SSH-Key"><a href="#使用GitHub时，在本地创建SSH-Key" class="headerlink" title="使用GitHub时，在本地创建SSH Key"></a>使用GitHub时，在本地创建SSH Key</h1><p><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><ul><li><p>如果一切顺利的话，可以在用户主目录里（~/.ssh）找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p></li><li><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p></li></ul><hr><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul><li>克隆远程仓库到本地<br><code>git clone git@github.com:michaelliao/gitskills.git</code></li><li><p>克隆远程仓库某个分支到本地<br><code>git clone -b &lt;branch&gt; &lt;remote_repo&gt;</code><br>例如： <code>git clone -b 指定的分支名字</code></p></li><li><p>给本地仓库指定远程仓库</p></li></ul><ol><li><p>关联GitHub仓库：<br><code>git remote add origin git@github.com:michaelliao/learngit.git</code></p></li><li><p>显示远程仓库：<br><code>git remote show origin</code><br>第一次推送使用：<br><code>git push -u origin 分支名称</code><br>之后推送使用：<br><code>git push origin maste</code></p></li><li><p>查看远程仓库地址<br><code>git remote -v</code></p></li><li><p>取消关联远程仓库<br><code>git remote rm origin</code></p></li></ol><hr><h1 id="初始化git仓库"><a href="#初始化git仓库" class="headerlink" title="初始化git仓库"></a>初始化git仓库</h1><p><code>git init</code><br><code>git add .</code><br><code>git commit -m “xxxx&quot;</code></p><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>删除所有文件<br><code>git rm * -r</code><br>删除文件夹<br><code>git rm filename -r</code><br>忽略无需版本控制的文档<br><code>echo “*.txt” &gt; .gitignore</code></p><hr><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>查看commit日志<br><code>git reflog</code><br>或<br><code>git log</code></p><hr><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul><li>查看当前所在分支<br><code>git branch -a</code></li><li>切换到某个分支<br><code>git checkout 分支名字</code></li></ul><hr><ul><li>创建本地分支并切换到创建的分支：<br><code>git checkout -b your_branch</code></li><li>提交该分支到远程仓库<br><code>git push origin dev</code></li></ul><hr><ul><li>追踪远程分支<br><code>git branch --track release_2.3.0 origin/HEAD:refs/for/release_2.3.0</code></li><li>将本地分支push到远程分支，（远程会自动创建your_branch分支），并关联本地分支与远程分支<br><code>git push -u origin your_branch</code></li><li>删除远程分支<br><code>git push origin --delete &lt;branchName&gt;</code></li><li>删除本地分支<br><code>git branch -d your_branch</code></li></ul><hr><h1 id="本地提交回滚"><a href="#本地提交回滚" class="headerlink" title="本地提交回滚"></a>本地提交回滚</h1><ol><li>先重置本地在上次提交之后的修改（如果需要的话）<br><code>git checkout *.m</code></li><li>重置为远程仓库的最新版本<br>soft表示本地的修改还在本地文件中，不加的话那么本地的修改也没了<br><code>git reset HEAD^ --soft</code></li></ol><hr><h1 id="拉取远程代码时冲突"><a href="#拉取远程代码时冲突" class="headerlink" title="拉取远程代码时冲突"></a>拉取远程代码时冲突</h1><ol><li>保存本地修改到暂存区<br><code>git stash</code></li><li>拉取远程代码<br><code>git pull</code></li><li>将暂存区内容恢复到本地，有冲突时先解决冲突<br><code>git stash pop</code></li></ol><hr><h1 id="git-stash-的使用"><a href="#git-stash-的使用" class="headerlink" title="git stash 的使用"></a>git stash 的使用</h1><ul><li>列出所有暂时保存的工作<br><code>git stash list</code></li><li>恢复某个暂时保存的工作</li></ul><p><code>git stash apply stash@{1}</code></p><ul><li><p>保存stash时设置stash名称<br><code>git stash save &quot;my_stash&quot;</code></p></li><li><p>丢弃最近一次stash的文件<br><code>git stash drop</code></p></li></ul><h1 id="合并某次提交-merge-a-specific-commit-in-Git"><a href="#合并某次提交-merge-a-specific-commit-in-Git" class="headerlink" title="合并某次提交 merge a specific commit in Git"></a>合并某次提交 merge a specific commit in Git</h1><p><code>git cherry-pick d42c389f</code></p><hr><h1 id="git-merge-后-push-到-Gerrit-失败，提示-no-new-changes"><a href="#git-merge-后-push-到-Gerrit-失败，提示-no-new-changes" class="headerlink" title="git merge 后 push 到 Gerrit 失败，提示 no new changes"></a>git merge 后 push 到 Gerrit 失败，提示 no new changes</h1><ul><li>在 <code>git merge</code> 的时候，加上 <code>--no-ff</code> 参数，是为了让它生成一个新的 commit，这样就可以提交了~（不过生成的 gerrit change 是看不到改动信息的）</li></ul><h1 id="tag-操作"><a href="#tag-操作" class="headerlink" title="tag 操作"></a>tag 操作</h1><ul><li>查看tag<br><code>git tag</code></li><li>创建 本地 tag<br><code>git tag 1.0.0</code><br>或者<br><code>git tag -m &quot;first release&quot; 0.1.0</code></li><li>推送 本地 tag 到远程服务器<br><code>git push origin 1.0.0</code></li><li>或者推送所有tags到远程服务器<br><code>git push --tags</code> </li><li>删除本地 tag<br><code>git tag -d 1.0.0</code></li><li>删除远程 tag</li></ul><ol><li>先删除本地 tag<br><code>git tag -d 1.0.0</code></li><li>然后push<br><code>git push origin --delete tag 1.0.0</code><h1 id="fatal-remote-origin-already-exists-错误解决"><a href="#fatal-remote-origin-already-exists-错误解决" class="headerlink" title="fatal: remote origin already exists.错误解决"></a><code>fatal: remote origin already exists.</code>错误解决</h1></li><li>先删除远程 Git 仓库</li></ol><p><code>git remote rm origin</code><br>2 再添加远程 Git 仓库</p><p><code>git remote add origin git@github.com:FBing/Java-code-generator</code></p><h1 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h1><ul><li>创建<code>.gitignore文件</code><br><code>touch .gitignore</code><br>忽略规则示例<pre><code># 这是注释行，将被忽略*.a       # 忽略所有以.a为扩展名的文件    !lib.a    # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略/TODO     # 只忽略此目录下的TODO文件，子目录中的TODO文件不忽略build/    # 忽略所有build目录下的文件，但如果是名为build的文件则不忽略doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略</code></pre>例如忽略下图的GPUImage.framework框架<pre><code>SystemVedio/GPUImage/GPUImage.framework</code></pre><img src="https://upload-images.jianshu.io/upload_images/1120923-8af29923ea45d7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6218590.png"></li></ul><p>只追踪某几个文件</p><pre><code>#忽略所有文件，注意放在开头/*#除src文件夹外!/src#除bin文件夹外!/bin #总的效果就是git只跟踪src和bin两个文件夹</code></pre><h1 id="merge-与-rebase-的区别"><a href="#merge-与-rebase-的区别" class="headerlink" title="merge 与 rebase 的区别"></a>merge 与 rebase 的区别</h1><blockquote><p>作者：王靖轩<br>链接：<a href="https://www.zhihu.com/question/36509119/answer/131513261" target="_blank" rel="noopener">https://www.zhihu.com/question/36509119/answer/131513261</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>搞清楚这个问题首先要搞清楚merge和rebase背后的含义。</p><h2 id="merge：会产生一次合并提交"><a href="#merge：会产生一次合并提交" class="headerlink" title="merge：会产生一次合并提交"></a>merge：会产生一次合并提交</h2><p>先看merge，官方文档给的说明是：<br>git-merge - Join two or more development histories together</p><p>顾名思义，当你想要两个分支交汇的时候应该使用merge。<br>根据官方文档给的例子，是master merge topic，如图：<br>A—B—C topic<br>/         \<br>D—E—F—G—H master<br>然而在实践中，在H这个commit上的merge经常会出现merge conflict。为了避免解决冲突的时候引入一些不必要的问题，工程中一般都会规定no conflict merge。比如你在github上发pull request，如果有conflict就会禁止merge。</p><p>所以才会有题主问的问题：在当前的topic分支，想要引入master分支的F、G commit上的内容以避免merge conflict，方便最终合并到master。</p><p>这种情况下用merge当然是一个选项。用merge代表了topic分支与master分支交汇，并解决了所有合并冲突。然而merge的缺点是引入了一次不必要的history join。如图：<br>A–B–C-X topic<br>/       / \<br>D—E—F—G—H master<br>其实仔细想一下就会发现，在引入master分支的F、G commit这个问题上，我们并没有要求两个分支必须进行交汇(join)，我们只是想避免最终的merge conflict而已。</p><h2 id="rebase：将其他分支的内容整合到当前分支，改变当前分支branch-out的位置"><a href="#rebase：将其他分支的内容整合到当前分支，改变当前分支branch-out的位置" class="headerlink" title="rebase：将其他分支的内容整合到当前分支，改变当前分支branch out的位置"></a>rebase：将其他分支的内容整合到当前分支，改变当前分支branch out的位置</h2><p>rebase是另一个选项。rebase的含义是改变当前分支branch out的位置。这个时候进行rebase其实意味着，将topic分支branch out的位置从E改为G，如图：<br>A—B—C topic<br>/<br>D—E—F—G master<br>在这个过程中会解决引入F、G导致的冲突，同时没有多余的history join。但是rebase的缺点是，改变了当前分支branch out的节点。如果这个信息对你很重要的话，那么rebase应该不是你想要的。rebase过程中也会有多次解决同一个地方的冲突的问题，不过可以用squash之类的选项解决。个人并不认为这个是rebase的主要问题。</p><p>综上，其实选用merge还是rebase取决于你到底是以什么意图来避免merge conflict。实践上个人还是偏爱rebase。一个是因为branch out节点不能改变的情况实在太少。另外就是频繁从master merge导致的冗余的history join会提高所有人的认知成本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC] &lt;/p&gt;
&lt;p&gt;#基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;指针：指向最新的提交&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="git" scheme="http://superkk.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac安装MQTT服务器</title>
    <link href="http://superkk.top/2017/03/03/Mac%E5%AE%89%E8%A3%85MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://superkk.top/2017/03/03/Mac安装MQTT服务器/</id>
    <published>2017-03-03T07:08:59.000Z</published>
    <updated>2019-08-29T09:07:04.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="emqttd-windows版安装"><a href="#emqttd-windows版安装" class="headerlink" title="emqttd windows版安装"></a>emqttd windows版安装</h1><p>具体以官方文档为主</p><ol><li>下载<a href="http://emqtt.io/docs/v2/install.html#installing-on-windows" target="_blank" rel="noopener">http://emqtt.io/docs/v2/install.html#installing-on-windows</a></li><li>进入下载后的bin目录下<br><code>cd C:\Users\kk\Desktop\emqttd\bin\</code><br>然后执行<br><code>emqttd console</code></li><li>进入Web管理控制台(Dashboard)<br>控制台地址: <a href="http://127.0.0.1:18083" target="_blank" rel="noopener">http://127.0.0.1:18083</a><br>默认用户: admin，密码：public</li></ol><a id="more"></a><h1 id="或者使用-mosquitto"><a href="#或者使用-mosquitto" class="headerlink" title="或者使用 mosquitto"></a>或者使用 mosquitto</h1><ol><li>安装<br><code>brew install mosquitto</code></li><li>配置服务器<br>进入目录<code>/usr/local/Cellar/mosquitto</code> 进入响应版本下目录，我这里是<code>1.4.11_2</code><br>找到<code>/etc/mosquitto/mosquitto.conf</code>文件，修改<code>mosquitto.conf</code>可以对服务器进行配置</li><li>启动服务器<br>进入sbin目录：<br><code>/usr/local/Cellar/mosquitto/1.4.11_2/sbin</code><br>然后执行：<br><code>./mosquitto -c /usr/local/Cellar/mosquitto/1.4.11_2/etc/mosquitto/mosquitto.conf -d</code></li></ol><p>参考：<a href="http://blog.csdn.net/pz0605/article/details/51970568" target="_blank" rel="noopener">http://blog.csdn.net/pz0605/article/details/51970568</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;emqttd-windows版安装&quot;&gt;&lt;a href=&quot;#emqttd-windows版安装&quot; class=&quot;headerlink&quot; title=&quot;emqttd windows版安装&quot;&gt;&lt;/a&gt;emqttd windows版安装&lt;/h1&gt;&lt;p&gt;具体以官方文档为主&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载&lt;a href=&quot;http://emqtt.io/docs/v2/install.html#installing-on-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://emqtt.io/docs/v2/install.html#installing-on-windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;进入下载后的bin目录下&lt;br&gt;&lt;code&gt;cd C:\Users\kk\Desktop\emqttd\bin\&lt;/code&gt;&lt;br&gt;然后执行&lt;br&gt;&lt;code&gt;emqttd console&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进入Web管理控制台(Dashboard)&lt;br&gt;控制台地址: &lt;a href=&quot;http://127.0.0.1:18083&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://127.0.0.1:18083&lt;/a&gt;&lt;br&gt;默认用户: admin，密码：public&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout高级</title>
    <link href="http://superkk.top/2016/11/09/Autolayout%E9%AB%98%E7%BA%A7/"/>
    <id>http://superkk.top/2016/11/09/Autolayout高级/</id>
    <published>2016-11-09T12:23:21.000Z</published>
    <updated>2019-08-29T09:02:37.964Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="intrinsicContentSize"><a href="#intrinsicContentSize" class="headerlink" title="intrinsicContentSize"></a>intrinsicContentSize</h1><p><code>Intrinsic Content Size</code>：固有大小。意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。</p><p>比如：大家都知道在使用 AutoLayout 的时候，<code>UILabel</code> 就不用指定尺寸大小，只需指定位置即可，就是因为，只要确定了文字内容，字体等信息，它自己就能计算出大小来。</p><blockquote><p><code>UILabel</code>，<code>UIImageView</code>，<code>UIButton</code> 等组件及某些包含它们的系统组件都有 Intrinsic Content Size 属性。</p></blockquote><h1 id="Content-Hugging-约束（不想变大约束）"><a href="#Content-Hugging-约束（不想变大约束）" class="headerlink" title="Content Hugging 约束（不想变大约束）"></a><code>Content Hugging</code> 约束（不想变大约束）</h1><p>如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要拉伸的时候拉伸。</p><h1 id="Content-Compression-Resistance-约束（不想变小约束）"><a href="#Content-Compression-Resistance-约束（不想变小约束）" class="headerlink" title="Content Compression Resistance 约束（不想变小约束）"></a><code>Content Compression Resistance</code> 约束（不想变小约束）</h1><p>如果组件的此属性优先级比另一个组件此属性优先级高的话，那么这个组件就保持不变，另一个可以在需要压缩的时候压缩。</p><p>例如：</p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-143170678a0a5d2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Top-Layout-Guide"><a href="#Top-Layout-Guide" class="headerlink" title="Top Layout Guide"></a><code>Top Layout Guide</code></h1><p><code>topLayoutGuide</code>属性表示不希望被透明的状态栏或导航栏遮挡的内容范围的最高位置。这个属性的值是它的length属性的值（topLayoutGuide.length）</p><p>这个值可能由当前的ViewController或这个ViewController所属的NavigationController或TabBarController决定，有如下情况：</p><ol><li>一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。</li><li>包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义：</li></ol><blockquote><ol><li>如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。</li><li>如果状态栏可见，topLayoutGuide表示状态栏的底部。</li><li>如果都不可见，表示ViewController的上边缘。</li></ol></blockquote><p>总之是屏幕上方任何遮挡内容的栏的最底部。</p><h1 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h1><p>*作用：取代<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>**</p><p><code>safeArea</code>是描述你的视图部分不被任何内容遮挡的方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/1120923-4bfd008744e885e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="改变布局的方法"><a href="#改变布局的方法" class="headerlink" title="改变布局的方法"></a>改变布局的方法</h1><h2 id="一、-setNeedsLayout与layoutIfNeeded"><a href="#一、-setNeedsLayout与layoutIfNeeded" class="headerlink" title="一、 setNeedsLayout与layoutIfNeeded"></a>一、 <code>setNeedsLayout</code>与<code>layoutIfNeeded</code></h2><p>更新Autolayout后，如何要立即刷新布局，还要依次调用以下两个方法</p><pre><code>// 立即刷新布局（自己和subview的）self.view.setNeedsLayout()self.view.layoutIfNeeded()</code></pre><p><code>setNeedsLayout</code>给当前 UIView 立一个 flag，以表示后续应该调用 <code>layoutSubviews</code>方法，以调整当前视图及其子视图的布局。</p><p><code>layoutIfNeeded</code>如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）</p><h2 id="二、-layoutSubviews"><a href="#二、-layoutSubviews" class="headerlink" title="二、 layoutSubviews"></a>二、 <code>layoutSubviews</code></h2><h3 id="触发时机——Frame改变就会触发，具体如下"><a href="#触发时机——Frame改变就会触发，具体如下" class="headerlink" title="触发时机——Frame改变就会触发，具体如下"></a>触发时机——Frame改变就会触发，具体如下</h3><ol><li><p>初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发</p></li><li><p>addSubview会触发layoutSubviews</p></li><li><p>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化</p></li><li><p>滚动一个UIScrollView会触发layoutSubviews</p></li><li><p>旋转Screen会触发父UIView上的layoutSubviews事件</p></li><li><p>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p></li></ol><h3 id="何时重写-layoutSubviews-方法"><a href="#何时重写-layoutSubviews-方法" class="headerlink" title="何时重写 layoutSubviews 方法"></a>何时重写 <code>layoutSubviews</code> 方法</h3><pre><code>当我们在某个类的内部调整子视图位置时，需要调用；如果你想要在外部设置subviews的位置，就不要重写。</code></pre><h2 id="三、sizeToFit"><a href="#三、sizeToFit" class="headerlink" title="三、sizeToFit"></a>三、<code>sizeToFit</code></h2><p>调用sizeToFit的时候，系统会根据内容的帮我布局一个它认为最合适的大小。</p><p>我们一般在不方便手动布局的时候才调用sizeToFit方法。比如</p><ol><li><p>navigationBar中对navigationItem的设置，（添加两个视图以上的控件到Item）</p></li><li><p>toolBar中的对UIBarButtonItem的设置（一般我们还要添加弹簧控件）</p></li></ol><p>上述两种场合就可以用sizeToFit这个方法，来让系统给我们做自动布局。（注意：如果就添加一个控件的话，我们直接设置fram也是可以的）</p><ol start="3"><li><p>在tabBar中我们不能手动的添加的子控件，因为tabBar是根据控制器系统默认自动添加的tabBarItem。（猜想系统可能也会自动调用了这个方法）</p></li><li><p>UILabel中添加文字，然后让调整label的大小来适应文字，我们也调用sizeToFit的方法。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;intrinsicContentSize&quot;&gt;&lt;a href=&quot;#intrinsicContentSize&quot; class=&quot;headerlink&quot; title=&quot;intrinsicContentSize&quot;&gt;&lt;/a&gt;intrinsicCont
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
      <category term="高级" scheme="http://superkk.top/categories/iOS/%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS调试内存泄露</title>
    <link href="http://superkk.top/2016/10/18/iOS%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://superkk.top/2016/10/18/iOS调试内存泄露/</id>
    <published>2016-10-18T15:11:07.000Z</published>
    <updated>2019-08-29T09:07:04.735Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Xcode8使用Memory-Graph"><a href="#Xcode8使用Memory-Graph" class="headerlink" title="Xcode8使用Memory Graph"></a>Xcode8使用Memory Graph</h1><ul><li><p>第一步：真机下运行APP后，点击<br><img src="https://upload-images.jianshu.io/upload_images/1120923-296131fcf6ffee5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第二步：查看issue面板，注意选择右边Runtime<br><img src="https://upload-images.jianshu.io/upload_images/1120923-8ee8fe78474da0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第三步：查看可能出现的内存泄露<br>比如上图的 <code>1 instance of __NSMallocBlock_leaked</code>，点击后出现下图<br><img src="https://upload-images.jianshu.io/upload_images/1120923-7765184c6159e657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>原因在于如下代码</p><pre><code>group.didSelectedRowBlock = { [unowned self, group] row inguard let indexPaths = group.selectedIndexPaths else {return}if indexPaths.count &gt; 0 {self.shouldAdd = truelet row = (indexPaths.firstObject as! IndexPath).rowself.deviceAttri?.attrValue = String(row)} else {self.shouldAdd = false}}</code></pre><p>group的block中又使用了group，导致了循环引用，虽然使用了[unowned group]，事实证明并没有效果<br>最后的解决办法是修改didSelectedRowBlock的接口，直接将selectedIndexPaths参数传入block参数中:</p><pre><code>group.didSelectedRowBlock = { [unowned self] indexPaths inguard let indexPaths = indexPaths else {return}if indexPaths.count &gt; 0 {self.shouldAdd = trueself.deviceAttri?.attrValue = String(indexPaths.first!.row)} else {self.shouldAdd = false}}</code></pre></li><li>第四步：在 debug 页面查看内存泄露情况<br><img src="https://upload-images.jianshu.io/upload_images/1120923-5d076268da519675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>有叹号说明需要注意可能存在内存泄露，可以看到 CoreFoundation中也可能存在内存泄露情况</li></ul><h1 id="使用Instruments的Leaks工具"><a href="#使用Instruments的Leaks工具" class="headerlink" title="使用Instruments的Leaks工具"></a>使用Instruments的Leaks工具</h1><h2 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a><code>Time Profiler</code></h2><ul><li>查看多个线程里那些方法费时过多的方法</li><li>Call Tree上会默认按照费时的线程进行排序，单个线程中会也会按照对应的费时方法排序<br><img src="https://upload-images.jianshu.io/upload_images/1120923-b7b30c7aedac7d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h2 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a><code>Allocations</code></h2><ul><li>可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置</li><li>具体操作</li></ul><ol><li>在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，</li><li>切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，</li><li>这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。</li></ol><h2 id="Leak"><a href="#Leak" class="headerlink" title="Leak"></a>Leak</h2><p>可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的<code>Statistics&gt;Allocation Summary</code>能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。</p><h1 id="其他调试方法"><a href="#其他调试方法" class="headerlink" title="其他调试方法"></a>其他调试方法</h1><h2 id="勾选Address-Sanitizer可以在运行时看到坏内存访问情况"><a href="#勾选Address-Sanitizer可以在运行时看到坏内存访问情况" class="headerlink" title="勾选Address Sanitizer可以在运行时看到坏内存访问情况"></a>勾选<code>Address Sanitizer</code>可以在运行时看到坏内存访问情况</h2><p><img src="https://upload-images.jianshu.io/upload_images/1120923-a6440da959e589ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Xcode8使用Memory-Graph&quot;&gt;&lt;a href=&quot;#Xcode8使用Memory-Graph&quot; class=&quot;headerlink&quot; title=&quot;Xcode8使用Memory Graph&quot;&gt;&lt;/a&gt;Xcode8使用Memor
      
    
    </summary>
    
      <category term="iOS" scheme="http://superkk.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用WireShark 调试真机网络</title>
    <link href="http://superkk.top/2016/10/09/%E4%BD%BF%E7%94%A8WireShark-%E8%B0%83%E8%AF%95%E7%9C%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://superkk.top/2016/10/09/使用WireShark-调试真机网络/</id>
    <published>2016-10-09T07:09:37.000Z</published>
    <updated>2019-08-29T09:07:04.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用WireShark-调试真机网络"><a href="#使用WireShark-调试真机网络" class="headerlink" title="使用WireShark 调试真机网络"></a>使用WireShark 调试真机网络</h1><p>需求：调试UIWebView加载缓慢问题</p><ul><li><ol><li>获取iPhone的UDID<br><img src="https://upload-images.jianshu.io/upload_images/1120923-d7d6872480927c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol></li><li><p>2：根据获取的 UDID 创建一个虚拟的网卡<br><code>rvictl -s &lt;UDID&gt;</code><br><img src="https://upload-images.jianshu.io/upload_images/1120923-f7f78d28cb94eda6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>通过 <code>ifconfig</code> 可以看到多了一个 <code>rvi0</code>接口<br>通过 <code>rvictl -l</code> 命令可以列出所有挂接的虚拟接口</p><ul><li>3: 在 Wireshark 首页选择 rvi0，使用默认的 Capture Options 即可开始对 iPhone 进行抓包。<br><img src="https://upload-images.jianshu.io/upload_images/1120923-602c6eb7b8e0f13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>其中 iPhone 手机连接 WiFi 动态获取的 IP 地址为 192.168.100.1。</p><blockquote><p>黑色的内容表示遇到错误，需要重点关注<br>关闭wifi，可以抓取移动网络数据包</p></blockquote><p>-4 ： 使用<code>rvictl  -x</code>命令删除虚拟接口, 使用 iPhone 的 UDID 作为参数。</p><h1 id="WireShark-抓包技巧"><a href="#WireShark-抓包技巧" class="headerlink" title="WireShark 抓包技巧"></a>WireShark 抓包技巧</h1><ul><li>第一步：找到请求网址的 IP 地址<br>方法一：用ping命令得到对应的IP地址（可能不对，此时要用方法二）<br><img src="https://upload-images.jianshu.io/upload_images/1120923-4ff29746a38a13a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>方法二：使用DNS包来确定IP地址</p><blockquote><p>注意手机上 DNS 解析的结果并不总是和电脑上的解析结果一致。这种情况下我们可以通过查看 DNS 数据包来确定<br>DNS 是基于 UDP 的协议，不会有 TCP 重传</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1120923-368232f0c1e87923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>第二步：过滤 IP 地址<br><img src="https://upload-images.jianshu.io/upload_images/1120923-78b3a639da943708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>第三步：确定端口号<br><img src="https://upload-images.jianshu.io/upload_images/1120923-730d2741f957db51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>注意红框中的 <strong>SourcePort</strong>，这是客户端端口。我们知道 HTTP 支持并发请求，不同的并发请求肯定是占用不同的端口。所以在图中看到的上下两个数据包，并非一定是请求与响应的关系，他们可能属于两个不同的端口，彼此之间毫无关系，只是恰好在时间上最接近而已。</p><blockquote><p>如果只想显示某个端口的数据，可以使用:</p></blockquote><p><code>ip.addr == 220.194.203.68 and tcp.dstport == 52914</code></p><blockquote><p>如果只想看 HTTP 协议的 GET 请求与响应，可以使用 </p></blockquote><p><code></code>ip.addr == 220.194.203.68 and (http.request.method == “GET” || http.response.code == 200)<code></code>来过滤。</p><blockquote><p>如果想看丢包方面的数据，可以用 </p></blockquote><p><code>ip.addr == 220.194.203.68 and (tcp.analysis.fast_retransmission || tcp.analysis.retransmission)</code></p><p><code># 参考</code></p><p><a href="http://ios.jobbole.com/93159/" target="_blank" rel="noopener">http://ios.jobbole.com/93159/</a></p><p><a href="http://blog.csdn.net/phunxm/article/details/38590561" target="_blank" rel="noopener">http://blog.csdn.net/phunxm/article/details/38590561</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用WireShark-调试真机网络&quot;&gt;&lt;a href=&quot;#使用WireShark-调试真机网络&quot; class=&quot;headerlink&quot; title=&quot;使用WireShark 调试真机网络&quot;&gt;&lt;/a&gt;使用WireShark 调试真机网络&lt;/h1&gt;&lt;p&gt;需求：调试U
      
    
    </summary>
    
      <category term="工具" scheme="http://superkk.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="iOS" scheme="http://superkk.top/tags/iOS/"/>
    
  </entry>
  
</feed>
